<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[geekzph's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://geekzph.github.io/"/>
  <updated>2017-09-17T15:55:45.000Z</updated>
  <id>http://geekzph.github.io/</id>
  
  <author>
    <name><![CDATA[geekzph]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[常见排序算法总结]]></title>
    <link href="http://geekzph.github.io/2017/09/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://geekzph.github.io/2017/09/17/常见排序算法总结/</id>
    <published>2017-09-17T14:55:22.000Z</published>
    <updated>2017-09-17T15:55:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_快速排序（Quick_Sort）">1. 快速排序（Quick Sort）</h3><p>快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。排序的趟数与原始序列有关。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">array</span>[end];</span><br><span class="line">    <span class="keyword">int</span> i = start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[j] &lt;= pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(<span class="built_in">array</span>[i+<span class="number">1</span>], <span class="built_in">array</span>[end]);</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Partition(<span class="built_in">array</span>,start, end);</span><br><span class="line">        quicksort(<span class="built_in">array</span>, start, index - <span class="number">1</span>);</span><br><span class="line">        quicksort(<span class="built_in">array</span>, index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快排的改进主要有三种方法：小数组使用插入排序、双枢轴（快速三向切分）、划分策略优化（五取样划分）。经过优化后的快速排序算法时间复杂度可以介于 O(N)O(N) 到 O(NlogN)O(NlogN) 之间，性能更优。</p>
<h3 id="2-_冒泡排序_(Bubble_Sort)">2. 冒泡排序 (Bubble Sort)</h3><p>冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。排序的趟数与原始序列有关。</p>
<p>由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是(a1 + an) * n / 2），也就是 O(n^2), 最好 O(n)。 空间复杂度是O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[j - <span class="number">1</span>] &gt; data[j])&#123;</span><br><span class="line">                swap(data[j - <span class="number">1</span>], data[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-_插入排序（Insertion_Sort）">3. 插入排序（Insertion Sort）</h3><p>插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。</p>
<p>因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是O(n^2),最好 O(n)。空间复杂度是O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; data[j] &gt; data[j + <span class="number">1</span>]; j--)</span><br><span class="line">            swap(data[j], data[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-_选择排序（Selection_Sort）">4. 选择排序（Selection Sort）</h3><p>选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。<br>元素间的比较次数与序列的初始状态无关，始终是 n(n-1)/2 次，所以时间复杂度始终是 O(n*n)</p>
<p>每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是O(n^2)。空间复杂度是O(n)。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void selection_sort(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="keyword">size</span>(); i++) &#123; <span class="comment">// position</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="keyword">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[<span class="keyword">min</span>]) &#123;</span><br><span class="line">                <span class="keyword">min</span> = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[<span class="keyword">min</span>];</span><br><span class="line">        nums[<span class="keyword">min</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-_希尔排序（Shell_Sort）">5. 希尔排序（Shell Sort）</h3><p>个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = nums.size() &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>) &#123; <span class="comment">// times</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; nums.size(); i++) &#123; <span class="comment">// position</span></span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i - gap;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                nums[j + gap] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-_归并排序（Merge_Sort）">6. 归并排序（Merge Sort）</h3><p>归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。</p>
<p>在merge_array过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是logn。所以这个算法最终时间复杂度是O(nlogn)，空间复杂度是O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_array</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> m, <span class="keyword">int</span> e, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lb = b, rb = m, tb = b;</span><br><span class="line">    <span class="keyword">while</span> (lb != m &amp;&amp; rb != e)</span><br><span class="line">        <span class="keyword">if</span> (nums[lb] &lt; nums[rb])</span><br><span class="line">            temp[tb++] = nums[lb++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[tb++] = nums[rb++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lb &lt; m)</span><br><span class="line">        temp[tb++] = nums[lb++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (rb &lt; e)</span><br><span class="line">        temp[tb++] = nums[rb++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b;i &lt; e; i++)</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> b, <span class="keyword">int</span> e, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (b + e) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (m != b) &#123;</span><br><span class="line">        merge_sort(nums, b, m, temp);</span><br><span class="line">        merge_sort(nums, m, e, temp);</span><br><span class="line">        merge_array(nums, b, m, e, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-_堆排序（Heap_Sort）">7. 堆排序（Heap Sort）</h3><p>堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。</p>
<p>堆执行一次调整需要O(logn)的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是O(nlogn)。空间复杂度是O(n)。建堆时间复杂度O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// build max heap</span></span><br><span class="line">        max_heapify(nums, i, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// heap sort</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        num[i] = nums[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = temp;</span><br><span class="line">        max_heapify(nums, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curr = beg;</span><br><span class="line">    <span class="keyword">int</span> child = curr * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; end &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[curr] &lt; nums[child]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[curr];</span><br><span class="line">            nums[curr] = nums[child];</span><br><span class="line">            num[child] = temp;</span><br><span class="line">            curr = child;</span><br><span class="line">            child = <span class="number">2</span> * curr + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_快速排序（Quick_Sort）">1. 快速排序（Quick Sort）</h3><p>快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[剑指offer(三)]]></title>
    <link href="http://geekzph.github.io/2017/08/24/%E5%89%91%E6%8C%87offer-%E4%B8%89/"/>
    <id>http://geekzph.github.io/2017/08/24/剑指offer-三/</id>
    <published>2017-08-24T03:13:13.000Z</published>
    <updated>2017-09-12T11:28:11.000Z</updated>
    <content type="html"><![CDATA[<p>41、和为S的两个数字<br>题目描述：输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>42、左旋字符串<br>题目描述：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>43、翻转单词顺序列<br>题目描述：牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>44、扑克牌顺子<br>题目描述：LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
<p>45、孩子们的游戏<br>题目描述：每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>46、求1+2+3+…+n<br>题目描述：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>47、不用加减乘除做加法<br>题目描述：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>48、把字符串转化为整数<br>题目描述：将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0<br>输入描述:<br>输入一个字符串,包括数字字母符号,可以为空<br>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0</p>
<p>49、数组中重复的数字<br>题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;<span class="keyword"></span><br><span class="line">public</span>:</span><br><span class="line">    // Parameters:</span><br><span class="line">    //        numbers:     an<span class="instruction"> array </span>of integers</span><br><span class="line">    //        length:      the length of<span class="instruction"> array </span>numbers</span><br><span class="line">    //        duplication:<span class="function"> (</span>Output<span class="function">)</span> the duplicated number in the<span class="instruction"> array </span>number</span><br><span class="line">    // Return value:       true<span class="instruction"> if </span>the input is valid,<span class="instruction"> and </span>there are some duplications in the<span class="instruction"> array </span>number</span><br><span class="line">    //                     otherwise false</span><br><span class="line">    bool<span class="function"> duplicate(</span>int numbers<span class="keyword">[</span>],<span class="instruction"> int </span>length, int* duplication<span class="function">)</span> &#123;</span><br><span class="line">       <span class="function"> if(</span>numbers == NULL || length &lt;= 0<span class="function">)</span></span><br><span class="line">           <span class="instruction"> return </span>false;</span><br><span class="line">       <span class="function"> for(</span>int i = 0; i &lt; length; ++i<span class="function">)</span>&#123;</span><br><span class="line">           <span class="function"> if(</span>numbers<span class="keyword">[</span>i] &lt; 0 || numbers<span class="keyword">[</span>i] &gt; length - 1<span class="function">)</span></span><br><span class="line">               <span class="instruction"> return </span>false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="function"> for(</span>int i = 0; i &lt; length; ++i<span class="function">)</span>&#123;</span><br><span class="line">           <span class="function"> while(</span>numbers<span class="keyword">[</span>i] != i<span class="function">)</span>&#123;</span><br><span class="line">               <span class="function"> if(</span>numbers<span class="keyword">[</span>i] == numbers<span class="keyword">[</span>numbers<span class="keyword">[</span>i]]<span class="function">)</span>&#123;</span><br><span class="line">                    *duplication = numbers<span class="keyword">[</span>i];</span><br><span class="line">                   <span class="instruction"> return </span>true;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                   <span class="instruction"> int </span>temp = numbers<span class="keyword">[</span>i];</span><br><span class="line">                    numbers<span class="keyword">[</span>i] = numbers<span class="keyword">[</span>temp];</span><br><span class="line">                    numbers<span class="keyword">[</span>temp] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">       <span class="instruction"> return </span>false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>50、构建乘积数组<br>题目描述：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em> A[1] </em> …<em> A[i-1]</em> A[i+1]<em> …</em>A[n-1]。不能使用除法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>51、正则表达式匹配<br>题目描述：请实现一个函数用来匹配包括’.’和’<em> ‘ 的正则表达式。模式中的字符’.’表示任意一个字符，而’</em> ‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab <em> ac </em> a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>52、表示数值的字符串<br>题目描述：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="number">53</span>、字符流中第一个不重复的字符</span><br><span class="line">题目描述：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符<span class="string">"go"</span>时，第一个只出现一次的字符是<span class="string">"g"</span>。当从该字符流中读出前六个字符“google<span class="string">"时，第一个只出现一次的字符是"</span>l<span class="string">"。</span></span><br><span class="line">输出描述:</span><br><span class="line">如果当前字符流没有存在出现一次的字符，返回<span class="preprocessor">#字符。</span></span><br></pre></td></tr></table></figure>
<p>class Solution<br>{<br>public:<br>  //Insert one char from stringstream<br>    int index = 0;<br>    int occurence[256];<br>    Solution() : index(0){<br>        for(int i = 0; i &lt; 256; ++i){<br>        occurence[i] = -1;<br>        }<br>    }</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span>
</span>{
     <span class="keyword">if</span>(occurence[ch] == -<span class="number">1</span>)
         occurence[ch] = index;
    <span class="keyword">if</span>(occurence[ch] &gt;= <span class="number">0</span>)
        occurence[ch] = -<span class="number">2</span>;
    index++;
}
</code></pre><p>  //return the first appearence once char in current stringstream<br>    char FirstAppearingOnce()<br>    {<br>        char ch = ‘\0’;<br>        int minindex = numeric_limits<int>::max();<br>        for(int i =0; i &lt; 256; ++i){<br>            if(occurence[i] &gt;= 0  &amp;&amp; occurence[i] &lt; minindex)<br>            ch = (char)i;<br>            minindex = occurence[i];<br>        }<br>         if(ch == ‘\0’)<br>            return ‘#’;<br>        return ch;<br>    }</int></p>
<p>};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">54</span>、链表中环的入口节点</span><br><span class="line">题目描述：一个链表中包含环，请找出该链表的环的入口结点。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">55</span>、删除链表中重复的点</span><br><span class="line">题目描述：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span> 处理后为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>class Solution {<br>public:<br>    ListNode<em> deleteDuplication(ListNode</em> pHead)<br>    {<br>        ListNode<em> DummyNode = new ListNode(0);<br>        DummyNode-&gt;next = pHead;<br>        if(pHead == NULL)<br>            return NULL;<br>        ListNode</em> head = DummyNode;<br>        while(head-&gt;next != NULL &amp;&amp; head-&gt;next-&gt;next != NULL){<br>            if(head-&gt;next-&gt;val == head-&gt;next-&gt;next-&gt;val){<br>                int val = head-&gt;next-&gt;val;<br>                while(head-&gt;next != NULL &amp;&amp; val == head-&gt;next-&gt;val)<br>                    head-&gt;next = head-&gt;next-&gt;next;<br>            }<br>            else{<br>                head = head-&gt;next;<br>            }    </p>
<pre><code>    }
    <span class="keyword">return</span> DummyNode-&gt;<span class="keyword">next</span><span class="comment">;</span>
}
</code></pre><p>};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">56</span>、二叉树的下一个节点</span><br><span class="line">题目描述：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>    TreeLinkNode<em> GetNext(TreeLinkNode</em> pNode)<br>    {</p>
<p>  if(pNode==NULL)<br>            return NULL;<br>        if(pNode-&gt;right!=NULL)<br>        {<br>            pNode=pNode-&gt;right;<br>            while(pNode-&gt;left!=NULL)<br>                pNode=pNode-&gt;left;<br>            return pNode;<br>        }<br>        while(pNode-&gt;next!=NULL)<br>        {<br>            TreeLinkNode *proot=pNode-&gt;next;<br>            if(proot-&gt;left==pNode)<br>                return proot;<br>            pNode=pNode-&gt;next;<br>        }<br>        return NULL;<br>    }<br>};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">57</span>、对称的二叉树</span><br><span class="line">题目描述：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>    bool isSymmetrical(TreeNode<em> pRoot)<br>    {<br>        return cmp(pRoot,pRoot);<br>    }<br>    bool cmp(TreeNode</em> root1, TreeNode* root2){<br>        if(root1 == NULL &amp;&amp; root2 == NULL)<br>            return true;<br>        if(root1 == NULL || root2 == NULL)<br>            return false;<br>        if(root1-&gt;val != root2-&gt;val)<br>            return false;</p>
<pre><code>    return <span class="function">cmp</span>(root1-&gt;<span class="attribute">left</span>, root2-&gt;<span class="attribute">right</span>) &amp;&amp; <span class="function">cmp</span>(root1-&gt;<span class="attribute">right</span>, root2-&gt;<span class="attribute">left</span>);
}
</code></pre><p>};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">58</span>、按之字形顺序打印二叉树</span><br><span class="line">题目描述：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>    vector<vector<int> &gt; Print(TreeNode<em> pRoot) {<br>       vector<vector<int> &gt; res;<br>            if(!pRoot)<br>                return res;<br>            queue&lt;TreeNode</vector<int></em>&gt; q1;<br>            q1.push(pRoot);<br>            int i = 0;<br>            while(!q1.empty()){<br>                vector<int> level;<br>                int my_size = q1.size();<br>                while(my_size != 0){<br>                    TreeNode* node = q1.front();<br>                    level.push_back(node-&gt;val);<br>                    q1.pop();<br>                    if(node-&gt;left != NULL)<br>                        q1.push(node-&gt;left);<br>                    if(node-&gt;right != NULL)<br>                        q1.push(node-&gt;right);<br>                    my_size–;<br>                }<br>                if(i % 2 == 0)<br>                    res.push_back(level);<br>                else{<br>                    reverse(level.begin(), level.end());<br>                    res.push_back(level);<br>                }<br>                ++i;<br>            }<br>            return res;<br>    }</int></vector<int></p>
<p>};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">59</span>、把二叉树打印成多行</span><br><span class="line">题目描述：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>        vector<vector<int> &gt; Print(TreeNode<em> pRoot) {<br>            vector<vector<int> &gt; res;<br>            if(!pRoot)<br>                return res;<br>            queue&lt;TreeNode</vector<int></em>&gt; q1;<br>            q1.push(pRoot);<br>            while(!q1.empty()){<br>                vector<int> level;<br>                int my_size = q1.size();<br>                while(my_size != 0){<br>                    TreeNode* node = q1.front();<br>                    level.push_back(node-&gt;val);<br>                    q1.pop();<br>                    if(node-&gt;left != NULL)<br>                        q1.push(node-&gt;left);<br>                    if(node-&gt;right != NULL)<br>                        q1.push(node-&gt;right);<br>                    my_size–;<br>                }<br>                res.push_back(level);<br>            }<br>            return res;<br>        }</int></vector<int></p>
<p>};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60</span>、序列化二叉树</span><br><span class="line">题目描述：请实现两个函数，分别用来序列化和反序列化二叉树</span><br><span class="line"></span><br><span class="line"><span class="number">61</span>、二叉搜索树的第K个结点</span><br><span class="line">题目描述：给定一颗二叉搜索树，请找出其中的第k大的结点。例如， <span class="number">5</span> / \ <span class="number">3</span> <span class="number">7</span> /\ /\ <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> 中，按结点数值大小顺序第三个结点的值为<span class="number">4</span>。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>    int count = 0;<br>public:<br>    TreeNode<em> KthNode(TreeNode</em> pRoot, int k)<br>    {<br>        TreeNode* node;<br>        if(pRoot == NULL)<br>            return NULL;<br>        node = KthNode(pRoot-&gt;left, k);<br>        if(node != NULL)<br>                return node;<br>        count++;<br>        if(count == k)<br>            return pRoot;<br>        node = KthNode(pRoot-&gt;right, k);<br>        if(node != NULL)<br>                return node;</p>
<pre><code>    <span class="keyword">return</span> <span class="literal">NULL</span><span class="comment">;</span>
}
</code></pre><p>};<br>```<br>62、数据流中的中位数<br>题目描述：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>63、滑动窗口的最大值<br>题目描述：给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p>64、矩阵中的路径<br>题目描述：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p>65、机器人的运动范围<br>题目描述：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>41、和为S的两个数字<br>题目描述：输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p>
<figure class=]]>
    </summary>
    
      <category term="剑指offer" scheme="http://geekzph.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[剑指offer(二)]]></title>
    <link href="http://geekzph.github.io/2017/08/24/%E5%89%91%E6%8C%87offer-%E4%BA%8C/"/>
    <id>http://geekzph.github.io/2017/08/24/剑指offer-二/</id>
    <published>2017-08-24T03:12:08.000Z</published>
    <updated>2017-09-19T00:59:25.000Z</updated>
    <content type="html"><![CDATA[<p>21、栈的压入弹出序列<br>题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pushV.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span> ;i &lt; pushV.size();)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push_back(pushV[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt; popV.size() &amp;&amp; <span class="built_in">stack</span>.back() == popV[j])&#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop_back();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>22、二叉树层次遍历<br>题目描述：从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="type">PrintFromTopToBottom</span>(<span class="type">TreeNode</span>* root) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        deque&lt;<span class="type">TreeNode</span>*&gt; dequeTreeNode;</span><br><span class="line">        dequeTreeNode.push_back(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(dequeTreeNode.size())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> *pNode = dequeTreeNode.front();</span><br><span class="line">            <span class="literal">result</span>.push_back(pNode-&gt;val);</span><br><span class="line">            dequeTreeNode.pop_front();</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left)</span><br><span class="line">                dequeTreeNode.push_back(pNode-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right)</span><br><span class="line">                dequeTreeNode.push_back(pNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>23、二叉搜索树的后序遍历序列<br>题目描述：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = r;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; l &amp;&amp; a[i - <span class="number">1</span>] &gt; a[r]) --i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= l; --j) <span class="keyword">if</span>(a[j] &gt; a[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(a, l, i - <span class="number">1</span>) &amp;&amp; (judge(a, i, r - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(a, <span class="number">0</span>, a.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>24、二叉树中和为某一值的路径<br>题目描述：输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; paths;</span><br><span class="line">        findPaths(root, sum, path, paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findPaths</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val == sum &amp;&amp; node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            paths.push_back(path);</span><br><span class="line">        findPaths(node-&gt;left, sum - node-&gt;val, path, paths);</span><br><span class="line">        findPaths(node-&gt;right, sum - node-&gt;val, path, paths);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>25、复杂链表的复制<br>题目描述：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RandomListNode* <span class="keyword">Clone</span>(RandomListNode* pHead)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!pHead) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        RandomListNode *currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode)&#123;</span><br><span class="line">            RandomListNode *node = <span class="keyword">new</span> RandomListNode(currNode-&gt;label);</span><br><span class="line">            node-&gt;next = currNode-&gt;next;</span><br><span class="line">            currNode-&gt;next = node;</span><br><span class="line">            currNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode)&#123;</span><br><span class="line">            RandomListNode *node = currNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(currNode-&gt;random)&#123;                </span><br><span class="line">                node-&gt;random = currNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            currNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        RandomListNode *pCloneHead = pHead-&gt;next;</span><br><span class="line">        RandomListNode *tmp;</span><br><span class="line">        currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode-&gt;next)&#123;</span><br><span class="line">            tmp = currNode-&gt;next;</span><br><span class="line">            currNode-&gt;next =tmp-&gt;next;</span><br><span class="line">            currNode = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>26、二叉搜索树与双向链表<br>题目描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>27、字符串的排列<br>题目描述：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="comment">//可以用递归来做</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.size()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">        Permutation(<span class="built_in">array</span>, str, <span class="number">0</span>);</span><br><span class="line">        sort(<span class="built_in">array</span>.begin(), <span class="built_in">array</span>.end());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;<span class="built_in">array</span>, <span class="built_in">string</span> str, <span class="keyword">int</span> begin)</span><span class="comment">//遍历第begin位的所有可能性</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==str.size()-<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">array</span>.push_back(str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin; i&lt;=str.size()-<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=begin &amp;&amp; str[i]==str[begin])<span class="comment">//有重复字符时，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(str[i], str[begin]);<span class="comment">//当i==begin时，也要遍历其后面的所有字符；</span></span><br><span class="line">                                    <span class="comment">//当i!=begin时，先交换，使第begin位取到不同的可能字符，再遍历后面的字符</span></span><br><span class="line">            Permutation(<span class="built_in">array</span>, str, begin+<span class="number">1</span>);<span class="comment">//遍历其后面的所有字符；</span></span><br><span class="line">             </span><br><span class="line">            swap(str[i], str[begin]);<span class="comment">//为了防止重复的情况，还需要将begin处的元素重新换回来</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>27、数组中超过一半的数<br>题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> partition(vector&lt;<span class="built_in">int</span>&gt; num, <span class="built_in">int</span> start, <span class="built_in">int</span> <span class="keyword">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> pivot = num[start];</span><br><span class="line">        <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; <span class="keyword">end</span> &amp;&amp; num[start] &lt;= pivot) ++start;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; <span class="keyword">end</span> &amp;&amp; num[<span class="keyword">end</span>] &gt;= pivot) --<span class="keyword">end</span>;</span><br><span class="line">            swap(num[start], num[<span class="keyword">end</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> MoreThanHalfNum_Solution(vector&lt;<span class="built_in">int</span>&gt; numbers) &#123;</span><br><span class="line">        <span class="built_in">int</span> len = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">int</span> mid = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = len - <span class="number">1</span>;</span><br><span class="line">    	<span class="built_in">int</span> <span class="built_in">index</span> = partition(numbers, start, <span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">index</span> <span class="comment">!= mid)&#123;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">index</span> &gt; mid)&#123;</span><br><span class="line">                <span class="keyword">end</span> = <span class="built_in">index</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">index</span> = partition(numbers, start, <span class="keyword">end</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                start = <span class="built_in">index</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">index</span> = partition(numbers, start, <span class="keyword">end</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> res = numbers[mid];</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;len; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == res)</span><br><span class="line">                ++<span class="built_in">count</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">count</span> * <span class="number">2</span> &lt;= len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> majorityNumber(vector&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> candidate, <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">count</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = nums[i];</span><br><span class="line">                <span class="keyword">count</span> ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidate == nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">count</span> ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">count</span> --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>28、最小的k个数<br>题目描述：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="keyword">struct</span> myComp&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = input.size();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>||k&gt;len) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>, myComp&gt; my_set;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span> (iter = input.begin(); iter != input.end(); ++iter) &#123;</span><br><span class="line">        <span class="keyword">if</span>(my_set.size() &lt; k)</span><br><span class="line">            my_set.insert(*iter);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>, myComp&gt;::iterator set_iter = my_set.begin();</span><br><span class="line">            <span class="keyword">if</span>(*iter &lt; *(my_set.begin()))&#123;</span><br><span class="line">                my_set.erase(set_iter);</span><br><span class="line">                my_set.insert(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(my_set.begin(),my_set.end());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>29、连续子数组最大和<br>题目描述：HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">array</span>[<span class="number">0</span>], tempsum = <span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">//注意初始值 不能设为0 防止只有负数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); i++) <span class="comment">//从1开始 因为0的情况在初始化时完成了</span></span><br><span class="line">        &#123;</span><br><span class="line">            tempsum = (tempsum &lt; <span class="number">0</span>) ? <span class="built_in">array</span>[i] : tempsum + <span class="built_in">array</span>[i];</span><br><span class="line">            sum = (tempsum &gt; sum) ? tempsum : sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>30、整数中1出现的次数<br>题目描述：求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123;</span><br><span class="line">        	<span class="keyword">int</span> a = n/m, b = n%m;</span><br><span class="line">        	ones += (a + <span class="number">8</span>) / <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span>) * (b + <span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>31、把数组排成最小的数<br>题目描述：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">         <span class="built_in">string</span> A=<span class="string">""</span>;</span><br><span class="line">         <span class="built_in">string</span> B=<span class="string">""</span>;</span><br><span class="line">         A+=to_string(a);</span><br><span class="line">         A+=to_string(b);</span><br><span class="line">         B+=to_string(b);</span><br><span class="line">         B+=to_string(a);</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">return</span> A&lt;B;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">string</span>  answer=<span class="string">""</span>;</span><br><span class="line">         sort(numbers.begin(),numbers.end(),cmp);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.size();i++)&#123;</span><br><span class="line">             answer+=to_string(numbers[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> answer;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>32、丑数<br>题目描述：把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">7</span>)<span class="keyword">return</span> index;</span><br><span class="line">        	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(index);</span><br><span class="line">        	res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>, i;</span><br><span class="line">        	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; index; ++i)</span><br><span class="line">        	&#123;</span><br><span class="line">            	res[i] = min(res[t2] * <span class="number">2</span>, min(res[t3] * <span class="number">3</span>, res[t5] * <span class="number">5</span>));</span><br><span class="line">            	<span class="keyword">if</span> (res[i] == res[t2] * <span class="number">2</span>)t2++;</span><br><span class="line">            	<span class="keyword">if</span> (res[i] == res[t3] * <span class="number">3</span>)t3++;</span><br><span class="line">            	<span class="keyword">if</span> (res[i] == res[t5] * <span class="number">5</span>)t5++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>33、第一次只出现一次的字符<br>题目描述：在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            hash[str[i]]++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>34、数组中的逆序对<br>题目描述：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>输入描述:<br>题目保证输入的数组中没有的相同的数字<br>数据范围：<br>    对于%50的数据,size&lt;=10^4<br>    对于%75的数据,size&lt;=10^5<br>    对于%100的数据,size&lt;=2*10^5</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>35、两个链表的第一个公共节点<br>题目描述：输入两个链表，找出它们的第一个公共结点。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ListLength(ListNode* list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">            list = list-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123;</span><br><span class="line">        <span class="keyword">int</span> list1_len = ListLength(pHead1);</span><br><span class="line">        <span class="keyword">int</span> list2_len = ListLength(pHead2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">step</span> = <span class="keyword">abs</span>(list1_len - list2_len);</span><br><span class="line">        <span class="keyword">if</span>(list1_len &lt; list2_len)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pHead2 != <span class="keyword">NULL</span> &amp;&amp; <span class="keyword">step</span> &gt;<span class="number">0</span> )&#123;</span><br><span class="line">                pHead2 = pHead2-&gt;<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">step</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2_len &lt; list1_len)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pHead1 != <span class="keyword">NULL</span> &amp;&amp; <span class="keyword">step</span> &gt;<span class="number">0</span> )&#123;</span><br><span class="line">                pHead1 = pHead1-&gt;<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">step</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list2_len &lt; list1_len)&#123;</span><br><span class="line">            <span class="keyword">while</span>(pHead1 != <span class="keyword">NULL</span> &amp;&amp; <span class="keyword">step</span> &gt;<span class="number">0</span> )&#123;</span><br><span class="line">                pHead1 = pHead1-&gt;<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">step</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span>(pHead1 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1 == pHead2) <span class="keyword">return</span> pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;<span class="keyword">next</span>;</span><br><span class="line">            pHead2 = pHead2-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>36、数字在排序数组中出现的次数<br>题目描述：统计一个数字在排序数组中出现的次数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> GetFirstIndex(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="type">data</span>,<span class="built_in">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">data</span>.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = <span class="type">data</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">data</span>[mid] == k)</span><br><span class="line">            	<span class="keyword">end</span> = mid;</span><br><span class="line">        	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">data</span>[mid] &lt; k)</span><br><span class="line">            	start = mid;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">            	<span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="type">data</span>[start] == k) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">data</span>[<span class="keyword">end</span>] == k) <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> GetLastIndex(vector&lt;<span class="built_in">int</span>&gt; &amp;<span class="type">data</span>,<span class="built_in">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">data</span>.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = <span class="type">data</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">data</span>[mid] == k)</span><br><span class="line">            	start = mid;</span><br><span class="line">        	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="type">data</span>[mid] &lt; k)</span><br><span class="line">            	start = mid;</span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">            	<span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="type">data</span>[<span class="keyword">end</span>] == k) <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">data</span>[start] == k) <span class="keyword">return</span> start;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> GetNumberOfK(vector&lt;<span class="built_in">int</span>&gt; <span class="type">data</span> ,<span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">data</span>.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> first = GetFirstIndex(<span class="type">data</span>,k);</span><br><span class="line">        <span class="built_in">int</span> last = GetLastIndex(<span class="type">data</span>, k);</span><br><span class="line">        <span class="keyword">if</span>(first <span class="comment">!= -1 &amp;&amp; last != -1)&#123;</span></span><br><span class="line">             <span class="keyword">return</span> last - first + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>37、二叉树的深度<br>题目描述：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = TreeDepth(pRoot-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = TreeDepth(pRoot-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return (<span class="built_in">left</span>&gt;<span class="built_in">right</span>) ? (<span class="built_in">left</span>+<span class="number">1</span>) : (<span class="built_in">right</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>38、平衡二叉树<br>题目描述：输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> treeDepth(TreeNode *root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = treeDepth(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = treeDepth(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return ((<span class="built_in">left</span> &gt; <span class="built_in">right</span>) ? <span class="built_in">left</span> : <span class="built_in">right</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bool IsBalanced_Solution(TreeNode* root) &#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">NULL</span>) return <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = treeDepth(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = treeDepth(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        <span class="built_in">int</span> diff = <span class="built_in">left</span> - <span class="built_in">right</span>;</span><br><span class="line">        <span class="keyword">if</span>(diff &gt; <span class="number">1</span> || diff &lt; -<span class="number">1</span>)</span><br><span class="line">            return <span class="literal">false</span>;</span><br><span class="line">        return IsBalanced_Solution(root-&gt;<span class="built_in">left</span>) &amp;&amp; IsBalanced_Solution(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>39、数组中只出现一次的数字<br>题目描述：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//if(nums.size() == 0) return 0;</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            temp = temp ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastbit = temp - (temp &amp; (temp - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &amp; lastbit )</span><br><span class="line">            results[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            results[<span class="number">1</span>] ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>40、和为S的连续整数数列<br>题目描述：小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<br>输出描述:<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>21、栈的压入弹出序列<br>题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就]]>
    </summary>
    
      <category term="剑指offer" scheme="http://geekzph.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[剑指offer(一)]]></title>
    <link href="http://geekzph.github.io/2017/08/24/%E5%89%91%E6%8C%87offer-%E4%B8%80/"/>
    <id>http://geekzph.github.io/2017/08/24/剑指offer-一/</id>
    <published>2017-08-24T03:10:32.000Z</published>
    <updated>2017-08-24T03:14:20.000Z</updated>
    <content type="html"><![CDATA[<p>1、二维数组查找<br>题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt;= m - <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[x][y] &lt; target)</span><br><span class="line">                x++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[x][y] &gt; target)</span><br><span class="line">                y--;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2、替换空格<br>题目描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">void</span> replaceSpace(<span class="keyword">char</span> *<span class="keyword">str</span>,<span class="keyword">int</span> length) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> num_space = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> new_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> old_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">str</span>[i] != <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++old_length;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">str</span>[i] == <span class="string">' '</span>)</span><br><span class="line">                num_space++;</span><br><span class="line">            </span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		new_length = old_length + num_space * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(new_length &gt; length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(old_length &gt;=<span class="number">0</span> &amp;&amp; new_length &gt; old_length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">str</span>[old_length] == <span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">str</span>[new_length--] = <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">str</span>[new_length--] = <span class="string">'2'</span>;</span><br><span class="line">            	<span class="keyword">str</span>[new_length--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">str</span>[new_length--] = <span class="keyword">str</span>[old_length];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            old_length--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3、从尾到头打印链表<br>题目描述：输入一个链表，从尾到头打印链表每个节点的值。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; printListFromTailToHead(<span class="type">ListNode</span>* head) &#123;</span><br><span class="line">        std::stack &lt;<span class="type">ListNode</span>*&gt; nodes;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="type">ListNode</span>* p_node = head;</span><br><span class="line">        <span class="keyword">while</span>(p_node != <span class="type">NULL</span>)&#123;</span><br><span class="line">            nodes.push(p_node);</span><br><span class="line">                p_node = p_node -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            p_node = nodes.top();</span><br><span class="line">            <span class="literal">result</span>.push_back(p_node-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">            //cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4、重建二叉树<br>题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startIn &gt; endIn || startPre &gt; endPre)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==pre[startPre])&#123;</span><br><span class="line">            root-&gt;left = reConstructBinaryTree(pre, startPre+<span class="number">1</span>, endPre, in, startIn, i-<span class="number">1</span>);</span><br><span class="line">            root-&gt;right = reConstructBinaryTree(pre, i-startIn+startPre+<span class="number">1</span>, endPre, in, i+<span class="number">1</span>, endIn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">		TreeNode* root = reConstructBinaryTree(pre,<span class="number">0</span>,pre.size()-<span class="number">1</span>,vin,<span class="number">0</span>,vin.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5、用两个栈实现队列<br>题目描述：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                a = stack1.top();</span><br><span class="line">                stack2.push(a);</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> a ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6、旋转数组的最小数字<br>题目描述：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minNumberInRotateArray(vector&lt;<span class="built_in">int</span>&gt; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="type">target</span> = nums[<span class="keyword">end</span>];</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &lt;= <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="keyword">end</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>7、斐波那契数列<br>题目描述：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="type">Fibonacci</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fib1 = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> fib2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    	&#123;</span><br><span class="line">        	<span class="literal">result</span> = fib1 + fib2;</span><br><span class="line"></span><br><span class="line">        	fib1 = fib2;</span><br><span class="line">        	fib2 = <span class="literal">result</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>8、跳台阶<br>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> jumpFloor(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fib1 = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> fib2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="literal">result</span> = fib1 + fib2;</span><br><span class="line"> </span><br><span class="line">            fib1 = fib2;</span><br><span class="line">            fib2 = <span class="literal">result</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>9、变态跳台阶<br>题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>10、举行覆盖<br>题目描述：我们可以用2<em> 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em> 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> rectCover(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fib1 = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> fib2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (unsigned <span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="literal">result</span> = fib1 + fib2;</span><br><span class="line"> </span><br><span class="line">            fib1 = fib2;</span><br><span class="line">            fib2 = <span class="literal">result</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>11、二进制表示中1的个数<br>题目描述：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">int</span>  NumberOf1(<span class="keyword">int</span> n) &#123;</span><br><span class="line">         <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)&#123;</span><br><span class="line">             ++<span class="keyword">count</span>;</span><br><span class="line">             n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>12、数值的整数次方<br>题目描述：<br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    double <span class="type">Power</span>(double base, <span class="type">int</span> exponent) &#123;</span><br><span class="line">        double <span class="literal">result</span> = <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> absexp = exponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            absexp = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(base &gt; <span class="number">0</span> || base &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=absexp; ++i)&#123;</span><br><span class="line">                <span class="literal">result</span> *= base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>.<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="literal">result</span> = <span class="number">1</span>.<span class="number">0</span> /<span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>13、调整数组使奇数位于偶数之前<br>题目描述：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span> || size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">array</span>.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=<span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">array</span>[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">array</span>[j+<span class="number">1</span>]=<span class="built_in">array</span>[j];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">array</span>[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int temp = array[size - 1];</span></span><br><span class="line">        <span class="comment">//array[size - 1] = array[i + 1];</span></span><br><span class="line">        <span class="comment">//array[i + 1] = temp;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>14、链表中倒数第k个节点<br>题目描述：输入一个链表，输出该链表中倒数第k个结点</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* FindKthToTail(ListNode* pListHead, unsigned <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pListHead == <span class="keyword">NULL</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        ListNode *p1 = pListHead;</span><br><span class="line">        ListNode *p2 = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;next != <span class="keyword">NULL</span>)</span><br><span class="line">            	p1 = p1-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = pListHead;</span><br><span class="line">        <span class="keyword">while</span>(p1-&gt;next != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>15、翻转链表<br>题目描述：输入一个链表，反转链表后，输出链表的所有元素。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line">         <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		 ListNode *preversehead = <span class="literal">NULL</span>;</span><br><span class="line">         ListNode *pnode = pHead;</span><br><span class="line">         ListNode *pprev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pnode != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *pnext = pnode-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(pnext == <span class="literal">NULL</span>)</span><br><span class="line">                preversehead = pnode;</span><br><span class="line">            pnode-&gt;<span class="keyword">next</span> = pprev;</span><br><span class="line">            pprev = pnode;</span><br><span class="line">            pnode = pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preversehead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>16、合并两个排序的链表<br>题目描述：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* Merge(ListNode* list1, ListNode* list2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode *mergehead = <span class="keyword">NULL</span>;</span><br><span class="line">        ListNode *current = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">NULL</span> &amp;&amp; list2 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mergehead == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">                    mergehead = current = list1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    current-&gt;next = list1;</span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mergehead == <span class="keyword">NULL</span>)&#123;</span><br><span class="line">                    mergehead = current = list2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    current-&gt;next = list2;</span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">NULL</span>)</span><br><span class="line">            current-&gt;next = list2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current-&gt;next = list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> mergehead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>17、树的子结构<br>题目描述：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">bool</span> <span class="type">DoseTree1HaveTree2</span>(<span class="type">TreeNode</span> *pRoot1,<span class="type">TreeNode</span> *pRoot2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot2 == <span class="type">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1 == <span class="type">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val != pRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">DoseTree1HaveTree2</span>(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; <span class="type">DoseTree1HaveTree2</span>(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="type">HasSubtree</span>(<span class="type">TreeNode</span>* pRoot1, <span class="type">TreeNode</span>* pRoot2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> <span class="literal">result</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 != <span class="type">NULL</span> &amp;&amp; pRoot2 != <span class="type">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pRoot1-&gt;val == pRoot2-&gt;val)</span><br><span class="line">                <span class="literal">result</span> = <span class="type">DoseTree1HaveTree2</span>(pRoot1,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="literal">result</span>)</span><br><span class="line">                <span class="literal">result</span> = <span class="type">HasSubtree</span>(pRoot1-&gt;left,pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="literal">result</span>)</span><br><span class="line">                <span class="literal">result</span> = <span class="type">HasSubtree</span>(pRoot1-&gt;right,pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>18、二叉树镜像<br>题目描述<br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         / \  / \<br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           /  \<br>          10   6<br>         / \  / \<br>        11 9 7  5</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    void Mirror(TreeNode *pRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left == <span class="keyword">NULL</span> &amp;&amp; pRoot-&gt;right == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TreeNode *pTemp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = pTemp;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left)</span><br><span class="line">            Mirror(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;right)</span><br><span class="line">            Mirror(pRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>19、顺时针打印矩阵<br>题目描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line"></span><br><span class="line"> 		<span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 输入的二维数组非法，返回空的数组</span></span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>)  <span class="keyword">return</span> res;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 定义四个关键变量，表示左上和右下的打印范围</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, top = <span class="number">0</span>, right = col - <span class="number">1</span>, bottom = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// left to right</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i)  res.push_back(matrix[top][i]);</span><br><span class="line">            <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; ++i)  res.push_back(matrix[i][right]);</span><br><span class="line">            <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">if</span> (top != bottom)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i)  res.push_back(matrix[bottom][i]);</span><br><span class="line">            <span class="comment">// bottom to top</span></span><br><span class="line">            <span class="keyword">if</span> (left != right)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; --i)  res.push_back(matrix[i][left]);</span><br><span class="line">            left++,top++,right--,bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>20、含min函数的栈<br>题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m_data;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; m_min;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        m_data.push(value);</span><br><span class="line">        <span class="keyword">if</span>(m_min.size() == <span class="number">0</span> || value &lt; m_min.top())</span><br><span class="line">            m_min.push(value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            m_min.push(m_min.top());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_data.size()&gt;<span class="number">0</span> &amp;&amp; m_min.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            m_data.pop();</span><br><span class="line">            m_min.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> m_data.top();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> m_min.top();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>1、二维数组查找<br>题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight cpp"><t]]>
    </summary>
    
      <category term="剑指offer" scheme="http://geekzph.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 5]]></title>
    <link href="http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-5/"/>
    <id>http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-5/</id>
    <published>2017-08-24T02:01:31.000Z</published>
    <updated>2017-08-24T02:01:31.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 4]]></title>
    <link href="http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-4/"/>
    <id>http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-4/</id>
    <published>2017-08-24T02:01:16.000Z</published>
    <updated>2017-08-24T02:01:16.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 3]]></title>
    <link href="http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-3/"/>
    <id>http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-3/</id>
    <published>2017-08-19T10:48:52.000Z</published>
    <updated>2017-08-24T01:49:46.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 2]]></title>
    <link href="http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-2/"/>
    <id>http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-2/</id>
    <published>2017-08-19T10:48:44.000Z</published>
    <updated>2017-08-27T15:46:55.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>Group Anagrams ：把字符串中的顺序颠倒的同字母组成的词放在一起。 哈希表</li>
<li>Maximum Subarray ：在数组中找到连续子数组的最大和。 DP</li>
<li>Merge Intervals ：合并间隔数组。 排序，比较</li>
<li>Unique Paths ：左上到右下共有多少种走法 DP</li>
<li>Climbing Stairs ：爬楼梯 DP</li>
<li>Edit Distance ：编辑距离，删插换操作。 DP</li>
<li>Sort Colors :012数组排序 两个指针</li>
<li>Minimum Window Substring ：T找到包含S所有元素的子字符串 两个指针</li>
<li>Subsets ：求数组的所有子集 回溯</li>
<li>Word Search ：从二维数组中找到目标单词。 标记，递归</li>
<li>Largest Rectangle in Histogram ：求直方图最大矩形面积 单调栈</li>
<li>Maximal Rectangle ：0,1二维数组中求1组成的最大矩形面积 单调栈/逐层计算</li>
<li>Unique Binary Search Trees ：给定n，求所有二叉搜索树（BST） DP</li>
<li>Validate Binary Search Tree ：判断是否为BST 性质比较</li>
<li>Symmetric Tree ：二叉树自身是否镜像 DFS/BFS</li>
<li>Binary Tree Level Order Traversal ：层次遍历 DFS/BFS</li>
<li>Maximum Depth of Binary Tree ：二叉树深度 DFS</li>
<li>Construct Binary Tree ：根据前序中序还原二叉树 性质</li>
<li>Flatten Binary Tree to Linked List ：二叉树原地扁平化 DFS/从后往前排</li>
<li>Best Time to Buy and Sell Stock ：求股票最大收益 DP</li>
</ul>
<h3 id="Group_Anagrams_[34-7%]_[Medium]"><a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="external">Group Anagrams [34.7%] [Medium]</a></h3><ul>
<li>题意 : 给定一系列的字符串，将Anagrams(顺序颠倒的同字母组成的词)组合在一起。</li>
<li>例子 :<br>给定[“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>返回[[“ate”, “eat”, “tea”], [“nat”, “tan”], [“bat”]]</li>
<li>思路 ：利用对字符排序，用unordered_map存储，key就是排序后的字符串，value是multiset，用来放原字符串。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s : strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> t = s;</span><br><span class="line">            sort(t.begin(), t.end());</span><br><span class="line">            mp[t].insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; anagrams;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m : mp)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(m.second.begin(), m.second.end());</span><br><span class="line">            anagrams.push_back(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> anagrams;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Maximum_Subarray_[39-6%]_[Easy]"><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="external">Maximum Subarray [39.6%] [Easy]</a></h3><ul>
<li><p>题意 ：在数组中找到连续子数组（包含至少一个数字）的最大值</p>
</li>
<li><p>例子 :<br>给定[-2,1,-3,4,-1,2,1,-5,4]<br>返回[4,-1,2,1]的最大值sum = 6.</p>
</li>
<li>思路 ： 动态规划。维护两个变量，一个是全局最优，就是到当前元素为止最优的解是，一个是局部最优，就是必须包含当前元素的最优的解。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> * dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//dp[i] means the maximum subarray ending with A[i];</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = nums[i] + (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            maxsub = max(maxsub, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxsub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Merge_Intervals_[30-1%]_[Medium]"><a href="https://leetcode.com/problems/merge-intervals/description/" target="_blank" rel="external">Merge Intervals [30.1%] [Medium]</a></h3><ul>
<li><p>题意 ：给定一个间隔集合，合并所有重叠的间隔。</p>
</li>
<li><p>例子<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
</li>
<li>思路 ： 对区间按照start进行排序，然后遍历经过排序的区间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> Interval &amp;a,<span class="keyword">const</span> Interval &amp;b)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; ins) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ins.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;Interval&gt;&#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Interval&gt; res;</span><br><span class="line">        sort(ins.begin(), ins.end(), comp);</span><br><span class="line">        res.push_back(ins[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ins.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.back().end &lt; ins[i].start) res.push_back(ins[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.back().end = max(res.back().end, ins[i].end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Unique_Paths_[41-1%]_[Medium]"><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="external">Unique Paths [41.1%] [Medium]</a></h3><ul>
<li>题意 ：机器人位于m x n网格的左上角（在下图中标记为“开始”）。机器人只能在任何时间点向下或向右移动。 机器人正在尝试到达网格的右下角（在下图中标记为“完成”）。有多少可能的唯一路径在那里？</li>
<li>思路 ： dp经典题。对于格点(i,j)。由于只能从上格点(i-1,j)或左格点(i,j-1)到达，并且两者路径是不重复的。 dp[i][j] = dp[i-1]dp[j] + dp[i][j - 1] 。注意初始化边界值，边界只有一种走法。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i ==<span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Climbing_Stairs_[40-0%]_[Easy]"><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="external">Climbing Stairs [40.0%] [Easy]</a></h3><ul>
<li>题意 ：你正在爬楼梯，每次你可以爬1或2步，你可以爬多少个不同的方式爬上去？</li>
<li>解题思路 ： dp经典题。 dp[i] 表示以i结尾的楼梯有多少种爬法， dp[i] = dp[i - 1] + dp[i - 2]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> * dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Edit_Distance_[31-6%]_[Hard]"><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="external">Edit Distance [31.6%] [Hard]</a></h3><ul>
<li>题意 ：给出两个单词word1和word2，找到将word1转换为word2所需的最小步数。 （每个操作计为1步）您有以下3个操作允许一个字：<br>a）插入一个字符<br>b）删除一个字符<br>c）替换一个字符</li>
<li>例子</li>
<li>解题思路 ： 编辑距离，dp经典题。边界情况，一个单词为空，则另一个单词所需最小步数就是字符个数。 dp[i][j] 表示i长度的word1换成j长度的word2所需最小步数，则有3种情况：<br>c）替换操作：<br>如果当前字符相同，即i-1字符与j-1字符相同，那么无需操作， dp[i][j] = dp[i - 1][j - 1]<br>如果当前字符不同，即i-1字符与j-1字符不同，那么，只需c）操作，替换当前字符即可， dp[i][j] = dp[i - 1][j - 1] + 1<br>b）删除操作：<br>即把i字符直接删除， dp[i][j] = dp[i - 1][j] + 1<br>a)插入操作<br>即在j中插入i字符， dp[i][j] = dp[i][j - 1] + 1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + <span class="number">1</span>; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i- <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>));</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Sort_Colors_[37-9%]_[Medium]"><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="external">Sort Colors [37.9%] [Medium]</a></h3><ul>
<li>题意 ：给定一个n个对象颜色为红，白或蓝的数组，对它们进行排序，使相同颜色的对象相邻，颜色为红，白，蓝。在这里，我们将使用0，1和2的整数分别表示红色，白色和蓝色。</li>
<li>例子</li>
<li>思路 ： 由于只要三种颜色，可以设置两个index，一个red的index，一个blue的index，从两边往中间走。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> red = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> blue = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blue + <span class="number">1</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)</span><br><span class="line">                swap(nums[i++], nums[red++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)</span><br><span class="line">                swap(nums[i], nums[blue--]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Minimum_Window_Substring_[25-3%]_[Hard]"><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="external">Minimum Window Substring [25.3%] [Hard]</a></h3><ul>
<li><p>题意 ：给定字符串S和字符串T，找到S中的最小窗口，其中将包含T中的所有字符。复杂度O（n）。没有返回空字符串””</p>
</li>
<li><p>例子<br>S =“ADOBECODEBANC”<br>T =“ABC”<br>最小窗口为“BANC”。</p>
</li>
<li>思路 ：用map来表示T中有哪些字符及每个字符出现次数。window表示在fast和slow指针之间有哪些字符及出现次数。先找到fast的位置，再把slow像后移动，找到最小窗口。</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">string</span> minWindow(<span class="type">string</span> S, <span class="type">string</span> T) &#123;</span><br><span class="line">        <span class="type">string</span> <span class="literal">result</span>;</span><br><span class="line">    <span class="keyword">if</span>(S.empty() || T.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.length(); i++)&#123;</span><br><span class="line">        map[T[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> minLength = <span class="type">INT_MAX</span>;</span><br><span class="line">    <span class="type">int</span> letterCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>; fast &lt; S.length(); fast++)&#123;</span><br><span class="line">        <span class="type">char</span> c = S[fast];</span><br><span class="line">        <span class="keyword">if</span>(map.find(c) != map.<span class="keyword">end</span>())&#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] &lt;= map[c])&#123;</span><br><span class="line">                letterCounter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(letterCounter &gt;= T.length())&#123;</span><br><span class="line">            <span class="keyword">while</span>(map.find(S[slow]) == map.<span class="keyword">end</span>() || window[S[slow]] &gt; map[S[slow]])&#123;</span><br><span class="line">                window[S[slow]]--;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast - slow + <span class="number">1</span> &lt; minLength)&#123;</span><br><span class="line">                minLength = fast - slow + <span class="number">1</span>;</span><br><span class="line">                <span class="literal">result</span> = S.substr(slow, minLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Subsets_[40-5%]_[Medium]"><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="external">Subsets [40.5%] [Medium]</a></h3><ul>
<li><p>题意 ：给定一组不同的整数，nums，返回所有可能的子集。注意：解决方案集不能包含重复的子集。</p>
</li>
<li><p>例子<br>[1,2,3]<br>[[3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]</p>
</li>
<li>思路 ： 回溯，注意每个元素都要输出，而不是等遍历完再输出</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; subsets(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">sort</span>(nums.begin(), nums.end());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; subs;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; <span class="sub"><span class="keyword">sub</span>;</span></span><br><span class="line">        GenSubsets(nums, <span class="number">0</span>, <span class="sub"><span class="keyword">sub</span>, subs);</span></span><br><span class="line">        <span class="keyword">return</span> subs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void GenSubsets(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt; <span class="sub"><span class="keyword">sub</span>, vector&lt;vector&lt;int&gt;&gt; &amp;subs)</span><br><span class="line">    &#123;</span></span><br><span class="line">        subs.push_back(<span class="sub"><span class="keyword">sub</span>);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.push_back(nums[i]);</span></span><br><span class="line">            GenSubsets(nums, i + <span class="number">1</span>, <span class="sub"><span class="keyword">sub</span>, subs);</span></span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.pop_back();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Word_Search_[26-8%]_[Medium]"><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="external">Word Search [26.8%] [Medium]</a></h3><ul>
<li>题意 ：从二维数组中找到目标单词。该单词可以由顺序相邻单元的字母构成，其中“相邻”单元是水平或垂直相邻的单元。相同的字母单元不会被多次使用。</li>
<li>例子<br>给定<br>[<br>[‘A’,’B’,’C’,’E’],<br>[‘S’,’F’,’C’,’S’],<br>[‘A’,’D’,’E’,’E’]<br>]<br>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</li>
<li>思路 ：遍历二维数组，找到目标单词的第一个字母后，就递归地向四周查找，维护一个visited来确保不会重复。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; ++x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; ++y)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word[<span class="number">0</span>] == board[x][y] &amp;&amp; search(board, word, x, y, <span class="number">0</span>, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.size() || i &lt; <span class="number">0</span> || j &gt;= board[i].size() || j &lt; <span class="number">0</span> || board[i][j] != word[index] || visited[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(search(board, word, i-<span class="number">1</span>, j, index+<span class="number">1</span>, visited) || </span><br><span class="line">           search(board, word, i+<span class="number">1</span>, j, index+<span class="number">1</span>, visited) ||</span><br><span class="line">           search(board, word, i, j-<span class="number">1</span>, index+<span class="number">1</span>, visited) || </span><br><span class="line">           search(board, word, i, j+<span class="number">1</span>, index+<span class="number">1</span>, visited))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Largest_Rectangle_in_Histogram_[26-7%]_[Hard]"><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="external">Largest Rectangle in Histogram [26.7%] [Hard]</a></h3><ul>
<li>题意 ：给定表示每个条的宽度为1的直方图条高的n个非负整数，找到直方图中最大矩形的面积。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Maximal_Rectangle_[27-9%]_[Hard]"><a href="https://leetcode.com/problems/maximal-rectangle" target="_blank" rel="external">Maximal Rectangle [27.9%] [Hard]</a></h3><ul>
<li>题意 ：给定填充0和1的二维二进制矩阵，找到只有1的最大矩形并返回其区域。</li>
</ul>
<h3 id="Unique_Binary_Search_Trees_[41-0%]_[Medium]"><a href="https://leetcode.com/problems/unique-binary-search-trees" target="_blank" rel="external">Unique Binary Search Trees [41.0%] [Medium]</a></h3><ul>
<li>题意 ：给定n，存储值1 … n的结构唯一BST（二叉搜索树）有多少？</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">            dp[i] += dp[j-<span class="number">1</span>] * dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Validate_Binary_Search_Tree_[23-3%]_[Medium]"><a href="https://leetcode.com/problems/validate-binary-search-tree" target="_blank" rel="external">Validate Binary Search Tree [23.3%] [Medium]</a></h3><ul>
<li>题意 ：给定二叉树，确定它是否是有效的二叉搜索树（BST）。</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *lastNode = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isValidBST(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lastNode != <span class="keyword">NULL</span> &amp;&amp; lastNode-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        lastNode = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Symmetric_Tree_[38-8%]_[Easy]"><a href="https://leetcode.com/problems/symmetric-tree" target="_blank" rel="external">Symmetric Tree [38.8%] [Easy]</a></h3><ul>
<li>题意 ：给定一个二叉树，检查它是否是自己的镜像（即围绕其中心对称）。</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> helper(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(p-&gt;left,q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Binary_Tree_Level_Order_Traversal_[39-7%]_[Medium]"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal" target="_blank" rel="external">Binary Tree Level Order Traversal [39.7%] [Medium]</a></h3><ul>
<li>题意 ：给定一个二叉树，返回其节点值的层次遍历。（即从左到右，逐层）。</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; levelOrder(<span class="type">TreeNode</span>* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        queue&lt;<span class="type">TreeNode</span>*&gt; q1;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty())</span><br><span class="line">        &#123; </span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="type">int</span> my_size = q1.size();</span><br><span class="line">            <span class="keyword">while</span>(my_size != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span>* head = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                level.push_back(head-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left != <span class="type">NULL</span>)</span><br><span class="line">                    q1.push(head-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;right != <span class="type">NULL</span>)</span><br><span class="line">                    q1.push(head-&gt;right);</span><br><span class="line">                </span><br><span class="line">                my_size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">result</span>.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Maximum_Depth_of_Binary_Tree_[52-7%]_[Easy]"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="external">Maximum Depth of Binary Tree [52.7%] [Easy]</a></h3><ul>
<li>题意 ：给定一个二叉树，找到其最大深度。</li>
</ul>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maxDepth(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = maxDepth(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = maxDepth(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        </span><br><span class="line">        return <span class="built_in">left</span> &gt; <span class="built_in">right</span> ? <span class="built_in">left</span> + <span class="number">1</span>: <span class="built_in">right</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal_[32-2%]_[Medium]"><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="external">Construct Binary Tree from Preorder and Inorder Traversal [32.2%] [Medium]</a></h3><ul>
<li>题意 ：给定树的前序和中序遍历，构造二叉树。假定树中不存在重复项。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Flatten_Binary_Tree_to_Linked_List_[35-1%]_[Medium]"><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list" target="_blank" rel="external">Flatten Binary Tree to Linked List [35.1%] [Medium]</a></h3><ul>
<li>题意 ：给定一个二叉树，将其平坦化到原来的链表。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode* prev = <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = prev;</span><br><span class="line">    root-&gt;left = <span class="keyword">NULL</span>;</span><br><span class="line">    prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Best_Time_to_Buy_and_Sell_Stock_[41-2%]_[Easy]"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="external">Best Time to Buy and Sell Stock [41.2%] [Easy]</a></h3><ul>
<li>题意 ：有一个数组，第i个元素是第i天给定股票的价格。如果只允许最多完成一个交易（即购买一个交易并且卖出一个股票），则设计一个算法来找到最大利润。</li>
<li>例子</li>
</ul>
<p>输入：[7，1，5，3，6，4]<br>输出：5。最大差= 6-1 = 5（不是7-1 = 6，因为售价需要大于购买价格）<br>输入：[7，6，4，3，1]<br>输出：0。在这种情况下，没有交易完成，即最大利润= 0。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>Group Anagrams ：把字符串中的顺序颠倒的同字母组成的词放在一起。 哈希表</li>
<li>Maximum Subarray ：在数组中找到连续子数组的最大和。 DP</li>
<li>Merge Intervals ：合并间隔数组。 排序，比较<]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 1]]></title>
    <link href="http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-1/"/>
    <id>http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-1/</id>
    <published>2017-08-19T10:48:40.000Z</published>
    <updated>2017-08-24T01:37:22.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>Two Sum ：从数组中找到两个数相加和为目标值</li>
<li>Add Two Numbers ：将两个链表表示的数相加</li>
<li>Longest Substring Without Repeating Characters ：没有重复元素的最长子字符串</li>
<li>Median of Two Sorted Arrays ：找到两个有序数组的中位数</li>
<li>Longest Palindromic Substring ：最长回文子字符串</li>
<li>Regular Expression Matching ：判断表达式是否匹配，含有正则 . 和 * 。</li>
<li>Container With Most Water ：数组中任意两个点与x坐标组成的水桶，求最多能装多少水</li>
<li>3Sum ：数组中三个数能否相加后为0。求出所有组合，相同元素只算一次。</li>
<li>Letter Combinations of a Phone Number ：递归、回溯经典题</li>
<li>Remove Nth Node From End of List ：删除列表中从后往前数第n个结点</li>
<li>Valid Parentheses ：求括号是否符合规定。栈</li>
<li>Merge Two Sorted Lists ：合并两个有序链表。</li>
<li>Generate Parentheses ：给定括号对数，写出所有合法的组合。回溯</li>
<li>Merge k Sorted Lists ：合并k个有序链表。优先对队列或归并排序</li>
<li>Longest Valid Parentheses ：找括号合法的最长子字符串。栈</li>
<li>Search in Rotated Sorted Array ：在旋转有序数组中找目标值。二分查找</li>
<li>Search for a Range ：找到升序数组中目标值的范围。二分查找</li>
<li>Combination Sum ：在数组中找到所有可以相加得到目标值的组合。回溯</li>
<li>Trapping Rain Water ：接水量。左右指针</li>
<li>Permutations ：全排列。回溯</li>
</ul>
<h3 id="Two_Sum_[34-5%]_[Easy]"><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">Two Sum [34.5%] [Easy]</a></h3><ul>
<li>题意 ：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。假定只有一个解，不能使用相同元素两次。</li>
<li><p>例子 :<br>对于数组nums = [2, 7, 11, 15]，目标值target为9，</p>
<pre><code>因为nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>，所以返回[<span class="number">0</span>, <span class="number">1</span>]。
</code></pre></li>
<li>思路：两根指针分别从前，和从后想中间扫描</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; twoSum(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[start] + nums[<span class="keyword">end</span>]) == target)&#123;</span><br><span class="line">                <span class="literal">result</span>.push_back(start);</span><br><span class="line">                <span class="literal">result</span>.push_back(<span class="keyword">end</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] + nums[<span class="keyword">end</span>] &lt; target) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] + nums[<span class="keyword">end</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">end</span>--;</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Add_Two_Numbers[27-7%]_[Medium]"><a href="https://leetcode.com/problems/add-two-numbers" target="_blank" rel="external">Add Two Numbers[27.7%] [Medium]</a></h3><ul>
<li>题意 ：给定两个非空的链表，表示两个非负整数， 低位在前，高位在后 。将两个数字相加并作为链表返回。假定两个数字不包含任何前导零，除了数字0本身。</li>
<li>例子：<br>输入 (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出 7 -&gt; 0 -&gt; 8</li>
<li>思路：按链表依次相加，注意进位</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">      <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">      ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      ListNode* p1 = l1; </span><br><span class="line">      ListNode* p2 = l2;</span><br><span class="line">      ListNode* p3 = res;</span><br><span class="line">      <span class="keyword">while</span>(p1 != <span class="keyword">NULL</span> || p2 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p1 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">              carry += p1-&gt;val;</span><br><span class="line">              p1 = p1-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(p2 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">              carry += p2-&gt;val;</span><br><span class="line">              p2 = p2-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          p3-&gt;next = <span class="keyword">new</span> ListNode(carry % <span class="number">10</span>);</span><br><span class="line">          p3 = p3-&gt;next;</span><br><span class="line">          carry = carry / <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">      p3-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Longest_Substring_Without_Repeating_Characters_[24-3%]_[Medium]"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="external">Longest Substring Without Repeating Characters [24.3%] [Medium]</a></h3><ul>
<li>题意 ：求无重复字符的最长子字符串</li>
<li>例子：<br>给定“abcabcbb”，答案是“abc”，长度为3。<br>给定“bbbbb”，答案是“b”，长度为1。<br>给定“pwwkew”，答案是“wke”，长度为3。请注意，答案必须是子字符串，“pwke”是子序列而不是子字符串。</li>
<li>思路：假设子字符串有重复字符，则父字符串一定含有重复字符，单个子问题就可以决定父问题，因此可以用贪心法。从左到右扫描，当遇到重复字母时，以上一个重复字母index+1，作为新的搜索位置，知道最后一个字母，复杂度O(n);<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> ASCII_MAX = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">int</span> last[ASCII_MAX];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        fill(last, last + ASCII_MAX, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(last[s[i]] &gt;= start)&#123;</span><br><span class="line">                max_len = max(i - start, max_len);</span><br><span class="line">                start = last[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max((<span class="keyword">int</span>)s.size() - start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Median_of_Two_Sorted_Arrays_[21-7%]_[Hard]"><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays [21.7%] [Hard]</a></h3><ul>
<li>题意 ：找到两个排序数组的中位数。整体运行时间复杂度要求为O（log（m + n））。</li>
<li>例子：<br>nums1 = [1, 3]，nums2 = [2]<br>The median is 2.0<br>nums1 = [1, 2]，nums2 = [3, 4]<br>The median is (2 + 3)/2 = 2.5</li>
<li>思路：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Longest_Palindromic_Substring_[25-2%]_[Medium]"><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="external">Longest Palindromic Substring [25.2%] [Medium]</a></h3><ul>
<li>给定一个字符串s，找到s中最长的 回文子字符串 。假定s的最大长度为1000。</li>
<li>例子：<br>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer<br>Input: “cbbd”<br>Output: “bb”</li>
<li>思路：以每个字符的中间向两边扩展，如果左右相等则增加距离。注意偶数回文字符串。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandFromCenter</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int len = 0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandFromCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandFromCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; end - start)&#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s.substr(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Regular_Expression_Matching_[24-1%]_[Hard]"><a href="https://leetcode.com/problems/regular-expression-matching" target="_blank" rel="external">Regular Expression Matching [24.1%] [Hard]</a></h3><ul>
<li>题意 ：判断表达式是否匹配，含有正则 . 和 <em> 。 . 匹配任何单个字符， </em> 匹配0个或多个前面的字符</li>
<li>例子：<br>isMatch(“aa”,”a”) ? false<br>isMatch(“aa”,”aa”) ? true<br>isMatch(“aaa”,”aa”) ? false<br>isMatch(“aa”, “a<em> “) ? true<br>isMatch(“aa”, “.</em> “) ? true<br>isMatch(“ab”, “.<em> “) ? true<br>isMatch(“aab”, “c</em> a* b”) ? true</li>
<li>思路：动态规划</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Container_With_Most_Water_[36-6%]_[Medium]"><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">Container With Most Water [36.6%] [Medium]</a></h3><ul>
<li><p>题意 ：给定一个非负整数数组，其中每个数表示坐标（i，ai）处的点。 绘制n条垂直线，使得线i的两个端点在（i，ai）和（i，0）处。 找到两条线，它们与x轴一起形成一个容器，使得容器含有最多的水。</p>
</li>
<li><p>例子：</p>
</li>
<li><p>思路 ： 两个指针分别在0和n - 1位置，记下此时的面积，比较这两个位置的大小，如果右边大，则左指针向右遍历；如果左边大，则右指针向左遍历。然后计算新的面积。保存最大的面积</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3Sum_[21-6%]_[Medium]"><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">3Sum [21.6%] [Medium]</a></h3><ul>
<li>题意 ：给定n个整数的数组S，S中是否有元素a，b，c，使得c + b + c = 0？ 找到数组中所有这样的三个元素，相同结果只记一次</li>
<li>例子 ：S = [-1, 0, 1, 2, -1, -4]，结果为[[-1, 0, 1], [-1, -1, 2]]</li>
<li>思路 ：转换成2Sum问题。对于S中所有的不同元素，求它们的twoSum，注意重复元素。</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; threeSum(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (start &gt; i + <span class="number">1</span> &amp;&amp; nums[start - <span class="number">1</span>] == nums[start]) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] &lt; target)</span><br><span class="line">                    start++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] &gt; target)</span><br><span class="line">                    <span class="keyword">end</span>--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] == target)&#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; triple;</span><br><span class="line">                    triple.push_back(nums[i]);</span><br><span class="line">                    triple.push_back(nums[start]);</span><br><span class="line">                    triple.push_back(nums[<span class="keyword">end</span>]);</span><br><span class="line">                    <span class="literal">result</span>.push_back(triple);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Letter_Combinations_of_a_Phone_Number_[34-4%]_[Medium]"><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="external">Letter Combinations of a Phone Number [34.4%] [Medium]</a></h3><ul>
<li>题意 ：给定一个数字字符串，返回数字可能代表的所有可能的字母组合。映射关系是手机的九宫格。</li>
<li>例子 ：<br>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</li>
<li>思路 ：回溯法<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">const</span> vector&lt;<span class="type">string</span>&gt; charmap &#123;<span class="string">" "</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="type">void</span> dfs(<span class="type">string</span>&amp; digits, <span class="type">int</span> start, <span class="type">string</span> path, vector&lt;<span class="type">string</span>&gt;&amp; <span class="literal">result</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == digits.size())&#123;</span><br><span class="line">            <span class="literal">result</span>.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> i : charmap[digits[start] - '<span class="number">0</span>'])</span><br><span class="line">            dfs(digits, start + <span class="number">1</span>, path + i, <span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">string</span>&gt; letterCombinations(<span class="type">string</span> digits) &#123;</span><br><span class="line">        vector&lt;<span class="type">string</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        dfs(digits, <span class="number">0</span>, <span class="string">""</span>, <span class="literal">result</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Remove_Nth_Node_From_End_of_List_[33-5%]_[Medium]"><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="external">Remove Nth Node From End of List [33.5%] [Medium]</a></h3><ul>
<li>题意：给定一个链表，要求删除 从尾部数起 第n个节点，只允许遍历一次。</li>
<li>例子：<br>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</li>
<li>思路 ：快慢指针。快指针先走n + 1个结点，然后快慢指针一起遍历，当快指针到null时，慢指针就指向n前面的点</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Valid_Parentheses_[33-3%]_[Easy]"><a href="https://leetcode.com/problems/valid-parentheses" target="_blank" rel="external">Valid Parentheses [33.3%] [Easy]</a></h3><ul>
<li>题意 ：给定一个仅包含字符’（’，’）’，’{‘，’}’，’[‘和’]’的字符串，确定输入字符串是否有效。</li>
<li>例子 无</li>
<li>思路 ：利用栈，当输入是左括号时，栈中压入对应的右括号；当输入是右括号时，比较栈顶与该右括号是否相同。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; op_stack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">                op_stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#123;'</span>)</span><br><span class="line">                op_stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>)</span><br><span class="line">                op_stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op_stack.empty() || op_stack.top() != c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                op_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> op_stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Merge_Two_Sorted_Lists_[39-0%]_[Easy]"><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="external">Merge Two Sorted Lists [39.0%] [Easy]</a></h3><ul>
<li>题意 ：合并两个有序链表</li>
<li>例子 无</li>
<li>思路 ：比较两个节点大小，小的节点放入新的链表中</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="keyword">NULL</span> &amp;&amp; l2 != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">NULL</span>) tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Generate_Parentheses_[45-0%]_[Medium]"><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="external">Generate Parentheses [45.0%] [Medium]</a></h3><ul>
<li>题意 ：给定n对括号，写一个函数来生成正确的括号的所有组合。</li>
<li>例子：<br>given n = 3, a solution set is:[“((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</li>
<li>思路 ：回溯</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; path, <span class="built_in">string</span> str, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.size() == max * <span class="number">2</span>)&#123;</span><br><span class="line">            path.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open &lt; max)</span><br><span class="line">            backtrack(path, str+<span class="string">"("</span>, open+<span class="number">1</span>, close, max);</span><br><span class="line">        <span class="keyword">if</span>(close &lt; open)</span><br><span class="line">            backtrack(path, str+<span class="string">")"</span>, open, close+<span class="number">1</span>, max);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        backtrack(path, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>Two Sum ：从数组中找到两个数相加和为目标值</li>
<li>Add Two Numbers ：将两个链表表示的数相加</li>
<li>Longest Substring Without Repeating Characters ：没有重复元素的最长子]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++虚函数的的实现]]></title>
    <link href="http://geekzph.github.io/2017/08/06/C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://geekzph.github.io/2017/08/06/C-虚函数的的实现/</id>
    <published>2017-08-06T15:50:42.000Z</published>
    <updated>2017-08-24T01:50:26.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="虚函数" scheme="http://geekzph.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="C++" scheme="http://geekzph.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不得不知的Linux命令]]></title>
    <link href="http://geekzph.github.io/2017/08/06/%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://geekzph.github.io/2017/08/06/不得不知的Linux命令/</id>
    <published>2017-08-06T15:50:18.000Z</published>
    <updated>2017-08-24T01:49:55.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="命令" scheme="http://geekzph.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://geekzph.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP协议那些事儿]]></title>
    <link href="http://geekzph.github.io/2017/08/06/TCP%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://geekzph.github.io/2017/08/06/TCP协议那些事儿/</id>
    <published>2017-08-06T15:49:52.000Z</published>
    <updated>2017-08-24T01:50:37.000Z</updated>
    <content type="html"><![CDATA[<p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看W.Richard Stevens的《TCP/IP 详解 卷1：协议》（当然，你也可以去读一下RFC793以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p>
<p>之所以想写这篇文章，目的有三个，</p>
<p>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。<br>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。<br>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。<br>所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。</p>
<p>我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<p>上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。<br>下篇中，重点介绍TCP的流迭、拥塞处理。<br>废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<p>TCP头格式<br>接下来，我们来看一下TCP头的格式</p>
<p>TCP头格式（图片来源）</p>
<p>你需要注意这么几点：</p>
<p>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。<br>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。<br>注意上图中的四个非常重要的东西：<br>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。<br>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。<br>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。<br>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。<br>关于其它的东西，可以参看下面的图示</p>
<p>（图片来源）</p>
<p>TCP的状态机<br>其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“TCP协议的状态机”（图片来源） 和 “TCP建链接”、“TCP断链接”、“传数据” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）</p>
<p>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<p>对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。<br>对于4次挥手，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</p>
<p>两端同时断连接（图片来源）</p>
<p>另外，有几个事情需要注意一下：</p>
<p>关于建连接时SYN超时。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。<br>关于SYN Flood攻击。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。<br>关于ISN的初始化。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – Wikipedia语条），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。<br>关于 MSL 和 TIME_WAIT。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》<br>关于TIME_WAIT数量太多。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫tcp_tw_reuse，另一个叫tcp_tw_recycle的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“It should not be changed without advice/request of technical experts”）。<br>关于tcp_tw_reuse。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下tcp_twsk_unique的源码 ）。我个人估计还是有一些场景会有问题。<br>关于tcp_tw_recycle。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 tcp_timewait_state_process）。<br>关于tcp_max_tw_buckets。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。<br>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（RFC 1122） </p>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个HTTP的KeepAlive有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<p>数据传输中的Sequence Number<br>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）</p>
<p>你可以看到，SeqNum的增加是和传输的字节数相关的。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p>注意：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<p>TCP重传机制<br>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<p>超时重传机制</p>
<p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<p>一种是仅重传timeout的包。也就是第3份数据。<br>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。<br>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<p>快速重传机制</p>
<p>于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p>
<p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<p>SACK 方法</p>
<p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》</p>
<p>Duplicate SACK – 重复收到数据的问题</p>
<p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。RFC-2883 里有详细描述和示例。下面举几个例子（来源于RFC-2883）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<p>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK<br>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK<br>示例一：ACK丢包</p>
<p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>Transmitted  Received    ACK Sent<br>Segment      Segment     (Including SACK Blocks)</p>
<p>3000-3499    3000-3499   3500 (ACK dropped)<br>3500-3999    3500-3999   4000 (ACK dropped)</p>
<h2 id="3000-3499_3000-3499_4000,_SACK=3000-3500">3000-3499    3000-3499   4000, SACK=3000-3500</h2><p> 示例二，网络延误</p>
<p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>Transmitted    Received    ACK Sent<br>Segment        Segment     (Including SACK Blocks)</p>
<p>500-999        500-999     1000<br>1000-1499      (delayed)<br>1500-1999      1500-1999   1000, SACK=1500-2000<br>2000-2499      2000-2499   1000, SACK=1500-2500<br>2500-2999      2500-2999   1000, SACK=1500-3000<br>1000-1499      1000-1499   3000</p>
<pre><code><span class="number">1000</span>-<span class="number">1499</span>   <span class="number">3000</span>, SACK=<span class="number">1000</span>-<span class="number">1500</span>
                       ---------
</code></pre><p>可见，引入了D-SACK，有这么几个好处：</p>
<p>1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p>
<p>2）是不是自己的timeout太小了，导致重传。</p>
<p>3）网络上出现了先发的包后到的情况（又称reordering）</p>
<p>4）网络上是不是把我的数据包给复制了。</p>
<p> 知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。</p>
<p>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看W.Richard Stevens的《TCP/IP 详解 卷1：协议》（]]>
    </summary>
    
      <category term="TCP" scheme="http://geekzph.github.io/tags/TCP/"/>
    
      <category term="网络" scheme="http://geekzph.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高频题目]]></title>
    <link href="http://geekzph.github.io/2017/08/06/%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/"/>
    <id>http://geekzph.github.io/2017/08/06/高频题目/</id>
    <published>2017-08-06T15:48:57.000Z</published>
    <updated>2017-08-30T17:21:29.000Z</updated>
    <content type="html"><![CDATA[<p>Single Number</p>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>思路：同过异或运算计算。a ^ a = 0, a ^ 0 = a, a ^ b ^ c = a ^ (b ^ c)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            res = res ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Single Number II</p>
<p>Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>思路：三进制异或运算</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int <span class="keyword">one</span>=0;</span><br><span class="line">        int <span class="keyword">two</span>=0;</span><br><span class="line">        int i,j,k;</span><br><span class="line">        <span class="keyword">for</span>(i=0; i&lt;nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">two</span> = <span class="keyword">two</span> |(<span class="keyword">one</span>&amp;nums[i]);</span><br><span class="line">            <span class="keyword">one</span> = <span class="keyword">one</span>^nums[i];</span><br><span class="line">            </span><br><span class="line">            int three = <span class="keyword">two</span>&amp;<span class="keyword">one</span>;</span><br><span class="line">            <span class="keyword">two</span> = <span class="keyword">two</span>^three;</span><br><span class="line">            <span class="keyword">one</span> = <span class="keyword">one</span>^three;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">one</span>|<span class="keyword">two</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Single Number III</p>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<p>思路：把数组分为两组，变为Single Number I.因为 a ^ b != 0.所以他们至少有一位不等。找到a和b不一定的以为，用这一位对数组分为两组。分别找数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">//if(nums.size() == 0) return 0;</span></span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            temp = temp ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastbit = temp - (temp &amp; (temp - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &amp; lastbit )</span><br><span class="line">            results[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            results[<span class="number">1</span>] ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Majority Element</p>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>思路：相同加1，不同减1；两两抵消</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> majorityElement(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> candidate, <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate = nums[i];</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(candidate == nums[i])</span><br><span class="line">                    <span class="keyword">count</span>++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">count</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> Majority Element II</p>
<p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.</p>
<p>思路：三三抵消</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; majorityElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> candidate1, candidate2;</span><br><span class="line">        <span class="keyword">int</span> count1, count2;</span><br><span class="line">        count1 = count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate1 == nums[i]) &#123;</span><br><span class="line">                count1 ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidate2 == nums[i]) &#123;</span><br><span class="line">                count2 ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate1 = nums[i];</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate2 = nums[i];</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 = count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == candidate1) &#123;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == candidate2) &#123;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> count1 &gt; count2 ? candidate1 : candidate2;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Best Time to Buy and Sell Stock<br>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Example 1:<br>Input: [7, 1, 5, 3, 6, 4]<br>Output: 5</p>
<p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2:<br>Input: [7, 6, 4, 3, 1]<br>Output: 0</p>
<p>In this case, no transaction is done, i.e. max profit = 0.</p>
<p>思路：遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=prices.size()-<span class="number">1</span>, ans=<span class="number">0</span>, maxp=prices[i];</span><br><span class="line">        <span class="keyword">for</span> (--i; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            ans=max(ans, maxp-prices[i]);</span><br><span class="line">            maxp=max(maxp, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Best Time to Buy and Sell Stock II<br>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>思路：枚举法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!prices.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size()-<span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])total+=prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Best Time to Buy and Sell Stock III</p>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>思路：两次扫描，先从左往右找出每个位置利润最大的点，再从右边往左找出利润最大点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; profits(prices.size());</span><br><span class="line">        <span class="keyword">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">        profits[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i)&#123;</span><br><span class="line">            profits[i] = max(profits[i - <span class="number">1</span>], prices[i] - buy);</span><br><span class="line">            buy = min(buy, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sell = prices[prices.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            best = max(best, sell - prices[i] + profits[i]);</span><br><span class="line">            sell = max(sell, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Maximum Subarray</p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<p>思路：动态规划dp[i] = nums[i] + (dp[i - 1] &gt; 0 ? dp[i - 1] : 0);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> * dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//dp[i] means the maximum subarray ending with A[i];</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = nums[i] + (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            maxsub = max(maxsub, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxsub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Maximum Subarray II</p>
<p>Given an array of integers, find two non-overlapping subarrays which have the largest sum.<br>The number in each subarray should be contiguous.<br>Return the largest sum.</p>
<p>Example<br>For given [1, 3, -1, 2, -1, 2], the two subarrays are [1, 3] and [2, -1, 2] or [1, 3, -1, 2] and [2], they both have the largest sum 7.</p>
<p>思路：两次扫描，先从左往右找出每个位置最大的点，再从右边往左找出每个位置最大点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * @param nums: A list of integers</span><br><span class="line">     * @return: An integer denotes the sum of max two non-overlapping subarrays</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTwoSubArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(nums.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i)&#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> pre = sum[<span class="number">0</span>];</span><br><span class="line">        left[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            left[i] = max(left[i - <span class="number">1</span>], sum[i] - pre);</span><br><span class="line">            pre = min(pre, sum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//vector&lt;int&gt; right(nums.size(), 0);</span></span><br><span class="line">        <span class="keyword">int</span> post = sum[nums.size()];</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">            best = max(best, post - sum[i] + left[i]);</span><br><span class="line">            post = max(post, sum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Minimum Subarray </p>
<p>Given an array of integers, find the subarray with smallest sum.<br>Return the sum of the subarray.</p>
<p>Example<br>For [1, -1, -2, 1], return -3.</p>
<p>思路：所有的数取反，用 Maximum Subarray 的方法做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * @param nums: a list of integers</span><br><span class="line">     * @return: A integer indicate the sum of minimum subarray</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            nums[i] = -nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> * dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//dp[i] means the maximum subarray ending with A[i];</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxsub = dp[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = nums[i] + (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            maxsub = max(maxsub, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -maxsub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Maximum Subarray Difference </p>
<p>Given an array with integers.<br>Find two non-overlapping subarrays A and B, which |SUM(A) - SUM(B)| is the largest.<br>Return the largest difference.</p>
<p>Example<br>For [1, 2, -3, 1], return 6.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Subarray Sum</p>
<p>Given an integer array, find a subarray where the sum of numbers is zero. Your code should return the index of the first number and the index of the last number.</p>
<p>Example<br>Given [-3, 1, 2, -3, 4], return [0, 2] or [1, 3].</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: A list <span class="keyword">of</span> integers</span><br><span class="line">     * @<span class="keyword">return</span>: A list <span class="keyword">of</span> integers includes the index <span class="keyword">of</span> the first number </span><br><span class="line">     *          <span class="keyword">and</span> the index <span class="keyword">of</span> the last number</span><br><span class="line">     */</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; subarraySum(vector&lt;<span class="type">int</span>&gt; nums)&#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        hash[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.find(sum) != hash.<span class="keyword">end</span>()) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">                <span class="literal">result</span>.push_back(hash[sum] + <span class="number">1</span>);</span><br><span class="line">                <span class="literal">result</span>.push_back(i);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Subarray Sum Closest</p>
<p>Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.</p>
<p>Example<br>Given [-3, 1, 1, -3, 5], return [0, 2], [1, 3], [1, 1], [2, 2] or [0, 4].</p>
<p>思路：前缀和数组排序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Two Sum</p>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; twoSum(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[start] + nums[<span class="keyword">end</span>]) == target)&#123;</span><br><span class="line">                <span class="literal">result</span>.push_back(start);</span><br><span class="line">                <span class="literal">result</span>.push_back(<span class="keyword">end</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] + nums[<span class="keyword">end</span>] &lt; target) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] + nums[<span class="keyword">end</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">end</span>--;</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; twoSum(vector&lt;<span class="type">int</span>&gt; numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.find(target - numbers[i]) != hash.<span class="keyword">end</span>())&#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">                <span class="literal">result</span>.push_back(hash[target - numbers[i]] + <span class="number">1</span>);</span><br><span class="line">                <span class="literal">result</span>.push_back(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hash[numbers[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Two Sum II - Input array is sorted</p>
<p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3Sum</p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note: The solution set must not contain duplicate triplets.</p>
<p>For example, given array S = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; threeSum(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (start &gt; i + <span class="number">1</span> &amp;&amp; nums[start - <span class="number">1</span>] == nums[start]) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] &lt; target)</span><br><span class="line">                    start++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] &gt; target)</span><br><span class="line">                    <span class="keyword">end</span>--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] == target)&#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; triple;</span><br><span class="line">                    triple.push_back(nums[i]);</span><br><span class="line">                    triple.push_back(nums[start]);</span><br><span class="line">                    triple.push_back(nums[<span class="keyword">end</span>]);</span><br><span class="line">                    <span class="literal">result</span>.push_back(triple);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3Sum Closest</p>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.<br>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4Sum</p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note: The solution set must not contain duplicate quadruplets.<br>For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.<br>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Sqrt(x)</p>
<p>Implement int sqrt(int x).<br>Compute and return the square root of x.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Single Number</p>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your a]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[链表]]></title>
    <link href="http://geekzph.github.io/2017/08/05/%E9%93%BE%E8%A1%A8/"/>
    <id>http://geekzph.github.io/2017/08/05/链表/</id>
    <published>2017-08-05T13:00:25.000Z</published>
    <updated>2017-08-24T01:50:20.000Z</updated>
    <content type="html"><![CDATA[<p>Remove Duplicates from Sorted List<br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="external">https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/</a></p>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.<br>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;next != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;val == node-&gt;next-&gt;val)&#123;</span><br><span class="line">                node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Remove Duplicates from Sorted List II<br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="external">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/</a><br>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.<br>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class <span class="constant">Solution </span>&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    <span class="constant">ListNode*</span> deleteDuplicates(<span class="constant">ListNode*</span> head) &#123;</span><br><span class="line">        if(head == <span class="constant">NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="constant">NULL;</span></span><br><span class="line">        <span class="constant">ListNode*</span> dummy = (<span class="constant">ListNode*</span>)malloc(sizeof(<span class="constant">ListNode)</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line">        head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;<span class="keyword">next</span> != <span class="constant">NULL </span>&amp;&amp; head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> != <span class="constant">NULL)</span>&#123;</span><br><span class="line">            if(head-&gt;<span class="keyword">next</span>-&gt;val == head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>-&gt;val)&#123;</span><br><span class="line">                int val = head-&gt;<span class="keyword">next</span>-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(head-&gt;<span class="keyword">next</span> != <span class="constant">NULL </span>&amp;&amp; head-&gt;<span class="keyword">next</span>-&gt;val == val)&#123;</span><br><span class="line">                    head-&gt;<span class="keyword">next</span> = head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                head = head-&gt;<span class="keyword">next</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Reverse Linked List<br><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="external">https://leetcode.com/problems/reverse-linked-list/description/</a><br>Reverse a singly linked list.</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = head-&gt;<span class="keyword">next</span>;</span><br><span class="line">            head-&gt;<span class="keyword">next</span> = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Reverse Linked List II<br><a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="external">https://leetcode.com/problems/reverse-linked-list-ii/description/</a><br>Reverse a linked list from position m to n. Do it in-place and in one-pass.<br>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,<br>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.<br>Note:<br>Given m, n satisfy the following condition:<br>1 ? m ? n ? length of list.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Partition List<br><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="external">https://leetcode.com/problems/partition-list/description/</a><br>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.<br>You should preserve the original relative order of the nodes in each of the two partitions.<br>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* partition(ListNode* head, <span class="keyword">int</span> x) &#123;</span><br><span class="line">        ListNode *leftDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *rightDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *leftTail = leftDummy;</span><br><span class="line">        ListNode *rightTail = rightDummy;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                leftTail-&gt;next = head;</span><br><span class="line">                leftTail = head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rightTail-&gt;next = head;</span><br><span class="line">                rightTail = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        leftTail-&gt;next = rightDummy-&gt;next;</span><br><span class="line">        rightTail-&gt;next = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftDummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Remove Linked List Elements<br><a href="https://leetcode.com/problems/remove-linked-list-elements/description/" target="_blank" rel="external">https://leetcode.com/problems/remove-linked-list-elements/description/</a><br>Remove all elements from a linked list of integers that have value val.<br>Example<br>Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6<br>Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5<br>Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="constant">Solution </span>&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    <span class="constant">ListNode*</span> removeElements(<span class="constant">ListNode*</span> head, int val) &#123;</span><br><span class="line">        <span class="regexp">//if</span>(head == <span class="constant">NULL)</span> <span class="keyword">return</span> <span class="constant">NULL;</span></span><br><span class="line">        <span class="constant">ListNode </span>*dummy = new <span class="constant">ListNode(</span><span class="number">0</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line">        head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;<span class="keyword">next</span> != <span class="constant">NULL)</span>&#123;</span><br><span class="line">            if(head-&gt;<span class="keyword">next</span>-&gt;val == val)&#123;</span><br><span class="line">                head-&gt;<span class="keyword">next</span> = head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            head = head-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Merge Two Sorted Lists<br><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="external">https://leetcode.com/problems/merge-two-sorted-lists/description/</a><br>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="keyword">NULL</span> &amp;&amp; l2 != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">NULL</span>) tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Merge k Sorted Lists<br><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="external">https://leetcode.com/problems/merge-k-sorted-lists/description/</a><br>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Sort List<br><a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="external">https://leetcode.com/problems/sort-list/description/</a><br>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>merge sort<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>quick sort</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Reorder List<br>Find the Middle of Linked List<br>Remove Nth Node<br>Linked List Cycle<br>Copy List with Random Pointer<br>Convert Sorted List to Balanced Binary Search Tree<br>Convert Array to Balanced Binary Search Tree</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Remove Duplicates from Sorted List<br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_bl]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二分搜索]]></title>
    <link href="http://geekzph.github.io/2017/08/05/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <id>http://geekzph.github.io/2017/08/05/二分搜索/</id>
    <published>2017-08-05T08:22:24.000Z</published>
    <updated>2017-08-24T01:50:03.000Z</updated>
    <content type="html"><![CDATA[<p>Classical Binary Search<br><a href="http://www.lintcode.com/en/problem/classical-binary-search/" target="_blank" rel="external">http://www.lintcode.com/en/problem/classical-binary-search/</a><br>Description:Find any position of a target number in a sorted array. Return -1 if target does not exist.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    /**</span><br><span class="line">     * @param A an <span class="type">integer</span> array sorted <span class="type">in</span> ascending order</span><br><span class="line">     * @param <span class="type">target</span> an <span class="type">integer</span></span><br><span class="line">     * @<span class="keyword">return</span> an <span class="type">integer</span></span><br><span class="line">     */</span><br><span class="line">    <span class="built_in">int</span> findPosition(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        // <span class="built_in">Write</span> your code here</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>First Position of Target<br><a href="http://www.lintcode.com/en/problem/first-position-of-target/#" target="_blank" rel="external">http://www.lintcode.com/en/problem/first-position-of-target/#</a><br>For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.<br>If the target number does not exist in the array, return -1.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: The <span class="type">integer</span> array.</span><br><span class="line">     * @param <span class="type">target</span>: <span class="type">Target</span> <span class="keyword">number</span> to find.</span><br><span class="line">     * @<span class="keyword">return</span>: The first <span class="keyword">position</span> of <span class="type">target</span>. <span class="keyword">Position</span> starts from <span class="number">0.</span> </span><br><span class="line">     */</span><br><span class="line">    <span class="built_in">int</span> binarySearch(vector&lt;<span class="built_in">int</span>&gt; &amp;nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        // <span class="built_in">write</span> your code here</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search a 2D Matrix<br><a href="https://leetcode.com/problems/search-a-2d-matrix/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-a-2d-matrix/#/description</a><br>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty() || <span class="built_in">array</span>[<span class="number">0</span>].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid  = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[mid][<span class="number">0</span>] == target)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[mid][<span class="number">0</span>] &lt; target)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[end][<span class="number">0</span>] &lt;= target)</span><br><span class="line">            index = end;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[start][<span class="number">0</span>] &lt;= target)</span><br><span class="line">            index = start;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid  = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[index][mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[index][mid] &lt; target)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[index][start] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[index][end] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> Search Insert Position<br> <a href="https://leetcode.com/problems/search-insert-position/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-insert-position/#/description</a></p>
<p> Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.<br>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> searchInsert(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        // <span class="built_in">Write</span> your code here</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &gt;= <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] &gt;= <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Find Minimum in Rotated Sorted Array<br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="external">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/</a><br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>Find the minimum element.<br>You may assume no duplicate exists in the array.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="type">target</span> = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt;= <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &lt;= <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="keyword">end</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search in Rotated Sorted Array<br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-in-rotated-sorted-array/#/description</a><br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>You are given a target value to search. If found in the array return its index, otherwise return -1.<br>You may assume no duplicate exists in the array.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> search(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid =  start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[start] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">target</span> &lt;= nums[mid] &amp;&amp; <span class="type">target</span> &gt;= nums[start])</span><br><span class="line">                    <span class="keyword">end</span> = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">target</span> &lt;= nums[<span class="keyword">end</span>] &amp;&amp; <span class="type">target</span> &gt;= nums[mid])</span><br><span class="line">                    start = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">end</span> = mid;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>) <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search in Rotated Sorted Array II<br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>Write a function to determine if a given target is in the array.<br>The array may contain duplicates.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Sqrt(x)<br><a href="https://leetcode.com/problems/sqrtx/#/description" target="_blank" rel="external">https://leetcode.com/problems/sqrtx/#/description</a><br>Implement int sqrt(int x).<br>Compute and return the square root of x.<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> mySqrt(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        long start = <span class="number">1</span>, <span class="keyword">end</span> = x;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            long <span class="built_in">mid</span> = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mid</span> * <span class="built_in">mid</span> &lt; x)</span><br><span class="line">                start = <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = <span class="built_in">mid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">end</span> * <span class="keyword">end</span> &lt;= x)</span><br><span class="line">            return (<span class="built_in">int</span>)<span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            return (<span class="built_in">int</span>)start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>First Bad Version<br><a href="https://leetcode.com/problems/first-bad-version/#/description" target="_blank" rel="external">https://leetcode.com/problems/first-bad-version/#/description</a></p>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.<br>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.<br>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                end = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(start))</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Wood Cut<br><a href="http://www.lintcode.com/en/problem/wood-cut/" target="_blank" rel="external">http://www.lintcode.com/en/problem/wood-cut/</a><br>Given n pieces of wood with length L[i] (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L &amp; k, return the maximum length of the small pieces.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     *@param L: Given n pieces of wood with length L[i]</span><br><span class="line">     *@param k: An integer</span><br><span class="line">     *return: The maximum length of the small pieces.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>  <span class="title">ok</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L, <span class="keyword">int</span> mid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mid) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = L.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt += L[i] / mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">woodCut</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span> l =<span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = L.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            r = max(r, L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (ok(L, mid, k)) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; </span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Find Peak Element<br><a href="https://leetcode.com/problems/find-peak-element/#/description" target="_blank" rel="external">https://leetcode.com/problems/find-peak-element/#/description</a><br>A peak element is an element that is greater than its neighbors.<br>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.<br>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br>You may imagine that num[-1] = num[n] = -∞.<br>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findPeakElement(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="literal">empty</span>()) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">mid</span> - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">end</span> = <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">mid</span> - <span class="number">1</span>])</span><br><span class="line">                start = <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = <span class="built_in">mid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &lt; nums[<span class="keyword">end</span>])</span><br><span class="line">            return <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            return start;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search for a Range<br><a href="https://leetcode.com/problems/search-for-a-range/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-for-a-range/#/description</a><br>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br>If the target is not found in the array, return [-1, -1].<br>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; searchRange(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; nores;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; res;</span><br><span class="line">        nores.push_back(-<span class="number">1</span>);</span><br><span class="line">        nores.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> nores;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(start);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(start);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Count of Smaller Numbers After Self<br><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/#/description" target="_blank" rel="external">https://leetcode.com/problems/count-of-smaller-numbers-after-self/#/description</a></p>
<p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].<br>Example:<br>Given nums = [5, 2, 6, 1]<br>To the right of 5 there are 2 smaller elements (2 and 1).<br>To the right of 2 there is only 1 smaller element (1).<br>To the right of 6 there is 1 smaller element (1).<br>To the right of 1 there is 0 smaller element.<br>Return the array [2, 1, 1, 0].</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Recover Rotated Sorted Array<br><a href="http://www.lintcode.com/en/problem/recover-rotated-sorted-array/" target="_blank" rel="external">http://www.lintcode.com/en/problem/recover-rotated-sorted-array/</a><br>Given a rotated sorted array, recover it to sorted array in-place.<br>Have you met this question in a real interview? Yes<br>Clarification<br>What is rotated array?<br>For example, the orginal array is [1,2,3,4], The rotated array of it can be [1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]<br>Example<br>[4, 5, 1, 2, 3] -&gt; [1, 2, 3, 4, 5]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Roate String<br><a href="http://www.lintcode.com/en/problem/rotate-string/" target="_blank" rel="external">http://www.lintcode.com/en/problem/rotate-string/</a><br>Given a string and an offset, rotate string by offset. (rotate from left to right)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Classical Binary Search<br><a href="http://www.lintcode.com/en/problem/classical-binary-search/" target="_blank" rel="external">http://ww]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[进程间通信概述]]></title>
    <link href="http://geekzph.github.io/2017/07/05/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/"/>
    <id>http://geekzph.github.io/2017/07/05/进程间通信概述/</id>
    <published>2017-07-05T11:49:33.000Z</published>
    <updated>2017-08-24T01:52:05.000Z</updated>
    <content type="html"><![CDATA[<p>进程间通信概述</p>
<p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间<br>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。<br>通知时间：一个进程需要向另一个或一组进程发送消息，通知他们发生了某些事件（如进程终止时要通知父进程）<br>资源共享：多个进程之间共享同样的资源，为了做到这一点，需要内核提供锁和同步机制<br>进程控制：有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入的异常，并能够及时指导它的状态改变。<br>进程间通信方式</p>
<p>管道(pipe)，有名管道(FIFO)<br>信号(signal)<br>共享内存(shared memory)<br>消息队列(message queue)<br>信号量(semaphore)<br>套接字(socket)<br>管道</p>
<p>管道针对本地计算机的两个进程之间的通信而设计的通信方式，管道建立后，实际获得两个文件描述符：一个用于读取另一个用于写入。<br>常见的IPC机制，通过pipe系统调用。<br>管道单工，数据只能向一个方向流动。双向通信时，需要建立两个管道。<br>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道的缓冲区的尾部，每次都是从缓冲区的头部读出数据。<br>管道的分类</p>
<p>匿名管道<br>关系进程，父子或兄弟<br>由pipe系统调用，管道由父进程建立<br>管道位于内核空间，其实是一块缓存<br>有名管道（FIFO）<br>两个没有任何关系的进程之间通信可通过有名管道进行数据传输<br>通过系统调用mkfifo创建<br>管道创建</p>
<p>#include<unistd.h><br>int pipe(int fd[2]);<br>//返回：0成功，-1出错<br>两个文件描述符数组<br>fd[0]:pipe的读端<br>fd[1]:pipe的写端<br>共享内存</unistd.h></p>
<p>共享内存区域是被多个进程共享的一部分物理内存。<br>多个进程都可以把共享内存映射到自己的虚拟空间。所有用户空间的进程要操作共享内存，都要将其映射到自己的虚拟空间，通过映射的虚拟内存空间地址去操作共享内存，从而达到进程间的数据通信。<br>共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容<br>本身不提供同步机制，可通过信号量进行同步<br>提升数据处理效率，一种效率最高的IPC机制<br>共享内存属性信息</p>
<p>struct shmid_ds{<br>    struct ipc_perm shm_perm;<br>    size_t shm_semsz;//共享内存大小<br>    pid_t shm_lpid;//最后一次调用系统pid<br>    pid_t shm_cpid;//pid的创建者的id<br>    shmatt_t shm_nattch;//和共享内存成功映射的数量<br>    time_t shm_atime;//最后一个成功映射的时间<br>    time_t shm_dtime;//最后断开映射的时间<br>    time_t shm_ctime;//最后改变的时间<br>}<br>共享内存使用步骤</p>
<p>使用shmget()函数创建共享内存<br>使用shmat()函数映射共享内存，将这段创建的共享内存映射到具体的进程虚拟内存空间<br>创建共享内存</p>
<p>#include <sys shm.h=""><br>itn shmget(key_t key,size_t size,int shmflag);<br>//返回，成功返回内核中共享内存的表示iD，失败返回-1.<br>参数<br>key:用户指定的共享内存键值<br>size:共享内存大小<br>shmflg:IPC_CREAT,IPC_EXCL等权限组合<br>erron<br>EINVAL(无效的内存段大小)<br>EEXIST(内存段已经存在，无法创建)<br>EIDRM(内存段已经被删除)<br>ENOENT(内存段不存在)<br>EACCES(权限不够)<br>ENOMEM(没有足够内存创建内存段)<br>共享内存控制</sys></p>
<p>#include<sys shm.h=""><br>int shmctl(int shmid,int cmd,struct shmid_ds *buf);<br>参数<br>shmid:共享内存ID<br>buf:共享内存属性指针<br>cmd<br>IPC_STAT 获取共享内存段属性<br>IPC_SET 设置共享内存段属性<br>IPC_RMID 删除共享内存段<br>SHM_LOCK 锁定共享内存段页面<br>SHM_UNLOCK 解锁锁定<br>共享内存映射和解除</sys></p>
<p>#include<sys shm.h=""><br>void shmat(int shmid,char <em>shmaddr,int shmflg);<br>int shmdt(char  </em>shmaddr);<br>//失败返回-1<br>参数<br>shmid:共享内存ID<br>shmaddr:映射到进程虚拟内存空间的地址，系统自动分配<br>shmflg:弱shmaddr为0，shmflag也是0<br>SHM_RND<br>SHMLBA 地址为2的次方<br>SHM_RDONLY 只读方式连接<br>errno<br>EINVAL 无效的IPC ID值或无效的地址<br>ENOMEM 没有足够的内存<br>EACCES 权限不够<br>子进程不继承父进程创建的共享内存，大家是共享的，子进程继承父进程映射的地址。<br>消息队列</sys></p>
<p>消息队列是内核中的一个链表<br>用户进程将数据传输到内核后，内核重新添加一些如用户ID、组ID、读写进程的ID和优先级等相关信息后并打包成一个数据包称为消息<br>允许一个或多个进程往消息队列中读写消息，但一个消息只能被一个进程读取，读取完毕后自动删除<br>消息队列具有一定的FIFO的特性，消息可以按照顺序发送到队列中，也可以几种不同的方式从队列中读取。每一个消息队列在内核中用一个唯一的IPC标识ID表示<br>消息队列的实现包括创建和打开队列、发送消息、读取消息和控制消息队列四种操作。<br>消息队列属性</p>
<p>struct msqid_ds<br>{<br>    struct ipc_perm msg_perm;<br>    msgqnum_t msg_qnum; //消息数量<br>    msglen_t msg_qbytes; //消息最大字节数<br>    pid_t msg_lspid; //最后一次发送消息进程的pid<br>    pid_t msg_lrpid; //最后一次接收消息的pid<br>    pid_t msg_stime; //最后一次消息发送的时间<br>    pid_t msg_ctime; //最后一次消息改变的时间<br>}；<br>打开或创建消息队列</p>
<p>#include <sys msg.h=""><br>int msgget(key_t key,int flag);<br>//返回：如果成功，返回内核中消息队列的标识ID，出错返回-1<br>参数<br>key:用户指定的消息队列键值<br>flag:IPC CREAT,IPC EXCL等权限组合<br>若创建消息队列，key可以指定键值，也可以设置为IPC_PRIVATE(0)。若打开进行查询，则key不能为0，必须是一个非零的值，否则查询不到<br>消息队列控制</sys></p>
<p>#include <sys msg.h=""><br>int msgctl(int msgid,int cmd,struct msqid_ds *buf);<br>//返回：成功返回0,出错返回-1<br>参数<br>msgid：消息队列ID<br>buf：消息队列属性指针<br>cmd<br>IPC_STAT：获取消息队列的属性，取此队列的msqid_ds结构，并放在buf指向的结构中<br>IPC_SET：设置属性，按由buf只想的结构中的值，设置与此队列相关的结构中的字段<br>IPC_RMID：删除队列，从系统中删除该队列以及在队列上的所有数据。<br>发送消息</sys></p>
<p>#include <sys msg.h=""><br>int msgsnd(int msgqid,const void *ptr,size_t nbytes,int flag);<br>//成功返回0,出错返回-1</sys></p>
<p>ptr:<br>struct mymesg<br>{<br>    long mtype;//消息类型<br>    char mtext[512];//消息数据本身<br>};<br>nbytes 指定消息的大小，不包括mtype的大小<br>mtype指消息的类型，由一个整数来表示，且大于0<br>mtext消息数据本身<br>在Linux中，消息的最大长度是4056个字节，其中包括mtype，占4个字节<br>结构体mymesg用户可自定义，但第一个成员必须是mtype<br>参数flag<br>0：阻塞<br>IPC_NOWAIT:类似文件I/O的非阻塞<br>若消息队列满（或者是队列中的消息总数等于系统限制值，或队列中的字节数等于系统限制值），则指定IPC_NOWAIT使得msgsnd立即出错返回EAGAIN。如果指定0，则<br>阻塞直到有空间可以容纳要发送的消息<br>或从系统中删除了此队列<br>或捕捉到一个信号，并从信号处理程序返回<br>接收消息</p>
<p>#include <sys msg.h=""><br>ssize_t msgrcv(int msgqid,void *ptr,size_t nbytes,long type,int flag);<br>//成功返回消息数据部分的长度，出错返回-1<br>参数<br>magqid：消息队列的ID<br>ptr：指向存放消息的缓存<br>nbytes：消息缓存的大小，不包括mtype的大小。计算方式<br>nbytes=sizeof(struct mymesg)-sizeof(long)<br>type：消息类型<br>type==0：获得消息队列中的第一个消息<br>type&gt;0：获得消息队列中类型type的第一个消息<br>type&lt;0：获得消息队列中小于或等于type绝对值的消息<br>flag：0或者IPC_NOWAIT<br>信号量</sys></p>
<p>本质上是共享资源的数目，用来控制对共享资源的访问。<br>用于进程间的互斥和同步<br>每种恭喜那个资源对应一个信号量，为了便于大量共享资源的操作引入了信号量集，可对多有信号量一次性操作。对信号量集中所有的操作可以要求全部成功，也可以部分成功<br>二元信号量(信号灯)值为0和1<br>对信号量做PV操作<br>信号量集属性</p>
<p>#include<sysm.h></sysm.h></p>
<p>struct semid_ds<br>{<br>    struct ipc_perm sem_perm;<br>    unsigned short sem_nseme; //信号灯的数量<br>    time_t sem_otime; //最后一次操作的时间<br>    time_t sem_ctime; //最后一次改变的时间<br>};<br>创建信号量集</p>
<p>#include <sysm.h><br>int semget(key_t key,int nsems,int flag);<br>//返回：如果成功，返回信号量集ID，出错返回-1<br>参数<br>key:用户指定的信号量集键值<br>nsems:信号量集中信号量的个数<br>flag:IPC CREAT,IPC EXCL等权限组合<br>若创建消息队列，key可以指定键值，也可以设置为IPC_PRIVATE(0)。若打开进行查询，则key不能为0，必须是一个非零的值，否则查询不到<br>信号量集控制</sysm.h></p>
<p>#include <sys msg.h=""><br>int semctl(int semid,int semnum,int cmd,…//信号量集数组);<br>//返回：成功返回0,出错返回-1<br>union semun<br>{<br>    int val;<br>    struct semid_ds <em>buf;<br>    unsigned short </em>array;<br>}<br>参数<br>semid：信号量集ID<br>semnum：0表示对所有信号量操作，信号量标号从0开始。<br>val：防止获取或设置信号量集中某个信号量的值<br>buf：信号量属性指针<br>array：防止获取或设置信号量集中所有信号量的值<br>cmd<br>IPC_STAT：获取信号量的属性，取此队列的semid_ds结构，并放在buf指向的结构中<br>IPC_SET：设置属性，按由buf只想的结构中的值，设置与此信号量相关的结构中的字段<br>IPC_RMID：删除信号量，从系统中删除该信号量以及信号量上的所有数据。<br>信号量集操作</sys></p>
<p>#include<sysm.h><br>int semop(int semid,struct sembuf *sops,size_t nsops);<br>//成功返回0，失败返回-1</sysm.h></p>
<p>struct sembuf<br>{<br>    unsigned short sem_num; //信号量集标号<br>    short sem_op; //操作<br>    short sem_flg; //<br>}<br>参数<br>semid：信号量集ID<br>sops：sembuf结构体数组指针<br>nsops：第二个参数中结构体数组的长度<br>sem_num：信号量集中信号量的编号<br>sep_op：正数为v操作，负数为p操作，0表示对共享资源是否已用完的测试<br>sem_flg：SEM_UNDO标志，表示进程结束时，相应的操作将被取消，如果设置了该标志，那么在进程没有释放共享资源就退出时，内核将代为释放。<br>用于信号量集中信号量的PV操作<br>可用于进程见的互斥和同步</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>进程间通信概述</p>
<p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间<br>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。<br>通知时间：一个进程需要向另一个或一组进程发送消息，通知他们]]>
    </summary>
    
      <category term="IPC" scheme="http://geekzph.github.io/tags/IPC/"/>
    
      <category term="Linux" scheme="http://geekzph.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python并发编程之Gevent]]></title>
    <link href="http://geekzph.github.io/2017/07/03/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGevent/"/>
    <id>http://geekzph.github.io/2017/07/03/Python并发编程之Gevent/</id>
    <published>2017-07-03T11:57:20.000Z</published>
    <updated>2017-08-24T01:52:10.000Z</updated>
    <content type="html"><![CDATA[<p>##Gevent<br>gevent是一个基于libev的并发库。它为各种并发和网络相关的任务提供了整洁的API。,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效。</p>
<p>在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<blockquote>
<p>在任何时刻，只有一个协程在运行。</p>
</blockquote>
<p>这与multiprocessing或threading等提供真正并行构造的库是不同的。 这些库轮转使用操作系统调度的进程和线程，是真正的并行。</p>
<p>gevent 是基于 greenlet 的一个 python 库，它可以把 python 的内置线程用 greenlet 包装，这样在我们使用线程的时候，实际上使用的是协程，在上一个协程的例子里，协程 A 结束时，由协程 A 让位给协程 B ，而在 gevent 里，所有需要让位的协程都让位给主协程，由主协程决定运行哪一个协程，gevent 也会包装一些可能需要阻塞的方法，比如 sleep ，比如读 socket ，比如等待锁，等等，在这些方法里会自动让位给主协程，而不是由程序员显示让位，这样程序员就可以按照线程的模式进行线性编程，不需要考虑切换的逻辑。</p>
<p>##协程<br>要理解Gevent首先要理解协程，进程，线程，协程定义如下：</p>
<ul>
<li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</li>
<li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</li>
<li>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</li>
</ul>
<p>协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p>
<p>协程的本质上是：</p>
<blockquote>
<p>allowing multiple entry points for suspending and resuming execution at certain locations.<br>允许多个入口对程序进行挂起、继续执行等操作</p>
</blockquote>
<p>协程就是一种特殊的并发机制，其调度[就是指什么时候调用什么函数]完全由程序员指定，比如下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump_range</span><span class="params">(upper)</span>:</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; upper:</span><br><span class="line">        jump = <span class="keyword">yield</span> index</span><br><span class="line">        <span class="keyword">if</span> jump <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            jump = <span class="number">1</span></span><br><span class="line">        index += jump</span><br><span class="line">jump = jump_range(<span class="number">5</span>)</span><br><span class="line">print(jump)</span><br><span class="line">print(jump.send(<span class="keyword">None</span>))</span><br><span class="line">print(jump.send(<span class="number">3</span>))</span><br><span class="line">print(jump.send(<span class="keyword">None</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object jump_range at <span class="number">0x10e283518</span>&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>jump_range函数在执行的过程中终端，又继续了好几次，这就是协程。这有类似线程的context-switch，那么协程的好处在哪呢？</p>
<ul>
<li>thread之間需要context-switch，而且成本很高，但是coroutine之間的切換很快</li>
<li>coroutine的成本很低，可以很輕易的產生大量的coroutine</li>
<li>這些事情全是在同一個thread裡發生的，因此不會有race condition等問題發生 (還是可能會有)</li>
<li>thread的context-switch雖然我們可以進行某種程度的控制，但是很多部份還是得靠OS來決定要先排程哪個thread，而coroutine的執行是由我們自己控制的。</li>
</ul>
<p>下面两幅图说明他们的区别：</p>
<p>协程的本质就是在单一线程里的协程互相切换，因此也被成为微线程。协程适合于I/O密集型的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Copyright (c) 2009 Denis Bilenko. See LICENSE for details.</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""Spawn multiple workers and wait for them to complete"""</span></span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'http://www.google.com'</span>, <span class="string">'http://www.yandex.ru'</span>, <span class="string">'http://www.python.org'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># patches stdlib (including socket and ssl modules) to cooperate with other greenlets</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_head</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Starting %s'</span> % url</span><br><span class="line">    data = urllib2.urlopen(url).read()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s: %s bytes: %r'</span> % (url, len(data), data[:<span class="number">50</span>])</span><br><span class="line"></span><br><span class="line">jobs = [gevent.spawn(print_head, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">gevent.joinall(jobs)</span><br></pre></td></tr></table></figure>
<p>monkey.patch_all()，會有這行，是因為Python內建的各種函式庫裡的IO函式庫、及會阻塞住的函數，例如Sleep都會讓整個程式卡住，而不是利用Selector/epoll之類的功能來處理，所以monkey這個函式庫就是負責將Python內建的函式庫取代成以gevent的非同步形式的函式，如此一來當執行到那些IO之類的動作，會切到MainThread的coroutine進行排程，而非直接卡在那裡等結果，而當IO動作真的完成了，gevent內部會將該coroutine標示為可執行的，因此下次有機會就會排到那個coroutine，看到下面的spawn，就是在產生coroutine，在這裡的coroutine因為事實上是greenlet這個Python函式庫題供的，所以事實上叫做greenlet，</p>
<p>总结一下：<br>1）多进程能够利用多核优势，但是进程间通信比较麻烦，另外，进程数目的增加会使性能下降，进程切换的成本较高。程序流程复杂度相对I/O多路复用要低。<br>2）I/O多路复用是在一个进程内部处理多个逻辑流程，不用进行进程切换，性能较高，另外流程间共享信息简单。但是无法利用多核优势，另外，程序流程被事件处理切割成一个个小块，程序比较复杂，难于理解。<br>3）线程运行在一个进程内部，由操作系统调度，切换成本较低，另外，他们共享进程的虚拟地址空间，线程间共享信息简单。但是线程安全问题导致线程学习曲线陡峭，而且易出错。<br>4）协程有编程语言提供，由程序员控制进行切换，所以没有线程安全问题，可以用来处理状态机，并发请求等。但是无法利用多核优势。<br>上面的四种方案可以配合使用，我比较看好的是进程+协程的模式。</p>
<p>Reference：</p>
<ul>
<li><a href="http://blog.jobbole.com/77240/" target="_blank" rel="external">python greenlet背景介绍与实现机制</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/" target="_blank" rel="external">gevent程序员指南</a></li>
<li><a href="http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/" target="_blank" rel="external">淺談coroutine與gevent</a></li>
<li><a href="https://segmentfault.com/a/1190000004890674" target="_blank" rel="external">PyTips 0x13 - Python 线程与协程（2）</a></li>
<li><a href="http://litaotao.github.io/python-gevent" target="_blank" rel="external">Python 并发编程之一：Gevent</a></li>
<li><a href="http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html" target="_blank" rel="external">进程、线程和协程的理解</a></li>
<li><a href="http://www.firefoxbug.com/index.php/archives/2750/" target="_blank" rel="external">Python Gevent应用</a></li>
<li><a href="http://blog.rainy.im/2016/03/10/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="external">Python 3.5 协程究竟是个啥</a></li>
<li><a href="http://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html" target="_blank" rel="external">Python关键字yield的解释(stackoverflow)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>##Gevent<br>gevent是一个基于libev的并发库。它为各种并发和网络相关的任务提供了整洁的API。,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效。</p>
<p>在gevent中用到的主要模式是Greenlet, 它]]>
    </summary>
    
      <category term="并发" scheme="http://geekzph.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Python" scheme="http://geekzph.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL源码分析之空间配置器]]></title>
    <link href="http://geekzph.github.io/2017/06/30/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://geekzph.github.io/2017/06/30/STL源码分析之空间配置器/</id>
    <published>2017-06-30T15:20:43.000Z</published>
    <updated>2017-08-24T01:52:37.000Z</updated>
    <content type="html"><![CDATA[<p>在内存配置方面，为了避免小型区块所造成的内存破碎问题，STL设计为两级配置器。第一级配置器直接使用malloc()和free(). 第二层配置器有有一个内存池，用一个union obj数组free_list来存储内存的地址，数组的每一个元素都指向一个obj链表，也就是内存链表。数组从小到大表示负责8b,16b,24b,…,120b,128b内存请求。当请求的内存大于128b的时候调用第一级配置器，当请求的内存小于等于128b的时候调用第二级配置器。<br><img src="/images/1.jpg" alt=""></p>
<p>第一级配置器</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line">class __malloc_alloc_template  </span><br><span class="line">&#123;  </span><br><span class="line">private:</span><br><span class="line">	//sfasdf</span><br><span class="line">	//调用malloc函数不成功后调用</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> *oom_malloc(size_t);</span><br><span class="line">	//调用realloc函数不成功后调用 </span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> *oom_realloc(<span class="type">void</span> *, size_t);</span><br><span class="line">	//类似于C++的set_new_handle错误处理函数一样，如果不设置，在内存不足时，返回<span class="type">THROW_BAD_ALLOC</span></span><br><span class="line">	<span class="comment">#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line">		<span class="keyword">static</span> <span class="type">void</span> (* __malloc_alloc_oom_handler)();  </span><br><span class="line">	<span class="comment">#endif  </span></span><br><span class="line">	public:  </span><br><span class="line">	//直接调用malloc来分配内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> * allocate(size_t n)  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> *<span class="literal">result</span> = malloc(n);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == <span class="literal">result</span>) <span class="literal">result</span> = oom_malloc(n);  //如果分配失败，则调用oom_malloc()</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">result</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line"> 	//第一级配置器直接调用free来释放内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> deallocate(<span class="type">void</span> *p, size_t /* n */)  </span><br><span class="line">	&#123; </span><br><span class="line">		free(p); </span><br><span class="line">	&#125;  </span><br><span class="line">	//直接调用reallloc来分配内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> * reallocate(<span class="type">void</span> *p, size_t /* old_sz */, size_t new_sz)  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> * <span class="literal">result</span> = realloc(p, new_sz);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == <span class="literal">result</span>) <span class="literal">result</span> = oom_realloc(p, new_sz);  //如果realloc分配不成功，调用oom_realloc()</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">result</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	//异常处理函数，即内存分配失败后的处理</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> (* set_malloc_handler(<span class="type">void</span> (*f)()))()  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> (* old)() = __malloc_alloc_oom_handler;  </span><br><span class="line">	 __malloc_alloc_oom_handler = f;  </span><br><span class="line">	 <span class="keyword">return</span>(old);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上述源码中可以看到，STL的第一级配置器仅仅是调用了malloc，free等函数，然后增加了内存分配错误下的异常处理函数。下面是内存分配失败时的代码</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 以下是针对内存分配失败后的处理</span><br><span class="line">//首先，将__malloc_alloc_oom_handler的默认值设为<span class="number">0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">#endif  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="type">void</span> *<span class="literal">result</span>;  </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  // 不断地尝试释放、再配置、再释放、再配置</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;  //这里是当没有设置处理函数的时候，直接抛出异常</span><br><span class="line">		(*my_malloc_handler)();   // 调用处理例程，尝试释放内存</span><br><span class="line">		<span class="literal">result</span> = malloc(n);  	  // 再重新分配内存</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span>(<span class="literal">result</span>);  // 如果分配成功则返回指针</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="type">void</span> *p, size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="type">void</span> *<span class="literal">result</span>;  </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  //不断地尝试释放、再配置、再释放、再配置</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; //这里是当没有设置处理函数的时候，直接抛出异常 </span><br><span class="line">		(*my_malloc_handler)();  // 调用处理例程，尝试释放内存</span><br><span class="line">		<span class="literal">result</span> = realloc(p, n);  // 再重新分配内存</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span>(<span class="literal">result</span>);  // 如果分配成功则返回指针</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数，在当内存分配失败时，会不断尝试区内存释放内存，再分配内存，所以再一定程度上提高内存分配成功。</p>
<p>第二级配置器<br>当申请内存小于128b的时候，会调用第二级配置器。第二级配置器有一个内存池和一个对应的自由链表，其定义如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span>  </span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span>  </span><br><span class="line">	char client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述obj所用的是union， 由于是union，从第一个字段看，obj可以视为一个指针，指向相同形式的另一个obj；从第二个字段看，obj可以被视为一个指针，指向实际区块。这样一来，既实现了链表结点只用一个指针的大小空间，却能同时做索引和指向内存区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;   <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;  <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;   <span class="comment">//free-lists个数</span></span><br><span class="line"><span class="comment">//第一参数用于多线程，这里不做讨论。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">class</span> __default_alloc_template  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 此函数将bytes的边界上调至8的倍数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(size_t bytes)</span>  </span><br><span class="line">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN-<span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));  </span><br><span class="line">	&#125;  </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">	<span class="comment">// 此union结构体上面已经解释过了</span></span><br><span class="line">	<span class="keyword">union</span> obj  </span><br><span class="line">	&#123;  </span><br><span class="line">	<span class="keyword">union</span> obj * free_list_link;  </span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="comment">//16个free-lists</span></span><br><span class="line">	<span class="keyword">static</span> obj * __VOLATILE free_list[__NFREELISTS];</span><br><span class="line">	<span class="comment">// 根据待待分配的空间大小, 在free_list中选择合适的大小  </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(size_t bytes)</span>  </span><br><span class="line">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN-<span class="number">1</span>)/__ALIGN - <span class="number">1</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个大小为n的对象，并可能加入大小为n的其它区块到free-lists</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(size_t n)</span></span>;  </span><br><span class="line">	<span class="comment">// 配置一大块空间，可容纳nobjs个大小为“size”的区块</span></span><br><span class="line">	<span class="comment">// 如果配置nobjs个区块有所不便，nobjs可能会降低，所以需要用引用传递</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(size_t size, <span class="keyword">int</span> &amp;nobjs)</span></span>;  </span><br><span class="line">	<span class="comment">// 内存池  </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;      <span class="comment">// 内存池起始点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;        <span class="comment">// 内存池结束点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;      <span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(size_t n)</span></span>;<span class="comment">// 空间配置函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, size_t n)</span></span>; <span class="comment">// 空间释放函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* p, size_t old_sz , size_t new_sz)</span></span>; <span class="comment">//空间重新配置函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一些静态成员变量的初始化</span></span><br><span class="line"><span class="comment">// 内存池起始位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池结束位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池容量索引数组  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * __VOLATILE  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS ] = </span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>
<p>空间配置函数allocate()</p>
<p>下图说明了说明空间配置函数的调用过程：<br><img src="/images/2.jpg" alt=""></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> * allocate(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	obj * volatile * my_free_list;  </span><br><span class="line">	obj * <span class="literal">result</span>;  </span><br><span class="line">	// 大于<span class="number">128</span>就调用第一级配置器</span><br><span class="line">	<span class="keyword">if</span> (n &gt; (size_t) __MAX_BYTES) &#123;  </span><br><span class="line">	 <span class="keyword">return</span>(malloc_alloc::allocate(n));  </span><br><span class="line">	&#125;  </span><br><span class="line">	// 寻找<span class="number">16</span>个free_lists中适当的一个</span><br><span class="line">	my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(n);  </span><br><span class="line">	<span class="literal">result</span> = *my_free_list;  </span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">result</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">		// 如果没有可用的free list，准备重新填充free_list</span><br><span class="line">		<span class="type">void</span> *r = refill(<span class="type">ROUND_UP</span>(n));  </span><br><span class="line">		<span class="keyword">return</span> r;  </span><br><span class="line">	&#125;</span><br><span class="line">	// 调整free list</span><br><span class="line">	*my_free_list = <span class="literal">result</span> -&gt; free_list_link;  </span><br><span class="line">	<span class="keyword">return</span> (<span class="literal">result</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存释放函数deallocate()<br>内存释放函数会将释放的空间交还给free_list以留备用。其过程如下图所示：<br><img src="/images/3.jpg" alt=""></p>
<p>重新填充函数refill()</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> nobjs = <span class="number">20</span>;  //	默认获取<span class="number">20</span>个</span><br><span class="line">	<span class="type">char</span> * chunk = chunk_alloc(n, nobjs);  //找内存池要空间</span><br><span class="line">	obj * volatile * my_free_list;  </span><br><span class="line">	obj * <span class="literal">result</span>;  </span><br><span class="line">	obj * current_obj, * next_obj;  </span><br><span class="line">	<span class="type">int</span> i;  </span><br><span class="line">	// 如果内存池仅仅只够分配一个对象的空间, 直接返回即可  </span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);  </span><br><span class="line">	// 内存池能分配更多的空间，调整free_list纳入新节点</span><br><span class="line">	my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(n);</span><br><span class="line">	// 在chunk的空间中建立free_list  </span><br><span class="line">	<span class="literal">result</span> = (obj *)chunk;</span><br><span class="line">	*my_free_list = next_obj = (obj *)(chunk + n); //导引free_list指向新配置的空间(取自内存池)</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; ; i++) &#123;	//从<span class="number">1</span>开始，因为第<span class="number">0</span>个返回给客端</span><br><span class="line">		current_obj = next_obj;  </span><br><span class="line">		next_obj = (obj *)((<span class="type">char</span> *)next_obj + n);  </span><br><span class="line">		<span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = next_obj;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span>(<span class="literal">result</span>);//返回头指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存池函数chunk_alloc()</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">char</span>*  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, <span class="type">int</span>&amp; nobjs)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> * <span class="literal">result</span>;  </span><br><span class="line">    size_t total_bytes = size * nobjs;  </span><br><span class="line">    size_t bytes_left = end_free - start_free;  // 计算内存池剩余容量  </span><br><span class="line">   </span><br><span class="line">    //内存池中的剩余空间满足需求 </span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">        <span class="literal">result</span> = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">result</span>);//返回起始地址</span><br><span class="line">    &#125;  </span><br><span class="line">    // 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span><br><span class="line">    // 返回所能分配的最多的节点, 返回start_free指向的内存块  </span><br><span class="line">    // 并且重新设置内存池起始点  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left/size;  </span><br><span class="line">        total_bytes = size * nobjs;  </span><br><span class="line">        <span class="literal">result</span> = start_free;  </span><br><span class="line">        start_free += total_bytes;  </span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">result</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 内存池剩余内存连一个节点也不够分配  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        size_t bytes_to_get = <span class="number">2</span> * total_bytes + <span class="type">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line">        // 将剩余的内存分配给指定的free_list[<span class="type">FREELIST_INDEX</span>(bytes_left)]  </span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        	//内存池内还有一些零头，先分给适当的free_list</span><br><span class="line">        	//寻找适当的free_list</span><br><span class="line">            obj * __VOLATILE * my_free_list =  </span><br><span class="line">                   	free_list + <span class="type">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">            // 调整free_list，将内存池中的残余空间编入 </span><br><span class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </span><br><span class="line">            *my_free_list = (obj *)start_free;  </span><br><span class="line">        &#125;  </span><br><span class="line">        start_free = (<span class="type">char</span> *)malloc(bytes_to_get);  </span><br><span class="line">        // 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;// heap里面空间不足，malloc失败</span><br><span class="line">            <span class="type">int</span> i;  </span><br><span class="line">            obj * __VOLATILE * my_free_list, *p;  </span><br><span class="line">            // 试着检查检查free_list中的可用空间，即尚有未用的空间，且区块够大  </span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </span><br><span class="line">                my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(i);  </span><br><span class="line">                p = *my_free_list;  </span><br><span class="line">                // 找到了一个, 将其加入内存池中  </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;  </span><br><span class="line">                    start_free = (<span class="type">char</span> *)p;  </span><br><span class="line">                    end_free = start_free + i;  </span><br><span class="line">                    // 内存池更新完毕, 重新分配需要的内存  </span><br><span class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">                    //任何剩余零头将被编入适当的free_list以留备用 </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line"> </span><br><span class="line">        // 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助  </span><br><span class="line">        // 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span><br><span class="line">        // 最好直接log, 然后让程序崩溃  </span><br><span class="line">        end_free = <span class="number">0</span>;</span><br><span class="line">        	//调用第一级配置器，看看<span class="keyword">out</span>-<span class="keyword">of</span>-memory机制能不能起点作用</span><br><span class="line">            start_free = (<span class="type">char</span> *)malloc_alloc::allocate(bytes_to_get);  </span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;  </span><br><span class="line">        end_free = start_free + bytes_to_get;  </span><br><span class="line">        // 内存池更新完毕, 重新分配需要的内存  </span><br><span class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用配置器<br>STL两层配置器就分析结束了，接下来看下配置器使如何使用的。<br>vector中使用配置器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc&gt;  <span class="comment">//alloc被默认为第二级配置器</span></span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 专属的空间配置器，每次只分配一个元素的大小</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	<span class="comment">// 在释放内存的时候直接调用借口函数即可</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(...)&#123;</span><br><span class="line">			data_allocator::deallocate(start , end_of_storage - start);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在内存配置方面，为了避免小型区块所造成的内存破碎问题，STL设计为两级配置器。第一级配置器直接使用malloc()和free(). 第二层配置器有有一个内存池，用一个union obj数组free_list来存储内存的地址，数组的每一个元素都指向一个obj链表，也就是内存链]]>
    </summary>
    
      <category term="STL" scheme="http://geekzph.github.io/tags/STL/"/>
    
      <category term="C++" scheme="http://geekzph.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树与分治法]]></title>
    <link href="http://geekzph.github.io/2017/06/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>http://geekzph.github.io/2017/06/30/二叉树与分治法/</id>
    <published>2017-06-30T02:33:46.000Z</published>
    <updated>2017-08-24T01:52:27.000Z</updated>
    <content type="html"><![CDATA[<p>Binary Tree Preorder Traversal<br>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>recursion<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param root: <span class="type">The</span> root <span class="keyword">of</span> binary tree.</span><br><span class="line">     * @<span class="keyword">return</span>: <span class="type">Preorder</span> <span class="keyword">in</span> vector which contains node values.</span><br><span class="line">     */</span><br><span class="line">    <span class="type">void</span> traverse(<span class="type">TreeNode</span> *root, vector&lt;<span class="type">int</span>&gt; &amp;res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        traverse(root-&gt;left, res);</span><br><span class="line">        traverse(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preorderTraversal(<span class="type">TreeNode</span> *root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        traverse(root, <span class="literal">result</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            </span><br><span class="line">            TreeNode *node = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push(node-&gt;left);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Maximum Depth of Binary Tree<br><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/maximum-depth-of-binary-tree/description/</a><br>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maxDepth(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = maxDepth(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = maxDepth(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return ((<span class="built_in">left</span> &gt; <span class="built_in">right</span>)?<span class="built_in">left</span>:<span class="built_in">right</span>) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Minimum Depth of Binary Tree<br><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/minimum-depth-of-binary-tree/description/</a><br>Given a binary tree, find its minimum depth.<br>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve_dp</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> lf = <span class="number">0x7fffffff</span>, rt = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            lf = solve_dp(root-&gt;left);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) </span><br><span class="line">            rt = solve_dp(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(lf, rt) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> solve_dp(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Balanced Binary Tree<br><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/balanced-binary-tree/description/</a><br>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    int treeDepth(<span class="type">TreeNode</span> *root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int <span class="keyword">left</span> = treeDepth(root-&gt;<span class="keyword">left</span>);</span><br><span class="line">        int <span class="keyword">right</span> = treeDepth(root-&gt;<span class="keyword">right</span>);</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">left</span> &gt; <span class="keyword">right</span>)?<span class="keyword">left</span>:<span class="keyword">right</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br><span class="line">    bool isBalanced(<span class="type">TreeNode</span>* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        int <span class="keyword">left</span> = treeDepth(root-&gt;<span class="keyword">left</span>);</span><br><span class="line">        int <span class="keyword">right</span> = treeDepth(root-&gt;<span class="keyword">right</span>);</span><br><span class="line">        int diff = <span class="keyword">left</span> - <span class="keyword">right</span>;</span><br><span class="line">        <span class="keyword">if</span>(diff &gt; <span class="number">1</span> || diff &lt; -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root-&gt;<span class="keyword">left</span>) &amp;&amp; isBalanced(root-&gt;<span class="keyword">right</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Binary Tree Maximum Path Sum<br><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" target="_blank" rel="external">https://leetcode.com/problems/binary-tree-maximum-path-sum/description/</a><br>Given a binary tree, find the maximum path sum.<br>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.<br>For example:<br>Given the below binary tree,</p>
<pre><code>  <span class="number">1</span>
 / \
<span class="number">2</span>   <span class="number">3</span>
</code></pre><p>Return 6.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Lowest Common Ancestor of a Binary Tree<br><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/</a><br>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code><span class="code">    _______3______</span>
   /              \
<span class="strong">___5__</span>          <span class="strong">___1__</span>
</code></pre><p>   /      \        /      \<br>   6      _2       0       8<br>         /  \<br>         7   4<br>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root == p || root == q)</span><br><span class="line">            return root;</span><br><span class="line">            </span><br><span class="line">        TreeNode* <span class="built_in">left</span> = lowestCommonAncestor(root-&gt;<span class="built_in">left</span>, p, q);</span><br><span class="line">        TreeNode* <span class="built_in">right</span> = lowestCommonAncestor(root-&gt;<span class="built_in">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)</span><br><span class="line">            return root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span>)</span><br><span class="line">            return <span class="built_in">left</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">right</span> != <span class="literal">NULL</span>)</span><br><span class="line">            return <span class="built_in">right</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            return <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Binary Tree Level Order Traversal<br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="external">https://leetcode.com/problems/binary-tree-level-order-traversal/description/</a><br>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; levelOrder(<span class="type">TreeNode</span>* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        queue&lt;<span class="type">TreeNode</span>*&gt; q1;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty())</span><br><span class="line">        &#123; </span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="type">int</span> my_size = q1.size();</span><br><span class="line">            <span class="keyword">while</span>(my_size != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span>* head = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                level.push_back(head-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left != <span class="type">NULL</span>)</span><br><span class="line">                    q1.push(head-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;right != <span class="type">NULL</span>)</span><br><span class="line">                    q1.push(head-&gt;right);</span><br><span class="line">                </span><br><span class="line">                my_size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">result</span>.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Validate Binary Search Tree<br><a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/validate-binary-search-tree/description/</a><br>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:<br>    2<br>   / \<br>  1   3<br>Binary tree [2,1,3], return true.<br>Example 2:<br>    1<br>   / \<br>  2   3<br>Binary tree [1,2,3], return false.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *lastNode = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isValidBST(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lastNode != <span class="keyword">NULL</span> &amp;&amp; lastNode-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        lastNode = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Delete Node in a BST<br><a href="https://leetcode.com/problems/delete-node-in-a-bst/discuss/" target="_blank" rel="external">https://leetcode.com/problems/delete-node-in-a-bst/discuss/</a><br>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<p>Search for a node to remove.<br>If the node is found, delete the node.<br>Note: Time complexity should be O(height of tree).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Binary Search Tree Iterator<br><a href="https://leetcode.com/problems/binary-search-tree-iterator/description/" target="_blank" rel="external">https://leetcode.com/problems/binary-search-tree-iterator/description/</a><br>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<p>Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; myStack;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    void pushAll(TreeNode *root)&#123;</span><br><span class="line">        <span class="keyword">for</span> (; root != <span class="keyword">NULL</span>; myStack.push(root), root = root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="keyword">bool</span> hasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> !myStack.<span class="keyword">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="keyword">int</span> next() &#123;</span><br><span class="line">        TreeNode * node = myStack.top();</span><br><span class="line">        myStack.pop();</span><br><span class="line">        pushAll(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Binary Tree Preorder Traversal<br>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>recursion<br><figure c]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[I/O复用之select、poll、epoll]]></title>
    <link href="http://geekzph.github.io/2017/06/19/I-O%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll/"/>
    <id>http://geekzph.github.io/2017/06/19/I-O复用之select、poll、epoll/</id>
    <published>2017-06-19T13:39:04.000Z</published>
    <updated>2017-08-24T01:52:31.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="IO复用" scheme="http://geekzph.github.io/tags/IO%E5%A4%8D%E7%94%A8/"/>
    
      <category term="Linux" scheme="http://geekzph.github.io/categories/Linux/"/>
    
  </entry>
  
</feed>

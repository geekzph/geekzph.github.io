<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[geekzph's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://geekzph.github.io/"/>
  <updated>2017-04-17T13:49:21.000Z</updated>
  <id>http://geekzph.github.io/</id>
  
  <author>
    <name><![CDATA[geekzph]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[并发与并行]]></title>
    <link href="http://geekzph.github.io/2017/04/17/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/"/>
    <id>http://geekzph.github.io/2017/04/17/并发与并行/</id>
    <published>2017-04-17T11:01:30.000Z</published>
    <updated>2017-04-17T13:49:21.000Z</updated>
    <content type="html"><![CDATA[<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。</p>
<p>引用<a href="https://www.zhihu.com/question/33515481" target="_blank" rel="external">知乎上的一个回答</a>：<br>`<br>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。<br>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。<br>所以我认为它们最关键的点就是：是否是『同时』。</p>
<p>`</p>
<p>####多线程在单核和多核CPU上的执行效率问题</p>
<ul>
<li>多线程在单cpu中其实也是顺序执行的，不过系统可以帮你切换那个执行而已，其实并没有快，单核CPU上运行的多线程程序, 同一时间只能一个线程在跑, 系统帮你切换线程而已, 系统给每个线程分配时间片来执行, 每个时间片大概10ms左右, 看起来像是同时跑, 但实际上是每个线程跑一点点就换到其它线程继续跑。对于CPU密集型的问题，多线程在单核CPU上非但不会减少运行时间，反而相对于单线程来说会变慢。但对于I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为IO的速度远远低于CPU和内存的速度）。对于I/O密集型任务，任务越多，CPU效率越高。</li>
<li>多个cpu的话就可以在多个CPU中同时执行,因此对于CPU密集型任务，可以提高CPU利用率，达到加速的效果。</li>
</ul>
<p>####Python中的多线程<br>在使用Python进行多线程编程时，如果是一个CPU密集型任务，由于GIL的存在会使得多线程变慢。如果是I/O密集型则能够加速。如果一个Python程序里有多个线程，一个程序运行的时候会拿着GIL，当遇到I/O的时候会放开GIL，但是CPU-bound的线程通常不会进行I/O。Python切换线程的一种作法是每100 ticks检查一下，可以通过sys.setcheckinterval()修改这个数值。因为Python线程不能有效利用多核，但是增加了CPU context switch的消耗，所以对于CPU-bound的程序表现很差。在单核CPU上，数百次的间隔检查才会导致一次线程切换。在多核CPU上，存在严重的线程颠簸（thrashing）。更糟糕的是，在多核情况下可能表现会更差，因为系统支持多线程运行但是GIL保证只有一个线程运行，这时候多线程会反复的检查GIL是否被释放，但是拿不到GIL(因为有太多线程竞争)，有可能导致系统发生Trashing现象。</p>
<p>Python解释器进程内的多线程是合作多任务方式执行。当一个线程遇到I/O任务时，将释放GIL。计算密集型（CPU-bound）的线程在执行大约100次解释器的计步（ticks）时，将释放GIL。计步（ticks）可粗略看作Python虚拟机的指令。计步实际上与时间片长度无关。可以通过sys.setcheckinterval()设置计步长度。</p>
<p>因此并发可以使I/O密集型任务加速而并行可以使用CPU密集型加速。</p>
<p>Reference：<br><a href="http://zhuoqiang.me/python-thread-gil-and-ctypes.html" target="_blank" rel="external">python 线程，GIL 和 ctypes</a><br><a href="http://www.dabeaz.com/GIL/" target="_blank" rel="external">Understanding the Python GIL</a><br><a href="https://www.zhihu.com/question/39923765" target="_blank" rel="external">python下同样代码，多核多线程为什么比单核多线程慢很多？</a><br><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001397567993007df355a3394da48f0bf14960f0c78753f000" target="_blank" rel="external">廖雪峰的博客</a><br><a href="https://medium.com/@yaoyaowd/python-%E4%BD%A0%E6%80%8E%E4%B9%88%E9%82%A3%E4%B9%88%E6%85%A2-%E7%9C%8B%E7%9C%8B%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91-6a97c4828d64" target="_blank" rel="external">Python，你怎么那么慢？看看并行和并发</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。</p>
<p>引用<a href="https:/]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[getline函数只能读首行的问题]]></title>
    <link href="http://geekzph.github.io/2017/04/13/getline%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E8%AF%BB%E9%A6%96%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://geekzph.github.io/2017/04/13/getline函数只能读首行的问题/</id>
    <published>2017-04-13T12:11:33.000Z</published>
    <updated>2017-04-13T12:53:55.000Z</updated>
    <content type="html"><![CDATA[<p>最近在写C++读入文件时发现一个问题，当使用getline函数读取文件时只能读取到第一行，百思不得其解，无奈边去查询官方文档。其函数原型如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(<span class="keyword">char</span>* s, streamsize n )</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(<span class="keyword">char</span>* s, streamsize n, <span class="keyword">char</span> delim )</span></span>;</span><br></pre></td></tr></table></figure>
<p>getline有两种调用形式，其中第二种形式的第三个参数是界定字符。如果界定字符是（‘\n’）就使用第一张形式，否则就用第二种形式。当n的值大于指针s所指向空间的大小时，它就会设置一个无效位，就不会在向下读取。因此如果出现只读取到第一行的情况恒友可能就是s太小了，把s数组改大一些就可以了。</p>
<p>如将</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="value">char</span> <span class="value">line</span><span class="attr_selector">[15]</span>;</span><br><span class="line">file<span class="class">.getline</span>(<span class="value">line</span>, 15);</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="value">char</span> <span class="value">line</span><span class="attr_selector">[35]</span>;</span><br><span class="line">file<span class="class">.getline</span>(<span class="value">line</span>, 35);</span><br></pre></td></tr></table></figure>
<p>就可以了。</p>
<p>参考资料:<a href="http://www.cplusplus.com/reference/istream/istream/getline/" target="_blank" rel="external">http://www.cplusplus.com/reference/istream/istream/getline/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在写C++读入文件时发现一个问题，当使用getline函数读取文件时只能读取到第一行，百思不得其解，无奈边去查询官方文档。其函数原型如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><p]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下文件排序]]></title>
    <link href="http://geekzph.github.io/2017/04/13/Linux%E4%B8%8B%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://geekzph.github.io/2017/04/13/Linux下文件排序/</id>
    <published>2017-04-13T12:08:06.000Z</published>
    <updated>2017-04-13T12:53:39.000Z</updated>
    <content type="html"><![CDATA[<p>有时候我们需要对一个文件就行排序，这个时候可以直接调用Linux的sort命令可以很方便的对文件就行排序。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sort</span> 文件名</span><br></pre></td></tr></table></figure>
<p>sort命令默认会从左到右按ASCII码值就行排序<br>他还有很多可选参数</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">u   /<span class="regexp">/去重</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp">r   /</span><span class="regexp">/降序</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp">n   /</span><span class="regexp">/按数字大小排序</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp">t   /</span><span class="regexp">/设置分隔符</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp">k   /</span><span class="regexp">/设置按那一列进行排序</span></span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时候我们需要对一个文件就行排序，这个时候可以直接调用Linux的sort命令可以很方便的对文件就行排序。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac环境变量设置]]></title>
    <link href="http://geekzph.github.io/2017/03/02/Mac%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
    <id>http://geekzph.github.io/2017/03/02/Mac环境变量设置/</id>
    <published>2017-03-02T15:27:27.000Z</published>
    <updated>2017-03-02T15:28:19.000Z</updated>
    <content type="html"><![CDATA[<p>OS X系统的环境变量，加载顺序为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/paths </span><br><span class="line">~/<span class="class">.bash_profile</span> </span><br><span class="line">~/<span class="class">.bash_login</span> </span><br><span class="line">~/<span class="class">.profile</span> </span><br><span class="line">~/.bashrc</span><br></pre></td></tr></table></figure>
<p>/etc/profile和/etc/paths是系统级别的，系统启动就会加载，<br>后面几个是当前用户级的环境变量。<br>~/.bash_profile，~/.bash_login，~/.profile按照从前往后的顺序读取，如果~/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果~/.bash_profile文件不存在，才会以此类推读取后面的文件。<br>~/.bashrc没有上述规则，它是bash shell打开的时候载入的。<br>设置PATH的语法为：</p>
<p><code>export PATH=&quot;$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:&lt;PATH 3&gt;:...:&lt;PATH N&gt;&quot;</code></p>
<p>注：<br>1）一般环境变量更改后，重启后才可生效。如果想立刻生效，则可执行下面的语句：</p>
<p><code>$ source 文件路径</code>    </p>
<p>2）如果默认shell是bash，那么shell启动时会触发.bashrc，如果默认shell是zsh，那么shell启动时会触发.zshrc，则需要编辑 .zshrc 这个文件 vi ~/.zshrc，否则环境变量在zsh中不能生效</p>
<p>3) 使用echo命令查看是否生效</p>
<p><code>echo $path</code></p>
<p>4)添加路径时候不能使用~，比如路径 ~/mongodb/应该改为/Users/用户名/mongodb</p>
<p>参考文章：<br><a href="http://www.jianshu.com/p/e6396fab1879" target="_blank" rel="external">http://www.jianshu.com/p/e6396fab1879</a><br><a href="http://cnbin.github.io/blog/2015/06/20/zsh-tian-jia-huan-jing-bian-liang/" target="_blank" rel="external">http://cnbin.github.io/blog/2015/06/20/zsh-tian-jia-huan-jing-bian-liang/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OS X系统的环境变量，加载顺序为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="li]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[《自控力》书摘]]></title>
    <link href="http://geekzph.github.io/2016/10/26/%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E4%B9%A6%E6%91%98/"/>
    <id>http://geekzph.github.io/2016/10/26/《自控力》书摘/</id>
    <published>2016-10-26T14:55:57.000Z</published>
    <updated>2016-11-28T12:24:08.000Z</updated>
    <content type="html"><![CDATA[<p>1.“说不”属于意志力的一部分，而且是最不可或缺的部分。</p>
<p>2.意志力就是要驾驭“我要做”、“我不要”和“我想要”这三种力量。</p>
<p>3.自控力比智商高更有助于拿高分，比个人魅力更有助于领导别人，比同理心跟有助于维持婚姻幸福。</p>
<p>4.意志力挑战就是两个自我的对抗–自控系统和原始本能。没有自我意识，自控系统将毫无用武之地。更强的自控力就得有更多的自我意识。</p>
<p>5.经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你注意集中力、管理压力、克制冲动和认识自我的能力。</p>
<p>6.心率变异度成为身体的意志力“储备”，也就是一个衡量自控力的生理学标准。</p>
<p>7.将呼吸频率降低到每分钟4-6次，也就是每次呼吸时间用时10-15秒，比平常呼吸慢一点，可以提高心率变异度。</p>
<p>8.自控力的良药是锻炼。锻炼能提高心率变异度的基准线。</p>
<p>9.改善心情，缓解压力的最有效的锻炼是每次5分钟，而不是每次几个小时。</p>
<p>10.长期的睡眠不足让你更容易感受到压力、萌生欲望、受到诱惑。</p>
<p>11.自控力就像肌肉一样有极限，意志力的肌肉模式告诉我们，自控力从早上到晚上会逐渐减弱。</p>
<p>12.如果你觉得自己没有时间和精力去处理“我想要”做的事情，那就把它安排在你意志力最强的时候做。</p>
<p>13.意志力饮食方案：低血糖食品包括瘦肉蛋白，坚果和豆类，粗纤维谷物和麦片，大多数的水果和蔬菜。</p>
<p>14.在一些小事上持续自控会提高整体的意志力，改变姿势，戒掉甜食，记录支出情况。</p>
<p>15.面对你最大的意志力挑战时，你可以考虑以下动机。如果挑战成功，你将会获得什么，还有谁受益。如果你现在愿意努力做困难的是，那么过一段时间后，这个挑战将会变得容易。</p>
<p>16.我们最强的动力并不是我们所想的那样，也不是我们觉得“应该是”的那样。</p>
<p>17.“道德许可”不仅会批准我们做坏事，也会让我们错失做善事的机会。</p>
<p>18.所有被我们道德化的东西都不可避免地受到“道德许可效应”的影响。</p>
<p>19.只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。</p>
<p>20.任何让你对自己的美感到满意的事，即便只是想想你做过的善事，都会允许我们做冲动的事。</p>
<p>21.当我们从道德的角度思考自己面对的意志力挑战时，我们就失去了自我判断能力，看不到这些挑战有助于我们得到自己想要的东西。</p>
<p>22.我们总是把进步当做放松的借口。</p>
<p>23.我们把需要做的事当成了自己已经付出的努力，只会给我们错误的满足感。</p>
<p>24.记住我们为什么会拒绝诱惑，这是个很有效的办法。</p>
<p>25.大脑对能完成目标的可能性感到兴奋，它错把可能性当成真正完成了目标。</p>
<p>26.我们想到未来的选择时，就会很容易犯下大错。我们不断期待明天能做出和今天不同的选择，但这种期望是错误的。</p>
<p>27.当你要做意志力挑战有关的决定是，注意一下，你脑海中是否闪过了“未来再好表现”的承诺。</p>
<p>28.对未来的乐观主义精神，不仅会影响我们自己的决定，还会影响我们究竟会不会按自己所说的去做。试着减少行为的变化性。</p>
<p>29.只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。当光环效应影响到了你的意志力挑战时，你需要找到具体的测量标准。</p>
<p>30.在追求自控的过程中，我们不应该把所有的意志力挑战都放在道德标准的框架中。想要做到始终如一，我们就需要认同目标本身，而不是我们做山是时的光环。</p>
<p>31.现代科技“及时行乐”的特点，加上原始的激励系统，就让我们成了多巴胺的奴隶，从此欲罢不能。</p>
<p>32.当奖励承诺的多巴胺释放时，你更容易受到其他形式的诱惑。</p>
<p>33.我们的大脑错把奖励的承诺当成快乐的保证，所以，我们从不可能带来满足的事物中找到满足。</p>
<p>34.想得到快乐是一种健康的生存机制。它和远离危险一样，都是人类的本能。</p>
<p>35.当我们情绪低落的时，大脑更容易受到诱惑。</p>
<p>36.最有效的解压方法包括：锻炼或参加体育活动、祈祷或参加宗教活动、阅读、听音乐、与家人相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。真正缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质。</p>
<p>37.导致跟多堕落的行为并不是第一次的放弃，而是第一次放弃后产生的羞耻感、罪恶感、失控感和绝望感。责备自己屈于诱惑的时候，往往会带来更多意志力的实效，造成更多的痛苦。</p>
<p>38.自我批评会降低积极性和自控力，而且也是最容易导致抑郁的因素。相反，自我同情则会提示积极性和自控力。</p>
<p>39.增强责任感的不是罪恶感，而是自我谅解。</p>
<p>40.当我们面对罪恶感、焦虑和压力感到备受打击时，我们会想到一件能让自己快乐的事——决定做出改变。不行的是，就像奖励的承诺和缓解压力的承诺一样，改变的承诺也很少能朝我们希望的方向发展。</p>
<p>41.当我们和诱惑正面交锋的时候，我们只愿意选择短期的、即时的奖励。即时奖励会激活更古老、更原始的奖励系统，刺激相应的多巴胺产生欲望。未来奖励则不太可能激活这个奖励系统。</p>
<p>42.当我们想到未来的自己时，我们的欲望不会像现在一样紧迫，情绪不会像现在一样真切。</p>
<p>43.大脑会把未来的自己当成别人，这种习惯对自控力影响极大。</p>
<p>44.无意识的模仿，传染情绪和当我们看到别人屈服于诱惑时，我们的大脑也可能受到诱惑。这三种形式都会是我们的社会脑出现意志力实效。</p>
<p>45.当我们看到别人忽视规则、受欲望支配的时候，我们更可能在任何冲动面前选择屈服。</p>
<p>46.社会传染病在人际网络中传播，那里面都是互相尊重、互相欣赏的人。</p>
<p>47.当群体里的其他人都在做某件事时，我们很容易认为这件事是应该做的聪明事情。我们的日常行为受到“社会认同”的巨大影响。</p>
<p>48.戒掉恶习并培养新的美德会让我们在自己最重视的群体中站稳脚跟，我们或许会愿意这么做。</p>
<p>49.在考虑如何做出选择是，我们经常想象自己是别人评估的对象。这位人们自控提供了强大的精神支持。</p>
<p>50.我们的大脑会把别人的目标、信念和行为整合到自己的决策中。我们的行为也影响了其他无数人，我们做的每个选择对别人来说也是一种鼓励或诱惑。</p>
<p>51.把我不要的力量用在涉及思想、情感的内心世界，他就会实效。</p>
<p>52.当人们视图摆脱一种想法，他却不断回到脑海中时，人们很可能认为他一定是真的。这种认知的偏见似乎已经在人类的大脑中根深蒂固了。人们会根据想起事情的难易程度来判断它的可能性或真实性。</p>
<p>53.当人们不再试图控制那些不希望出现的想法和情绪时，他们也就不会再来烦你。</p>
<p>54.直面自身欲望，但不要付诸行动。驾驭冲动。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.“说不”属于意志力的一部分，而且是最不可或缺的部分。</p>
<p>2.意志力就是要驾驭“我要做”、“我不要”和“我想要”这三种力量。</p>
<p>3.自控力比智商高更有助于拿高分，比个人魅力更有助于领导别人，比同理心跟有助于维持婚姻幸福。</p>
<p>4.意志力挑]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ngrok实现内网穿透]]></title>
    <link href="http://geekzph.github.io/2016/08/18/%E4%BD%BF%E7%94%A8ngrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://geekzph.github.io/2016/08/18/使用ngrok实现内网穿透/</id>
    <published>2016-08-18T13:52:33.000Z</published>
    <updated>2016-09-18T09:37:18.000Z</updated>
    <content type="html"><![CDATA[<p>在很多时候我需要把内网的东西暴露给外网，但是又没有外网IP。这个时候我们可以借助一些内网穿透工具达到这个目的，例如花生壳之类。但是这些收费的。ngrok是一个开源的内网穿透服务，可以在他的官网注册账号实现内网穿透，但是现在应被墙了。不过我们可以用他的源码在自己的VPS上搭建这个服务。ngrok可以做TCP端口转发，对于Linux可以将其映射到22端口进行SSH连接。Windows的远程桌面可以将其映射到3389端口来实现。同理，如果要做MySQL的远程连接，只需映射3306端口即可。本文详细记录了整个搭建过程。</p>
<h2 id="编译Ngrok">编译Ngrok</h2><p>以Ubuntu 14.04 为例<br>1、安装必备工具</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install <span class="keyword">build-essential </span>mercurial git</span><br></pre></td></tr></table></figure>
<p>2、配置Go环境<br>下载Go源码</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O <span class="string">https:</span><span class="comment">//storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure>
<p>注意：同过apt-get 方式下载的Go可能会由于版本低而导致无法编译</p>
<p>解压源码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tar</span> <span class="tag">xvf</span> <span class="tag">go1</span><span class="class">.6</span><span class="class">.linux-amd64</span><span class="class">.tar</span><span class="class">.gz</span></span><br></pre></td></tr></table></figure>
<p>Go目录的权限改为root，并把它移动到/usr/local目录</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R roo<span class="variable">t:root</span> ./<span class="keyword">go</span></span><br><span class="line">sudo mv <span class="keyword">go</span> /usr/local</span><br></pre></td></tr></table></figure>
<p>配置环境变量，打开.profile 文件</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vi</span> ~/.<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>
<p>在末尾加入下面两行</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=<span class="variable">$HOME</span>/work </span><br><span class="line">export PATH=<span class="variable">$PATH</span>:/usr/local/go/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>
<p>编译使其生效</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> ~/.<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>
<p>测试Go是否安装成功</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="keyword">version</span></span><br></pre></td></tr></table></figure>
<p>3、编译ngrok源码</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/tutumcloud/ngrok.git ngrok</span><br><span class="line"><span class="keyword">cd</span> ngrok</span><br></pre></td></tr></table></figure>
<p>生成并替换源码里默认的证书，注意域名修改为你自己的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NGROK_DOMAIN=<span class="string">"geekzph.com"</span></span><br><span class="line"></span><br><span class="line">openssl genrsa -out base<span class="class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -new -x509 -nodes -key base<span class="class">.key</span> -days <span class="number">10000</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -out base<span class="class">.pem</span></span><br><span class="line">openssl genrsa -out server<span class="class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -new -key server<span class="class">.key</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -out server<span class="class">.csr</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server<span class="class">.csr</span> -CA base<span class="class">.pem</span> -CAkey base<span class="class">.key</span> -CAcreateserial -days <span class="number">10000</span> -out server<span class="class">.crt</span></span><br><span class="line"></span><br><span class="line">cp base<span class="class">.pem</span> assets/client/tls/ngrokroot.crt</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make GOOS=linux <span class="operator"><span class="keyword">release</span>-<span class="keyword">server</span> <span class="keyword">release</span>-<span class="keyword">client</span></span></span><br></pre></td></tr></table></figure>
<p>如果出现类似下面的错误</p>
<blockquote>
<p>GOOS=”” GOARCH=”” go get github.com/jteeuwen/go-bindata/go-bindata<br>bin/go-bindata -nomemcopy -pkg=assets -tags=debug \<br>-debug=true \<br>-o=src/ngrok/client/assets/assets_debug.go \<br>assets/client/…<br>make: bin/go-bindata：command not found<br>make: <em>*</em> [client-assets] error 127</p>
</blockquote>
<p>则可是<br>1、Go的环境变量没有设置好，需要重新检查环境变量<br>2、编译的时候GOOS没有设置为linux</p>
<p>如果编译成功的话，在ngrok/bin下应该有ngrok、ngrokd 两个可执行文件。</p>
<p>5、启动服务端</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ngrok/</span><br><span class="line">sudo ./bin/ngrokd -tlsKey=server<span class="class">.key</span> -tlsCrt=server<span class="class">.crt</span> -domain=<span class="string">"geekzph.com"</span> -httpAddr=<span class="string">":9090"</span> -httpsAddr=<span class="string">":9092"</span></span><br></pre></td></tr></table></figure>
<p>现在服务端已经运行起来了，ngrokd 会开一个 4443 端口用来跟客户端通讯。</p>
<p>6、配置域名解析<br>我用的DNSPOD的域名解析服务<br><img src="/media/Snip20160918_3.png" alt="Snip20160918_3"><br>把域名泛解析到 VPS 上,记录值为VPS的IP地址。这时候访问geekzph.com，会出现</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tunnel geekzph<span class="class">.com</span>:<span class="number">9091</span> not found</span><br></pre></td></tr></table></figure>
<p>说明一切已经就绪了。</p>
<p>7、客户端<br>由于我们刚才编译的是linux的客户端，如果需要在Windows上使用的话还需要编译一个Windows的客户端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切到go的安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/go/src </span><br><span class="line"><span class="comment">#给Go编译器加上交叉编译windows/amd64程序的功能 </span></span><br><span class="line">GOOS=windows GOARCH=amd64 ./make.bash</span><br></pre></td></tr></table></figure>
<p>开始编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#切回到ngrok目录 </span></span><br><span class="line">cd - </span><br><span class="line"><span class="preprocessor">#执行如下命令编译Windows <span class="number">64</span>位客户端 </span></span><br><span class="line">GOOS=windows GOARCH=amd64 make release-client </span><br><span class="line"><span class="preprocessor">#以上GOARCH=amd64指的是编译为<span class="number">64</span>位版本，如需<span class="number">32</span>位改成GOARCH=<span class="number">386</span>即可</span></span><br></pre></td></tr></table></figure>
<p>Windows客户端ngrok就编译成功了，我们可以在./bin/windows_amd64/目录下找到执行文件ngrok.exe。使用scp命令将其从vps上下载到Windows上。</p>
<p>然后在ngrok目录下新建一个配置文件，例如命名为grok.cfg：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server_addr:</span> gekezph.<span class="string">com:</span><span class="number">4443</span></span><br><span class="line"><span class="string">trust_host_root_certs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>打开命令提示符，切到ngrok.exe所在目录，并执行以下命令。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#启动ngrok客户端</span></span><br><span class="line"><span class="preprocessor">#注意：如果不加参数-subdomain=test，将会随机自动分配子域名。</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line">ngrok -config=ngrok.cfg -subdomain=test <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>这样就配置成功了！访问。test.geekzph.com就可以看到网站内容了。以上是映射的http服务，还以映射tcp服务，这样就能ssh，远程桌面等功能。</p>
<p>我们以远程桌面为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#这里以远程桌面时的<span class="number">3389</span>端口为例 </span></span><br><span class="line">ngrok -proto=tcp <span class="number">3389</span></span><br></pre></td></tr></table></figure>
<p>之后出现下面提示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#客户端ngrok正常执行显示的内容 </span></span><br><span class="line">ngrok (Ctrl+C to quit) </span><br><span class="line">Tunnel Status online </span><br><span class="line">Version <span class="number">1.7</span>/<span class="number">1.7</span> </span><br><span class="line">Forwarding tcp:<span class="comment">//geekzph.com:98805 -&gt; 127.0.0.1:22 </span></span><br><span class="line">Web Interface <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4040</span> </span><br><span class="line"><span class="preprocessor"># Conn <span class="number">0</span> </span></span><br><span class="line">Avg Conn Time <span class="number">0.00</span>ms</span><br></pre></td></tr></table></figure>
<p>这个时候在远程桌面客户端的地址输入：geekzph.com:98805，就可以连接到位于内网的电脑了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在很多时候我需要把内网的东西暴露给外网，但是又没有外网IP。这个时候我们可以借助一些内网穿透工具达到这个目的，例如花生壳之类。但是这些收费的。ngrok是一个开源的内网穿透服务，可以在他的官网注册账号实现内网穿透，但是现在应被墙了。不过我们可以用他的源码在自己的VPS上搭建]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解快速排序]]></title>
    <link href="http://geekzph.github.io/2016/08/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://geekzph.github.io/2016/08/18/深入理解快速排序/</id>
    <published>2016-08-18T13:29:29.000Z</published>
    <updated>2017-03-02T15:17:26.000Z</updated>
    <content type="html"><![CDATA[<p>快速排序partition有几种不同的形式，下面我们来分别讨论一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// version of introduction to algorithm exercise</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">haorePartition</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">array</span>[p];</span><br><span class="line">    <span class="keyword">int</span> i = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[j] &gt; x)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i] &lt; x)</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// version of introduction to algorithm exercise</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">haorePartition</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">array</span>[p];</span><br><span class="line">    <span class="keyword">int</span> i = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[j] &gt; x)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i] &lt; x)</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//verson of introduction to algorithm content</span></span><br><span class="line"><span class="comment">//N.Lomuto</span></span><br><span class="line"><span class="comment">// Do partition in arr[begin, end), with the first element as the pivot.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lomutoPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[begin];</span><br><span class="line">    <span class="comment">// Last position where puts the no_larger element.</span></span><br><span class="line">    <span class="keyword">int</span> pos = begin;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin+<span class="number">1</span>; i!=end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            pos++;</span><br><span class="line">            <span class="keyword">if</span>(i!=pos)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr[pos], arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[begin], arr[pos]);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>快速排序partition有几种不同的形式，下面我们来分别讨论一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><sp]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建Git服务器]]></title>
    <link href="http://geekzph.github.io/2016/03/05/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://geekzph.github.io/2016/03/05/搭建Git服务器/</id>
    <published>2016-03-05T15:42:53.000Z</published>
    <updated>2017-03-01T14:14:01.000Z</updated>
    <content type="html"><![CDATA[<h4 id="搭建Git服务器">搭建Git服务器</h4><h5 id="服务器端配置">服务器端配置</h5><p>1、安装Git</p>
<p><code>$ sudo apt-get install git</code>    </p>
<p>2、创建一个git用户，用来运行git服务。通过cd + 空格 转至当前用户目录为home/git。然后创建.ssh文件夹来存储SHH公钥。大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo adduser git</span><br><span class="line"><span class="variable">$ </span>su git</span><br><span class="line"><span class="variable">$ </span>cd</span><br><span class="line"><span class="variable">$ </span>mkdir .ssh</span><br></pre></td></tr></table></figure>
<p>3、初始化Git仓库</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd /opt/git</span><br><span class="line"><span class="variable">$ </span>mkdir project.git</span><br><span class="line"><span class="variable">$ </span>cd project.git</span><br><span class="line"><span class="variable">$ </span>git --bare init</span><br></pre></td></tr></table></figure>
<p>4、owner改为git,此命令在/opt/git下执行</p>
<p><code>$ sudo chown -R git:git project.git</code>    </p>
<p>如果出现下述错误提示，就是因为权限没有修改，执行上述命令即可</p>
<pre><code>remote: <span class="keyword">error</span>: insufficient permission <span class="keyword">for</span> adding an <span class="built_in">object</span> <span class="keyword">to</span> repository database ./objects
remote: fatal: failed <span class="keyword">to</span> write <span class="built_in">object</span>
<span class="keyword">error</span>: unpack failed: unpack-objects abnormal <span class="keyword">exit</span>
</code></pre><p>5、测试本机SSH是否可以正常工作。如果出现connetction refused证明ssh不能使用，需要安装ssh</p>
<p><code>$ ssh localhost</code>    </p>
<p> 如果在客户端出现下述错误提示，则很有可能是ssh没有安装，或没有运行：</p>
<pre><code>IOperation timed <span class="keyword">out</span> fatal: Could <span class="keyword">not</span> <span class="keyword">read</span> <span class="keyword">from</span> remote rIepository.
git server Could <span class="keyword">not</span> <span class="keyword">read</span> <span class="keyword">from</span> remote repository.
</code></pre><p>这时候就需要来安装ssh</p>
<p><code>$ sudo apt-get install openssh-server</code>    </p>
<p>然后确认sshserver是否启动了：</p>
<p><code>ps -e |grep ssh</code></p>
<p>如果看到sshd那说明ssh-server已经启动了。<br>如果没有则可以这样启动：</p>
<p><code>sudo /etc/init.d/ssh start</code>    </p>
<h5 id="客服端配置">客服端配置</h5><p>1、生成ssh公钥<br>Mac和Linux可直接用下面命令生成。</p>
<p><code>$ ssh-keygen</code></p>
<p>数次回车之后就会在.ssh/id_rsa目录下生成公钥id_dsa.pub，将其复制到服务器上/tmp/id_rsa.pub，最后只要把它写入 authorized_keys 文件。</p>
<p><code>cat /tmp/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>    </p>
<p>2、将本机已有仓库与远程仓库关联</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir testgit</span><br><span class="line"><span class="variable">$ </span>cd testgit</span><br><span class="line"><span class="variable">$ </span>git init</span><br><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">'initial commit'</span></span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@ip</span><span class="symbol">:/opt/git/project</span>.git</span><br><span class="line"><span class="variable">$ </span>git push origin master</span><br></pre></td></tr></table></figure>
<p>这样就实现了本地仓库与远程仓库的关联。</p>
<p>3、在另一台电脑上可以clone下来</p>
<p><code>$ git clone git@ip:/opt/git/project.git</code>    </p>
<h6 id="Git_服务器演示">Git 服务器演示</h6><p>1、在Mac端将本地仓库test与服务器端project2仓库关联，test有readme.txt,git服务器的地址为10.211.55.3。</p>
<p><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1ezpzv0gc32j311w0wiajp.jpg" alt="image"></p>
<p>readme.txt的内容为</p>
<p><img src="http://ww3.sinaimg.cn/large/005FcoR8gw1ezpzvuxzxmj313y0t40u8.jpg" alt="image"></p>
<p>2、在Mac客户端克隆仓库到用户目录<br><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1ezpzxnogjvj311w0wijxv.jpg" alt="image"></p>
<p>3、在Windows客服端克隆仓库</p>
<p><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1ezpzyll0fwj30jo0jwwlc.jpg" alt="image"><br>4、改变readme.txt的内容</p>
<p><img src="http://ww3.sinaimg.cn/large/005FcoR8gw1ezpzzf5cc9j313y0t4gnl.jpg" alt="image"></p>
<p>5、分别在Mac端和Windows端克隆</p>
<p><img src="http://ww3.sinaimg.cn/large/005FcoR8gw1ezpzzf5cc9j313y0t4gnl.jpg" alt="image"></p>
<p><img src="http://ww4.sinaimg.cn/large/005FcoR8gw1ezq017oofaj30ja0jowlq.jpg" alt="image"></p>
<h5 id="关于Git整合代码统计的思考">关于Git整合代码统计的思考</h5><p>应该在Git源码中加入监视模块，一旦有新的代码改动push服务器，就会触发器代码统计功能。它会在发生改动的文件夹执行，以此完成此项功能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="搭建Git服务器">搭建Git服务器</h4><h5 id="服务器端配置">服务器端配置</h5><p>1、安装Git</p>
<p><code>$ sudo apt-get install git</code>    </p>
<p>2、创建一个git用户，用]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[代码行数统计]]></title>
    <link href="http://geekzph.github.io/2016/03/05/%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    <id>http://geekzph.github.io/2016/03/05/代码行数统计/</id>
    <published>2016-03-05T15:40:52.000Z</published>
    <updated>2016-03-05T15:41:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一、_代码统计">一、    代码统计</h4><p>设计思想为各个类的方法名用正则表达式来匹配，每个放的行数使用栈来计算，类之间的引用关系使用图存储。通过判断是否存在环来判断是否有循环引用。使用Python实现。</p>
<p>#####1、类SourceCodeANA</p>
<p>方法：ListAllFile()</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">ListAllFile</span><span class="params">()</span>:</span>    <span class="comment">#获取目录下所有的文件名及其路径</span>
    path = os.getcwd()   <span class="comment">#获取当前目录</span>
    file_paths=[]
    new_path = os.path.join(path,<span class="string">'SLRtableProducer'</span>)
    listfile=os.listdir(new_path)  <span class="comment">#列出目录下所有文件</span>
    <span class="keyword">for</span> files <span class="keyword">in</span> listfile:
        file_paths.append(os.path.join(new_path,files))
    <span class="keyword">return</span> listfile,file_paths      <span class="comment">#返回所有文件名lisfile,返回所有文件的路径.</span>
</code></pre><p>此方法的功能为遍历当前目录下多有的文件，返回其文件名和完整路径。</p>
<p>1.2 方法：GetName（）</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">GetName</span><span class="params">()</span>:</span>   <span class="comment">#生成类名字典</span>
    listfile,file_paths = ListAllFile()
    i = <span class="number">0</span>
    class_dict={}
    <span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:
        dotposition=file_path.rfind(<span class="string">'.'</span>)
        extention_name=file_path[dotposition+<span class="number">1</span>:]  <span class="comment">#获取扩展名</span>
        class_name=file_path[file_path.rfind(<span class="string">'/'</span>)+<span class="number">1</span>:]  <span class="comment">#类名,带.h</span>
        <span class="keyword">if</span> extention_name==<span class="string">'h'</span>:
            class_dict[class_name]=i
            newclass_dict[i]=class_name
            i=i+<span class="number">1</span>
    <span class="keyword">return</span> class_dict
</code></pre><p>此方法的功能为为每个类名生成键值对，已方便生成类引用图时表示的方便。返回类似这样的结果：{‘AnalysisTable.h’: 0, ‘global.h’: 1, ‘LexerSupport.h’: 2}</p>
<p>1.3 方法：CountLine(file_path)</p>
<pre><code>def <span class="function"><span class="title">CountLine</span><span class="params">(file_path)</span></span>:  #计算方法行数,利用栈
s=<span class="function"><span class="title">Stack</span><span class="params">()</span></span>
f=<span class="function"><span class="title">open</span><span class="params">(file_path,<span class="string">'r'</span>)</span></span>
i=<span class="number">0</span>
function_line=[]
<span class="keyword">for</span> lines <span class="keyword">in</span> f.<span class="function"><span class="title">readlines</span><span class="params">()</span></span>:
    <span class="keyword">if</span> lines.<span class="function"><span class="title">find</span><span class="params">(<span class="string">'{'</span>)</span></span>!=-<span class="number">1</span>:
        s.<span class="function"><span class="title">push</span><span class="params">(<span class="number">1</span>)</span></span>
        i=<span class="number">0</span>
    <span class="keyword">if</span> lines.<span class="function"><span class="title">find</span><span class="params">(<span class="string">'}'</span>)</span></span>!=-<span class="number">1</span>:
        s.<span class="function"><span class="title">pop</span><span class="params">()</span></span>
        <span class="keyword">if</span> s.<span class="function"><span class="title">isEmpty</span><span class="params">()</span></span>==True:
            function_line.<span class="function"><span class="title">append</span><span class="params">(i)</span></span>
            i=<span class="number">0</span>
    i=i+<span class="number">1</span>
return function_line
</code></pre><p>此方法的作用统计每个方法的行数。每当遇到’{‘时就入栈，每当遇到’}’时就出栈，当栈为空是即为这个方法已经结束。每个从文件读入一行，每次读入累加器就会加1，以此来统计行数。</p>
<p>1.4 方法：ShowReference(file_paths,class_dict)</p>
<pre><code>def <span class="function"><span class="title">ShowReference</span><span class="params">(file_paths,class_dict)</span></span>:  #生成类之间引用关系的图,用邻接矩阵存储
ReturnMat = numpy.<span class="function"><span class="title">zeros</span><span class="params">((<span class="number">21</span>,<span class="number">21</span>)</span></span>)
<span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:
    class_name=file_path[file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'/'</span>)</span></span>+<span class="number">1</span>:]
    extention_name=file_path[file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'.'</span>)</span></span>+<span class="number">1</span>:]  #获取扩展名
    <span class="keyword">if</span> os<span class="class">.path</span><span class="class">.exists</span>(file_path)==True and extention_name==<span class="string">'h'</span>:
        f=<span class="function"><span class="title">open</span><span class="params">(file_path,<span class="string">'r'</span>)</span></span>
        <span class="attribute">content</span>=f.<span class="function"><span class="title">read</span><span class="params">()</span></span>
        result1=re.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'#include "(.*)"'</span>,content)</span></span>
        result2=re.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'#include &lt;(.*)&gt;'</span>,content)</span></span>
        result1.<span class="function"><span class="title">extend</span><span class="params">(result2)</span></span>

        <span class="keyword">for</span> result <span class="keyword">in</span> result1:
            <span class="keyword">if</span> class_dict.<span class="function"><span class="title">has_key</span><span class="params">(class_name)</span></span>==True and class_dict.<span class="function"><span class="title">has_key</span><span class="params">(result)</span></span>==True:
                ReturnMat[class_dict[class_name]][class_dict[result]]=<span class="number">1</span>
return ReturnMat
</code></pre><p>此方法的作用为生成类之间引用关系的有向图,用邻接矩阵存储。</p>
<p>1.5 方法：dfs（）</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,m)</span>:</span>
<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">20</span>):
    <span class="keyword">if</span> dataSet[i][j] == <span class="number">1</span>:

        <span class="keyword">if</span> m!=i:
            <span class="keyword">print</span> <span class="string">'----------------------------------------------------------'</span>
        <span class="keyword">print</span> newclass_dict[i],<span class="string">'-&gt;'</span>,newclass_dict[j]
        dataSet[i][j]=<span class="number">2</span>
        m=j
        dfs(j,m)
</code></pre><p>这个方法是用来遍历类引用关系生成的邻接矩阵，采用了深度优先遍历，以此来得到类之间的引用关系。</p>
<p>1.6 方法：Main（）</p>
<pre><code>def <span class="function"><span class="title">Main</span><span class="params">()</span></span>:
listfile,file_paths=<span class="function"><span class="title">ListAllFile</span><span class="params">()</span></span>
class_count=<span class="number">0</span>      #类的个数
class_name=<span class="string">''</span>      #类名
function_lines=<span class="number">0</span>   #方法行数
reclass=[]         #类中所引用的类

<span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:  #遍历所有文件
    isCycle=<span class="string">'否'</span>      #是否存在循环引用
    reclass=[]       #引用类list
    dotposition=file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'.'</span>)</span></span>
    extention_name=file_path[dotposition+<span class="number">1</span>:]  #获取扩展名
    <span class="keyword">if</span> extention_name==<span class="string">'h'</span>:  #利用.h文件计算方法个数
        class_count=class_count+<span class="number">1</span>  #类的个数
        class_name=file_path[file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'/'</span>)</span></span>+<span class="number">1</span>:dotposition]  #类名,不带<span class="class">.h</span>
        class_name_h=class_name+<span class="string">'.h'</span>   #类名,带<span class="class">.h</span>
        cppfile_path=file_path[:dotposition]+<span class="string">'.cpp'</span>    #.cpp文件路径

        <span class="keyword">if</span> os<span class="class">.path</span><span class="class">.exists</span>(cppfile_path)==True:    #通过cpp计算方法行数
            function_lines=<span class="function"><span class="title">CountLine</span><span class="params">(cppfile_path)</span></span>
        <span class="keyword">else</span>:
            function_lines=<span class="number">0</span>

        #打开.h文件,统计方法
        f=<span class="function"><span class="title">open</span><span class="params">(file_path,<span class="string">'r'</span>)</span></span>
        <span class="attribute">content</span>=f.<span class="function"><span class="title">read</span><span class="params">()</span></span>
        reresult=re.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'(\w*)\((.*?)\);| (\w*)\((.*?)\)\s*\{'</span>,content)</span></span>
        function_count=<span class="function"><span class="title">len</span><span class="params">(reresult)</span></span>
        <span class="keyword">for</span> name <span class="keyword">in</span> reresult:  #方法名加入list
            <span class="keyword">if</span> name[<span class="number">0</span>]!=<span class="string">''</span>:
                function_name.<span class="function"><span class="title">append</span><span class="params">(name[<span class="number">0</span>])</span></span>

        print <span class="string">'类名为:'</span>,class_name
        print <span class="string">'方法个数为:'</span>,function_count
        <span class="keyword">if</span> function_count!=<span class="number">0</span> and function_lines!=<span class="number">0</span>:
            print <span class="function"><span class="title">sorted</span><span class="params">(function_lines)</span></span>
            print <span class="string">'最长的方法有:'</span>,<span class="function"><span class="title">sorted</span><span class="params">(function_lines)</span></span>[<span class="number">0</span>],<span class="string">'行'</span>
            print <span class="string">'最短的方法有:'</span>,<span class="function"><span class="title">sorted</span><span class="params">(function_lines)</span></span>[<span class="function"><span class="title">len</span><span class="params">(function_lines)</span></span>-<span class="number">1</span>],<span class="string">'行'</span>
            print <span class="string">'引用的类有:'</span>,reclass
            print <span class="string">'是否存在循环引用:'</span>,isCycle
            print <span class="string">'------------------------------'</span>
        <span class="keyword">else</span>:
            print <span class="string">'------------------------------'</span>
</code></pre><p>此函数为主函数，主要为获取各个函数名，以及输出最后的结果。</p>
<p>#####2、类Stack</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span>
<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,size = <span class="number">16</span>)</span>:</span>
    self.stack = []
    self.size = size
    self.top = -<span class="number">1</span>
<span class="function"><span class="keyword">def</span> <span class="title">setSize</span><span class="params">(self, size)</span>:</span>
    self.size = size
<span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.top == -<span class="number">1</span>:
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="keyword">False</span>
<span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.top +<span class="number">1</span> == self.size:
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="keyword">False</span>
<span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.isEmpty():
        <span class="keyword">raise</span> Exception(<span class="string">"StackIsEmpty"</span>)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> self.stack[self.top]
<span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,obj)</span>:</span>
    <span class="keyword">if</span> self.isFull():
        <span class="keyword">raise</span> Exception(<span class="string">"StackOverFlow"</span>)
    <span class="keyword">else</span>:
        self.stack.append(obj)
        self.top +=<span class="number">1</span>
<span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.isEmpty():
        <span class="keyword">raise</span> Exception(<span class="string">"StackIsEmpty"</span>)
    <span class="keyword">else</span>:
        self.top -= <span class="number">1</span>
        <span class="keyword">return</span> self.stack.pop()
<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span>
    print(self.stack)
</code></pre><p>这个类实现了栈这种数据结构，用来统计代码行数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="一、_代码统计">一、    代码统计</h4><p>设计思想为各个类的方法名用正则表达式来匹配，每个放的行数使用栈来计算，类之间的引用关系使用图存储。通过判断是否存在环来判断是否有循环引用。使用Python实现。</p>
<p>#####1、类SourceCod]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[经济学人词频统计]]></title>
    <link href="http://geekzph.github.io/2015/12/15/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%BA%BA%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"/>
    <id>http://geekzph.github.io/2015/12/15/经济学人词频统计/</id>
    <published>2015-12-15T06:55:39.000Z</published>
    <updated>2015-12-15T06:55:39.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用Python提取心跳节律信息]]></title>
    <link href="http://geekzph.github.io/2015/12/15/%E5%88%A9%E7%94%A8Python%E6%8F%90%E5%8F%96%E5%BF%83%E8%B7%B3%E8%8A%82%E5%BE%8B%E4%BF%A1%E6%81%AF/"/>
    <id>http://geekzph.github.io/2015/12/15/利用Python提取心跳节律信息/</id>
    <published>2015-12-15T06:13:42.000Z</published>
    <updated>2015-12-15T06:36:20.000Z</updated>
    <content type="html"><![CDATA[<h4 id="心跳信息的提取分析：">心跳信息的提取分析：</h4><p>首先，ECG_signal.mat文件包含两组信息ECG_1和Time_Adjusted。其中ECG_1中存储的信息为心跳的数值，可以观察到大部分数值为负数。而波峰均为整数，可以通过计算两个相邻波峰之间的实际来得到周期，从而计算出心跳的次数。</p>
<h4 id="具体实现过程：">具体实现过程：</h4><p>使用Pyhton第三方库scipy中的loadmat来加载mat文件，格式为字典，因为此文件包含两个量，所以就有两个键。以正负变化的点作为分割点对ECG_1进行划分，把正负改变点放在list中。计算list中每两个相邻索引之间最大值的下标，这些小标就是心跳图形波峰的下标。利用这些下标在Time_Adjusted中得到波峰的采样时间点，两个波峰之间的时间差就是一个周期的实际，把计算出的每个周期时间相加再除以个数，就获得了平均周期时间。所以一分钟心跳次数=60/周期</p>
<h4 id="Python代码">Python代码</h4><pre><code><span class="comment"># -*- coding: UTF-8 –*-</span>
<span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt
data = sio.loadmat(<span class="string">'ECG_signal.mat'</span>)   <span class="comment"># 加载mat文件</span>
mylist=[]                     <span class="comment"># 存储正负改变点的索引</span>
ecg=data[<span class="string">'ECG_1'</span>]             <span class="comment"># ecg为numpy.ndarray型</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(ecg)-<span class="number">1</span>,<span class="number">1</span>):
    <span class="keyword">if</span> (ecg[i]&lt;<span class="number">0</span> <span class="keyword">and</span> ecg[i+<span class="number">1</span>]&gt;=<span class="number">0</span>) <span class="keyword">or</span> (ecg[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> ecg[i+<span class="number">1</span>]&lt;<span class="number">0</span>):
        mylist.append(i)

maxindex=[]                   <span class="comment"># 最大值的索引</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(mylist),<span class="number">2</span>):
    maxindex.append(mylist[i]+ecg[mylist[i]:mylist[i+<span class="number">1</span>]].argmax())

period = []                            <span class="comment"># 分别存储各个周期</span>
time_adjusted=data[<span class="string">'Time_Adjusted'</span>][<span class="number">0</span>] <span class="comment"># 取第0行的数据</span>
count = <span class="number">0</span>                              <span class="comment"># 周期个数</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(maxindex)-<span class="number">1</span>,<span class="number">1</span>):
    period.append(time_adjusted[maxindex[i+<span class="number">1</span>]]-time_adjusted[maxindex[i]]) <span class="comment"># 各个周期加入list中</span>
count = count + <span class="number">1</span>

<span class="keyword">print</span> <span class="string">'原始数据的周期个数:'</span>,count
total_time=<span class="number">0</span>
<span class="keyword">for</span> i <span class="keyword">in</span> period:
    total_time= total_time+i
<span class="keyword">print</span> <span class="string">'原始数据的周期为:'</span>,total_time/count
<span class="keyword">print</span> ‘一分钟的心跳次数为:<span class="string">',60/(total_time/count)</span>
</code></pre><h4 id="运行结果：">运行结果：</h4><p>原始数据的周期个数: 24</p>
<p>原始数据的周期为: 0.813541666667</p>
<p>一分钟的心跳次数为: 73.7516005122</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="心跳信息的提取分析：">心跳信息的提取分析：</h4><p>首先，ECG_signal.mat文件包含两组信息ECG_1和Time_Adjusted。其中ECG_1中存储的信息为心跳的数值，可以观察到大部分数值为负数。而波峰均为整数，可以通过计算两个相邻波峰之间的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下Java环境变量的配置]]></title>
    <link href="http://geekzph.github.io/2015/12/08/Linux%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://geekzph.github.io/2015/12/08/Linux下Java环境变量的配置/</id>
    <published>2015-12-08T06:19:19.000Z</published>
    <updated>2015-12-08T06:19:19.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫爬取动态网页]]></title>
    <link href="http://geekzph.github.io/2015/12/08/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/"/>
    <id>http://geekzph.github.io/2015/12/08/Python爬虫爬取动态网页/</id>
    <published>2015-12-08T06:17:43.000Z</published>
    <updated>2015-12-15T06:26:49.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[《与时间做朋友》读书笔记]]></title>
    <link href="http://geekzph.github.io/2015/12/08/%E3%80%8A%E4%B8%8E%E6%97%B6%E9%97%B4%E5%81%9A%E6%9C%8B%E5%8F%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://geekzph.github.io/2015/12/08/《与时间做朋友》读书笔记/</id>
    <published>2015-12-08T06:17:03.000Z</published>
    <updated>2015-12-08T06:17:03.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Matlab实现基于内容的图像检索系统]]></title>
    <link href="http://geekzph.github.io/2015/12/06/Matlab%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E5%9B%BE%E5%83%8F%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://geekzph.github.io/2015/12/06/Matlab实现基于内容的图像检索系统/</id>
    <published>2015-12-06T13:39:21.000Z</published>
    <updated>2015-12-14T13:47:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、_检索方案">一、 检索方案</h3><p>常见的图像特征有:颜色、纹理、形状、空间关系。<br>此次检索的物体为汽车,汽车有比较明显的颜色特征,而在纹理特征方面也与其他物体也有一定的区别,因此本次实验选取了颜色和纹理做为两个检索特征。颜色特征是通 过颜色矩的方式来进行提取,颜色矩是一种简单有效的颜 色特征表示方法,有一阶矩(均值,mean)、二阶矩(方 差,viarance)和三阶矩(斜度,skewness)等,由于颜色信息 主要分布于低阶矩中,所以用一阶矩,二阶矩和三阶矩足 以表达图像的颜色分布,颜色矩已证明可有效地表示图像中的颜色分布。纹理特征是通过LBP方法来进行提取。LBP 是一种用来描述图像局部纹理特征的算法;它的作用是进行特征提取,提取图像的局部纹理特征。原始的LBP算法定义为在 3 <em> 3的窗口内,以窗口中心像素为阈值,将相邻的8个像素的灰度值与其进行比较,若周围像素值大于中 心像素值,则该像素点的位置被标记为 1,否则为0。3 </em> 3领域内的8个点可产生 8bit 的无符号数,即得到该窗口的 LBP 值,并用这个值来反映该区域的纹理信息。</p>
<h3 id="二、_实现方法">二、 实现方法</h3><p>共有100张图片,其中50张为汽车,另外50张为其他背景图片。首先要做的就是对这 100张图片建索引, 对这些图片分别提取纹理特征和颜色矩特征,并存mat文件。之后就可以进行检索了。纹理特征和颜色矩特征都是一维向量,检索的时候分别计算待检索图像和mat文件中颜色矩和纹理特征向量的欧几里得距离,并给予不同的权值。对这些距离进行升序排序,这样就得到了图像检索结果。</p>
<h3 id="三、_运行结果">三、 运行结果</h3><p><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1eyziseb8n9j310e0kadkw.jpg" alt=""></p>
<p><a href="https://github.com/geekzph/CBIR" target="_blank" rel="external">https://github.com/geekzph/CBIR</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、_检索方案">一、 检索方案</h3><p>常见的图像特征有:颜色、纹理、形状、空间关系。<br>此次检索的物体为汽车,汽车有比较明显的颜色特征,而在纹理特征方面也与其他物体也有一定的区别,因此本次实验选取了颜色和纹理做为两个检索特征。颜色特征是通 过颜色矩的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Matlab实现JPEG压缩]]></title>
    <link href="http://geekzph.github.io/2015/12/06/%E4%BD%BF%E7%94%A8Matlab%E5%AE%9E%E7%8E%B0JPEG%E5%8E%8B%E7%BC%A9/"/>
    <id>http://geekzph.github.io/2015/12/06/使用Matlab实现JPEG压缩/</id>
    <published>2015-12-06T13:07:50.000Z</published>
    <updated>2015-12-14T14:07:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、_图像压缩原理">一、 图像压缩原理</h3><p>图像分成 8*8 小块 –&gt; DCT 变换 –&gt;用量化表对其量化 –&gt;编码生成压缩数据</p>
<h3 id="二、_具体压缩过程">二、 具体压缩过程</h3><ul>
<li>1、将原始图像分为 8 * 8 的小块, 每个 block 里有 64 个像素。</li>
</ul>
<ul>
<li><p>2、 将图像中每个 8 <em> 8 的 block 进行 DCT 变换。8 </em> 8 的图象经过 DCT 变换后,其低频分量都集中在左上角,高频分量分布在右下角。由于该低频分量包含了图象的主要信息(如亮度),而高频与之相比,就不那么重要了,所以我们可以忽略高频分量。</p>
</li>
<li><p>3、 利用量化表抑制高频变量。量化操作,就是将某一个值除以量化表中对应的值。由 于量化表左上角的值较小,右上角的值较大,这样就起到了保持低频分量,抑制高 频分量的目的。压缩时候将彩色图像的颜色空间由 RGB 转化为 YUV 格式。其中 Y 分量代表了亮度信息,UV 分量代表了色差信息。相比而言,Y 分量更重要一些。 我们可以对 Y 采用细量化,对 UV 采用粗量化,可进一步提高压缩比。所以量化表 通常有两张,一张是针对 Y 的标准亮度量化表;一张是针对 UV 的标准色彩量化表。</p>
</li>
</ul>
<ul>
<li>4、 经过量化之后右下角大部分数据变成了 0,左上角为非零数据。这时使用 Z 字型(如 图所示)的顺序来重新排列数据生成一个整数数组,这样 0 就位于数组都后端。找到数组最后一个非零元素,将其后的数据都舍弃,并加上结束标志。</li>
</ul>
<h3 id="三、_关键代码">三、 关键代码</h3><h4 id="Compress-m">Compress.m</h4><pre><code>function [comp_image_Y,comp_image_U,comp_image_V] = Compress(orig_image)
RGB=orig_image<span class="comment">;</span>
%下面是对 RGB 三个分量进行分离 
R=RGB(:,:,1)<span class="comment">;</span>
G=RGB(:,:,2)<span class="comment">;</span>
B=RGB(:,:,3)<span class="comment">;</span>
%RGB-&gt;YUV Y=0.299*double(R)+0.587*double(G)    +0.114*double(B)<span class="comment">; </span>
[xm, xn] = size(Y)<span class="comment">;             </span>
U=-0.169*double(R)-0.3316*double(G)+0.5*double(B)<span class="comment">;     V=0.5*double(R)-0.4186*double(G)-0.0813*double(B);</span>
%产生一个 8*8 的 DCT 变换举证 
T=dctmtx(8)<span class="comment">;</span>
%进行 DCT 变换 BY BU BV 是 double 类型
BY=blkproc(Y,[8 8],'P1*x*P2',T,T')<span class="comment">; </span>
BU=blkproc(U,[8 8],'P1*x*P2',T,T')<span class="comment">; </span>
BV=blkproc(V,[8 8],'P1*x*P2',T,T')<span class="comment">;     %低频分量量化表</span>
a=[
<span class="number">16 11 10 16</span> <span class="number">24 40 51 61</span><span class="comment">;</span>
<span class="number">12 12 14 19</span> <span class="number">26 58 60 55</span><span class="comment">;</span>
<span class="number">14 13 16 24</span> <span class="number">40 57 69 55</span><span class="comment">;</span>
<span class="number">14 17 22 29</span> <span class="number">51 87 80 62</span><span class="comment">;</span>
<span class="number">18 22 37 56</span> <span class="number">68 109 103 77</span><span class="comment">; </span>
<span class="number">24 35 55 64</span> <span class="number">81 104 113 92</span><span class="comment">;                         </span>
49     <span class="number">64 78 87 103</span> <span class="number">121 120 101</span><span class="comment">;                     </span>
<span class="number">72 92 95 98</span> <span class="number">112 100 103 99</span><span class="comment">;</span>
]<span class="comment">; %高频分量量化表</span>
b=[<span class="number">17 18 24 47</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">18 21 26 66</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">24 26 56 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">47 66 99 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">99 99 99 99</span> 99     99 99 99<span class="comment">; </span>
<span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;];</span>
%使用量化表对三个分量进行量化 
BY2=blkproc(BY,[8 8],'round(x./P1)',a)<span class="comment">; </span>
BU2=blkproc(BU,[8 8],'round(x./    P1)',b)<span class="comment">; </span>
BV2=blkproc(BV,[8 8],'round(x./P1)',b)<span class="comment">;</span>
%调用压缩函数 
comp_image_Y=img2jpg(BY2,1)<span class="comment">;         </span>
comp_image_U=img2jpg(BU2,2)<span class="comment">;                     </span>
comp_image_V=img2jpg(BV2,3)<span class="comment">;</span>
</code></pre><h4 id="img2jpg-m">img2jpg.m</h4><pre><code><span class="function"><span class="keyword">function</span> <span class="params">[ y ]</span> = <span class="title">img2jpg</span><span class="params">( x,flag )</span></span>
<span class="matrix">[xm, xn]</span> = <span class="built_in">size</span>(x);
<span class="comment">%z字型读取数据顺序表</span>
order = <span class="matrix">[<span class="number">1</span> <span class="number">9</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">10</span> <span class="number">17</span> <span class="number">25</span> <span class="number">18</span> <span class="number">11</span> <span class="number">4</span>  <span class="number">5</span>  <span class="number">12</span> <span class="number">19</span> <span class="number">26</span> <span class="number">33</span>  ...
    <span class="number">41</span> <span class="number">34</span> <span class="number">27</span> <span class="number">20</span> <span class="number">13</span> <span class="number">6</span>  <span class="number">7</span>  <span class="number">14</span> <span class="number">21</span> <span class="number">28</span> <span class="number">35</span> <span class="number">42</span> <span class="number">49</span> <span class="number">57</span> <span class="number">50</span>  ...
    <span class="number">43</span> <span class="number">36</span> <span class="number">29</span> <span class="number">22</span> <span class="number">15</span> <span class="number">8</span>  <span class="number">16</span> <span class="number">23</span> <span class="number">30</span> <span class="number">37</span> <span class="number">44</span> <span class="number">51</span> <span class="number">58</span> <span class="number">59</span> <span class="number">52</span>  ...
    <span class="number">45</span> <span class="number">38</span> <span class="number">31</span> <span class="number">24</span> <span class="number">32</span> <span class="number">39</span> <span class="number">46</span> <span class="number">53</span> <span class="number">60</span> <span class="number">61</span> <span class="number">54</span> <span class="number">47</span> <span class="number">40</span> <span class="number">48</span> <span class="number">55</span>  ...
    <span class="number">62</span> <span class="number">63</span> <span class="number">56</span> <span class="number">64</span>]</span>;

y = im2col(x, <span class="matrix">[<span class="number">8</span> <span class="number">8</span>]</span>, <span class="string">'distinct'</span>);  <span class="comment">% 将8x8 的块转化为列</span>
xb = <span class="built_in">size</span>(y, <span class="number">2</span>);                   <span class="comment">% 分块数</span>
y = y(order, :);                   <span class="comment">% 按照order的顺序排列数据</span>

eob = max(y(:)) + <span class="number">1</span>;               <span class="comment">% 设置块尾结束标志</span>
r = <span class="built_in">zeros</span>(<span class="built_in">numel</span>(y) + <span class="built_in">size</span>(y, <span class="number">2</span>), <span class="number">1</span>);
count = <span class="number">0</span>;
<span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:xb                       <span class="comment">% 每次处理一个块</span>
    <span class="built_in">i</span> = max(<span class="built_in">find</span>(y(:, <span class="built_in">j</span>)));         <span class="comment">% 找到最后一个非零元素</span>
    <span class="keyword">if</span> <span class="built_in">isempty</span>(<span class="built_in">i</span>)                   
          <span class="built_in">i</span> = <span class="number">0</span>;
    <span class="keyword">end</span>
    p = count + <span class="number">1</span>;
    q = p + <span class="built_in">i</span>;
    r(p:q) = <span class="matrix">[y(<span class="number">1</span>:i, j); eob]</span>;      <span class="comment">% 加入块结束标志</span>
    count = count + <span class="built_in">i</span> + <span class="number">1</span>;          <span class="comment">% 计数</span>
<span class="keyword">end</span>

r((count + <span class="number">1</span>):<span class="keyword">end</span>) = <span class="matrix">[]</span>;           <span class="comment">% 删除r 中不需要的元素</span>
<span class="matrix">[r1,r2]</span>=<span class="built_in">size</span>(r);
y           = struct;
y.realsize = r1;
y.<span class="built_in">size</span>      = uint16(<span class="matrix">[xm xn]</span>);
y.numblocks = uint16(xb);
y.r   = r;
y.flag = flag;

<span class="keyword">end</span>
</code></pre><h4 id="jpg2img">jpg2img</h4><pre><code>function [ x ] = jpg2img( y )
%低频分量量化表   
a=[
<span class="number">16 11 10 16</span> <span class="number">24 40 51 61</span><span class="comment">;  </span>
<span class="number">12 12 14 19</span> <span class="number">26 58 60 55</span><span class="comment">;  </span>
<span class="number">14 13 16 24</span> <span class="number">40 57 69 55</span><span class="comment">;  </span>
<span class="number">14 17 22 29</span> <span class="number">51 87 80 62</span><span class="comment">;  </span>
<span class="number">18 22 37 56</span> <span class="number">68 109 103 77</span><span class="comment">;  </span>
<span class="number">24 35 55 64</span> <span class="number">81 104 113 92</span><span class="comment">;  </span>
<span class="number">49 64 78 87</span> <span class="number">103 121 120 101</span><span class="comment">;  </span>
<span class="number">72 92 95 98</span> <span class="number">112 100 103 99</span><span class="comment">;</span>

]<span class="comment">;  </span>
%高频分量量化表    
b=[<span class="number">17 18 24 47</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">18 21 26 66</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">24 26 56 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">47 66 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;]; </span>

order = [1 9  2  3  <span class="number">10 17 25 18</span> 11 4  5  <span class="number">12 19 26 33</span>  ...
    <span class="number">41 34 27 20</span> 13 6  7  <span class="number">14 21 28 35</span> <span class="number">42 49 57 50</span>  ...
    <span class="number">43 36 29 22</span> 15 8  <span class="number">16 23 30 37</span> <span class="number">44 51 58 59</span> 52  ...
    <span class="number">45 38 31 24</span> <span class="number">32 39 46 53</span> <span class="number">60 61 54 47</span> 40 48 55  ...
    <span class="number">62 63 56 64</span>]<span class="comment">;</span>
rev = order<span class="comment">;                          % 计算反序</span>
for k = 1:length(order)
    rev(k) = find(order == k)<span class="comment">;</span>
end

xb = double(y.numblocks)<span class="comment">;             % 块的个数</span>
sz = double(y.size)<span class="comment">;</span>
xn = sz(2)<span class="comment">;                           % 列数</span>
xm = sz(1)<span class="comment">;                           % 行数</span>
x = y.r<span class="comment">;                              % 压缩后的数据</span>
eob = max(x(:))<span class="comment">;                      % 返回块尾标志</span>

z = zeros(64, xb)<span class="comment">;   k = 1;           % 生成 64 * xb 的零矩阵</span>
for j = 1:xb                          % x中的值放入z中，如果遇到eob就转入下一列
    for i = 1:64                       
          if x(k) == eob                  
             k = k + 1<span class="comment">;   </span>
             break<span class="comment">;          </span>
          else
             z(i, j) = x(k)<span class="comment">;</span>
             k = k + 1<span class="comment">;</span>
          end
    end
end
T=dctmtx(8)<span class="comment">;                                   %产生一个8*8的DCT变换举证  </span>
z = z(rev, :)<span class="comment">;                                 % 按order恢复之前排列</span>
x = col2im(z, [8 8], [xm xn], 'distinct')<span class="comment">;     % 生成矩阵</span>
if y.flag==1
    x = blkproc(x, [8 8], 'x .* P1', a)<span class="comment">;       % 反量化，乘量化表的值</span>
else
    x = blkproc(x, [8 8], 'x .* P1', b)<span class="comment">;</span>
end
x = blkproc(x, [8 8], 'P1 * x * P2', T', T)<span class="comment">;   % 反DCT变换</span>
end
</code></pre><h4 id="Decompress-m">Decompress.m</h4><pre><code>function reco_image = Decompress(orig_image_Y,orig_image_U,orig_image_V) %解压缩
YI=jpg2img(orig_image_Y)<span class="comment">;</span>
UI=jpg2img(orig_image_U)<span class="comment">;</span>
VI=jpg2img(orig_image_V)<span class="comment">;</span>
%YUV 转为 RGB
RI=YI-0.001*UI+1.402*VI<span class="comment">; </span>
GI=YI-0.344*UI-0.714*VI<span class="comment">; </span>
BI=YI+1.772*UI+0.001*VI<span class="comment">;</span>
%经过 DCT 变换和量化后的 YUV 图像 
RGBI=cat(3,RI,GI,BI)<span class="comment">;</span>
RGBI=uint8(RGBI)<span class="comment">;</span>
reco_image = RGBI<span class="comment">;</span>
</code></pre><h4 id="运行结果">运行结果</h4><p><img src="http://ww4.sinaimg.cn/large/005FcoR8jw1eys83bfllhj30fk0bojs7.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005FcoR8jw1eys82m17wfj30fk0bo755.jpg" alt=""></p>
<p><a href="https://github.com/geekzph/JPEGCompression" target="_blank" rel="external">https://github.com/geekzph/JPEGCompression</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、_图像压缩原理">一、 图像压缩原理</h3><p>图像分成 8*8 小块 –&gt; DCT 变换 –&gt;用量化表对其量化 –&gt;编码生成压缩数据</p>
<h3 id="二、_具体压缩过程">二、 具体压缩过程</h3><ul>
<li>1、将原始]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python读取mat文件]]></title>
    <link href="http://geekzph.github.io/2015/10/22/Python%E8%AF%BB%E5%8F%96mat%E6%96%87%E4%BB%B6/"/>
    <id>http://geekzph.github.io/2015/10/22/Python读取mat文件/</id>
    <published>2015-10-22T08:09:53.000Z</published>
    <updated>2015-10-25T10:01:20.000Z</updated>
    <content type="html"><![CDATA[<h4 id="读取mat文件">读取mat文件</h4><p>mat数据格式是Matlab的数据存储的标准格式。在Matlab中主要使用load()函数导入一个mat文件，使用save()函数保存一个mat文件。在Python中处理mat文件，需要导入scipy库，它的load函数可以加载mat文件。读取进来的数据是字典格式。</p>
<pre><code><span class="import"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span>
<span class="typedef"><span class="keyword">data</span> = sio.loadmat<span class="container">('<span class="type">ECG_signal</span>.<span class="title">mat'</span>)</span>   # 加载mat文件</span>
<span class="title">print</span> <span class="typedef"><span class="keyword">type</span><span class="container">(<span class="title">data</span>)</span>                       #查看数据格式</span>
</code></pre><p>我的mat文件中有两个量，一个是ECG_1，另一个是Time_Adjusted，可以用print显示出来</p>
<pre><code>#加载后的文件为字典,打印数据
<span class="function"><span class="title">print</span><span class="params">(<span class="string">'\nThe vaulue of Time_Adjusted:'</span>)</span></span>
<span class="function"><span class="title">print</span><span class="params">(data[<span class="string">'Time_Adjusted'</span>])</span></span>
<span class="function"><span class="title">print</span><span class="params">(<span class="string">'\nThe vaulue of ECG:'</span>)</span><span class="title">r</span></span>
<span class="function"><span class="title">print</span><span class="params">(data[<span class="string">'ECG_1'</span>])</span></span>
</code></pre><p>还可以用matplotlib库，绘制图形。</p>
<pre><code>#绘图
plt.<span class="function"><span class="title">figure</span><span class="params">(<span class="number">1</span>)</span></span>
plt.<span class="function"><span class="title">plot</span><span class="params">(data[<span class="string">'ECG_1'</span>])</span></span>
plt.<span class="function"><span class="title">figure</span><span class="params">(<span class="number">2</span>)</span></span>
plt.<span class="function"><span class="title">plot</span><span class="params">(data[<span class="string">'Time_Adjusted'</span>])</span></span>
plt.<span class="function"><span class="title">show</span><span class="params">()</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="读取mat文件">读取mat文件</h4><p>mat数据格式是Matlab的数据存储的标准格式。在Matlab中主要使用load()函数导入一个mat文件，使用save()函数保存一个mat文件。在Python中处理mat文件，需要导入scipy库，它的load]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu下安装软件方法总结]]></title>
    <link href="http://geekzph.github.io/2015/10/16/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://geekzph.github.io/2015/10/16/Ubuntu下安装软件方法总结/</id>
    <published>2015-10-16T13:31:07.000Z</published>
    <updated>2015-10-19T10:26:48.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>sudo apt-get install packagename 命令<br>apt-get是ubuntu下一个强大的命令行工具。可以用它来安装新的软件包，升级现有的软件包，升级列表索引，甚至升级整个系统。如果出现could not get lock /var/lib/dpkg/lock -open等 ，类似这样的提示，是因为有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。输入下面命令就行了。</p>
<p> sudo rm /var/cache/apt/archives/lock</p>
<p> sudo rm /var/lib/dpkg/lock</p>
</li>
<li>deb格式文件是Ubuntu可安装类型，可以通过双击来直接安装。也可以使用dkpg命令来安装：dpkg -i xxx.deb ，参数i表示可安装的意思</li>
<li>rpm格式是Red Hat Package Manager的简称。在Ubuntu不能通过双击来安装。一般使用alien命令把rpm转换为deb格式后在安装。首先要安装alien命令：sudo apt-get install alien ，然后用alien来转换：sudo alien xxx.rpm 之后会在同文件夹生成同名的deb文件，然后就可以安装了</li>
<li>tar.gz和tar.bz2格式文件的安装。一般需要先解压：tar -zxvf FileName.tar.gz ，然后根据解压后的情况来安装。如果是源码的话，在解压后文件夹里会有confiure文件，源码文件的安装，首先执行：./configure  来进行配置，然后执行make来进行编译，最后执行make install 安装。make uninstall 来进行卸载。或者在配置时指定软件将要安装到目标路径：./configure –prefix=目录名，这样可以使用“rm -rf 软件目录名”命令来进行干净彻底的卸载。</li>
<li>run格式文件的安装。首先执行 chmod +x xxx.run来增加执行权限，然后执行sudo ./xxx.run就可以安装了</li>
<li><p>sh 格式文件。直接 ./xxx.sh 来进行安装。如果遇到这样情况</p>
<p> Configuring the installer…<br> Searching for JVM on the system…<br> Extracting installation data…<br> Installer file /home/jiangkai/netbeans-7.2.1-ml-linux.sh seems to be corrupted<br>很可能是下载文件不完整，建议重新下载在安装。</p>
</li>
</ol>
<p>常用的apt命令</p>
<pre><code>apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">search</span> <span class="keyword">package</span> 搜索包
apt-<span class="keyword">cache</span> <span class="keyword">show</span> <span class="keyword">package</span> 获取包的相关信息，如说明、大小、版本等
sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> <span class="keyword">package</span> 安装包
sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> <span class="keyword">package</span> - - reinstall 重新安装包
sudo apt-<span class="keyword">get</span> -<span class="keyword">f</span> <span class="keyword">install</span> 修复安装<span class="string">"-f = - -fix-missing"</span>
sudo apt-<span class="keyword">get</span> remove <span class="keyword">package</span> 删除包
sudo apt-<span class="keyword">get</span> remove <span class="keyword">package</span> - - <span class="keyword">purge</span> 删除包，包括删除配置文件等
sudo apt-<span class="keyword">get</span> <span class="keyword">update</span> 更新源
sudo apt-<span class="keyword">get</span> <span class="keyword">upgrade</span> 更新已安装的包
sudo apt-<span class="keyword">get</span> dist-<span class="keyword">upgrade</span> 升级系统
sudo apt-<span class="keyword">get</span> dselect-<span class="keyword">upgrade</span> 使用 dselect 升级
apt-<span class="keyword">cache</span> depends <span class="keyword">package</span> 了解使用依赖
apt-<span class="keyword">cache</span> rdepends <span class="keyword">package</span> 是查看该包被哪些包依赖
sudo apt-<span class="keyword">get</span> <span class="keyword">build</span>-dep <span class="keyword">package</span> 安装相关的编译环境
apt-<span class="keyword">get</span> <span class="keyword">source</span> <span class="keyword">package</span> 下载该包的源代码
sudo apt-<span class="keyword">get</span> clean &amp;&amp; sudo apt-<span class="keyword">get</span> autoclean 清理无用的包
sudo apt-<span class="keyword">get</span> <span class="keyword">check</span> 检查是否有损坏的依赖</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>sudo apt-get install packagename 命令<br>apt-get是ubuntu下一个强大的命令行工具。可以用它来安装新的软件包，升级现有的软件包，升级列表索引，甚至升级整个系统。如果出现could not get lock /v]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下Parallels Desktop安装Ubuntu无法全屏]]></title>
    <link href="http://geekzph.github.io/2015/10/16/Mac%E4%B8%8BParallels-Desktop%E5%AE%89%E8%A3%85Ubuntu%E6%97%A0%E6%B3%95%E5%85%A8%E5%B1%8F/"/>
    <id>http://geekzph.github.io/2015/10/16/Mac下Parallels-Desktop安装Ubuntu无法全屏/</id>
    <published>2015-10-16T13:14:03.000Z</published>
    <updated>2015-10-16T13:31:38.000Z</updated>
    <content type="html"><![CDATA[<p>在Mac中，Parallels Desktop安装Ubuntu无法全屏问题出现，是由于在安装ubuntn是没有选择快速安装，因此在安装过程中就没有安装Parallels Tools。因此就会出现比如分辨率问题，或者终端窗口显示不正常等一些问题。解决这个问题方法就是安装Parallels Tools。可按照以下步骤安装：</p>
<ol>
<li>启动虚拟机。</li>
<li>确保虚拟机的 CD/DVD 驱动指向默认的空驱动</li>
<li>操作系统启动后请点击PD顶部菜单里的操作-&gt;安装Parallels Tools。<br>prl-tools-lin.iso 镜像文件将会加载至虚拟机的 CD/DVD 驱动器中。<br>如果上述方法没有加载成功，您也可手动连接并安装 Parallels Tools ISO 镜像文件。<br>右击虚拟机窗口的状态栏中的 CD/DVD 驱动图标并选择连接镜像。在弹出的 Finder 窗口中，进入硬盘文件夹（通常名为 “Macintosh HD”），选择 /Library/Parallels/Tools/ 文件夹（针对Parallels Desktop 7）或 /Applications/Parallels Desktop.app/Contents/Resources/Tools/ （针对 Parallels Desktop 8），选择prl-tools-lin.iso文件，然后点击打开连接至虚拟机。</li>
<li>在您的 Ubuntu 虚拟机中启动 终端。</li>
<li><p>在终端中找到光驱的位置：</p>
<p> cd /media/username/Parallels\ Tools/</p>
</li>
</ol>
<p>输入以下命令安装：</p>
<pre><code>sudo ./<span class="keyword">install</span>
</code></pre><p>根据 Parallels Tools 安装程序的提示完成安装。在 Parallels Tools 安装完成后，重新启动虚拟机。</p>
<blockquote>
<p>注意：1.上述命令中的Parallels\ Tools/的斜杠是因为路径名字包含空格，使用\作为转义字符代替空格<br> 2.不要在光驱中双击install-gui来安装，那样是无法安装的，必须在命令行下才可以安装</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Mac中，Parallels Desktop安装Ubuntu无法全屏问题出现，是由于在安装ubuntn是没有选择快速安装，因此在安装过程中就没有安装Parallels Tools。因此就会出现比如分辨率问题，或者终端窗口显示不正常等一些问题。解决这个问题方法就是安装Par]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客（二）]]></title>
    <link href="http://geekzph.github.io/2015/10/12/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://geekzph.github.io/2015/10/12/使用Hexo搭建个人博客（二）/</id>
    <published>2015-10-12T13:37:01.000Z</published>
    <updated>2015-10-16T13:11:00.000Z</updated>
    <content type="html"><![CDATA[<p>上篇文章介绍了如何通过Hexo来搭建博客，通过上篇文章相信搭建已经可以一个简单的博客了。但是这还不够，因为默认的博客还比较简陋，还需要进一步的去配置，使其更加完善。</p>
<p>官方提供了很多主题供大家来选择</p>
<ul>
<li>Hexo Themes - <a href="http://hexo.io/themes" target="_blank" rel="external">http://hexo.io/themes</a></li>
<li>NexT - <a href="http://theme-next.iissnan.com" target="_blank" rel="external">http://theme-next.iissnan.com</a></li>
<li>jacman - <a href="https://github.com/wuchong/jacman" target="_blank" rel="external">https://github.com/wuchong/jacman</a></li>
</ul>
<p>本文以Next为例来介绍主题使用方法</p>
<h4 id="下载NexT主题">下载NexT主题</h4><p>两种方法</p>
<ol>
<li><p>在终端窗口下，定位到 Hexo 站点目录下</p>
<p> $ cd your-hexo-site</p>
<p> $ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a>     themes/next</p>
</li>
<li><p>前往 NexT 版本 发布页面，选择你所需要的版本，下载 Download 下的 Source Code (zip) 到本地。解压所下载的压缩包至站点的 themes 目录下，并将 解压后的文件夹名称（hexo-theme-next-0.4.0）更改为 next</p>
</li>
</ol>
<h4 id="启用NexT主题">启用NexT主题</h4><p>克隆/下载 完成后，打开 站点配置文件，找到 theme 字段，并将其值更改为 next。<br>运行 hexo s –debug，并访问 <a href="http://localhost:4000，确保站点正确运行。" target="_blank" rel="external">http://localhost:4000，确保站点正确运行。</a></p>
<h4 id="主题设定">主题设定</h4><ol>
<li><p>语言设置：编辑 站点配置文件，将 language 设置成你所需要的语言。<br>例如选用正体中文，则配置为：</p>
<p> language: zh-hk</p>
</li>
</ol>
<ol>
<li><p>菜单设置：菜单配置在 主题配置文件 的 menu。 若你的站点运行在子目录中，请将链接前缀的 / 去掉。默认支持的菜单项有：</p>
<p> menu:</p>
<p> home: /</p>
<p> archives: /archives</p>
<p> about: /about</p>
<p> categories: /categories</p>
<p> tags: /tags</p>
<p> commonweal: /404.html</p>
</li>
<li><p>侧栏设置：默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示。可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。</p>
</li>
<li>头像设置：编辑 站点配置文件，新增字段 avatar， 值设置成头像的链接地址。</li>
<li>作者名称：编辑 站点配置文件，设置 author 为你的昵称。</li>
<li>站点描述设置：编辑 站点配置文件，设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:)</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>上篇文章介绍了如何通过Hexo来搭建博客，通过上篇文章相信搭建已经可以一个简单的博客了。但是这还不够，因为默认的博客还比较简陋，还需要进一步的去配置，使其更加完善。</p>
<p>官方提供了很多主题供大家来选择</p>
<ul>
<li>Hexo Themes - <a h]]>
    </summary>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-10-30T12:41:10.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《自控力》书摘]]></title>
    <link href="http://yoursite.com/2016/10/26/%E3%80%8A%E8%87%AA%E6%8E%A7%E5%8A%9B%E3%80%8B%E4%B9%A6%E6%91%98/"/>
    <id>http://yoursite.com/2016/10/26/《自控力》书摘/</id>
    <published>2016-10-26T14:55:57.000Z</published>
    <updated>2016-10-30T12:41:10.000Z</updated>
    <content type="html"><![CDATA[<p>1.<br>“说不”属于意志力的一部分，而且是最不可或缺的部分。<br>2.<br>意志力就是要驾驭“我要做”、“我不要”和“我想要”这三种力量。<br>3.<br>自控力比智商高更有助于拿高分，比个人魅力更有助于领导别人，比同理心跟有助于维持婚姻幸福。<br>3.<br>意志力挑战就是两个自我的对抗–自控系统和原始本能。没有自我意识，自控系统将毫无用武之地。更强的自控力就得有更多的自我意识。<br>4.<br>经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你注意集中力、管理压力、克制冲动和认识自我的能力。<br>5.<br>心率变异度成为身体的意志力“储备”，也就是一个衡量自控力的生理学标准。<br>6.<br>将呼吸频率降低到每分钟4-6次，也就是每次呼吸时间用时10-15秒，比平常呼吸慢一点，可以提高心率变异度。<br>7.<br>自控力的良药是锻炼。锻炼能提高心率变异度的基准线。<br>8.<br>改善心情，缓解压力的最有效的锻炼是每次5分钟，而不是每次几个小时。<br>9.<br>长期的睡眠不足让你更容易感受到压力、萌生欲望、受到诱惑。<br>10.<br>自控力就像肌肉一样有极限，意志力的肌肉模式告诉我们，自控力从早上到晚上会逐渐减弱。<br>11.<br>如果你觉得自己没有时间和精力去处理“我想要”做的事情，那就把它安排在你意志力最强的时候做。<br>12.<br>意志力饮食方案：低血糖食品包括瘦肉蛋白，坚果和豆类，粗纤维谷物和麦片，大多数的水果和蔬菜。<br>13.<br>在一些小事上持续自控会提高整体的意志力，改变姿势，戒掉甜食，记录支出情况。<br>14.<br>面对你最大的意志力挑战时，你可以考虑以下动机。如果挑战成功，你将会获得什么，还有谁受益。如果你现在愿意努力做困难的是，那么过一段时间后，这个挑战将会变得容易。<br>15.<br>我们最强的动力并不是我们所想的那样，也不是我们觉得“应该是”的那样。<br>16.<br>“道德许可”不仅会批准我们做坏事，也会让我们错失做善事的机会。<br>17.<br>所有被我们道德化的东西都不可避免地受到“道德许可效应”的影响。<br>18.<br>只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。<br>19.<br>任何让你对自己的美感到满意的事，即便只是想想你做过的善事，都会允许我们做冲动的事。<br>20.<br>当我们从道德的角度思考自己面对的意志力挑战时，我们就失去了自我判断能力，看不到这些挑战有助于我们得到自己想要的东西。<br>21.<br>我们总是把进步当做放松的借口。<br>22.<br>我们把需要做的事当成了自己已经付出的努力，只会给我们错误的满足感。<br>23.<br>记住我们为什么会拒绝诱惑，这是个很有效的办法。<br>24.<br>大脑对能完成目标的可能性感到兴奋，它错把可能性当成真正完成了目标。<br>25.<br>我们想到未来的选择时，就会很容易犯下大错。我们不断期待明天能做出和今天不同的选择，但这种期望是错误的。<br>26.<br>当你要做意志力挑战有关的决定是，注意一下，你脑海中是否闪过了“未来再好好表现”的承诺。<br>27.<br>对未来的乐观主义精神，不仅会影响我们自己的决定，还会影响我们究竟会不会按自己所说的去做。试着减少行为的变化性。<br>28.<br>只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。当光环效应影响到了你的意志力挑战时，你需要找到具体的测量标准。<br>29.<br>在追求自控的过程中，我们不应该把所有的意志力挑战都放在道德标准的框架中。想要做到始终如一，我们就需要认同目标本身，而不是我们做山是时的光环。<br>30.<br>现代科技“及时行乐”的特点，加上原始的激励系统，就让我们成了多巴胺的奴隶，从此欲罢不能。<br>31.<br>当奖励承诺的多巴胺释放时，你更容易受到其他形式的诱惑。<br>32.<br>我们的大脑错把奖励的承诺当成快乐的保证，所以，我们从不可能带来满足的事物中找到满足。<br>33.<br>想得到快乐是一种健康的生存机制。它和远离危险一样，都是人类的本能。<br>34.<br>当我们情绪低落的时，大脑更容易受到诱惑。<br>35.<br>最有效的解压方法包括：锻炼或参加体育活动、祈祷或参加宗教活动、阅读、听音乐、与家人相处、按摩、外出散步、冥想或做瑜伽，以及培养有创意的爱好。真正缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质。<br>36.<br>导致跟多堕落的行为并不是第一次的放弃，而是第一次放弃后产生的羞耻感、罪恶感、失控感和绝望感。责备自己屈于诱惑的时候，往往会带来更多意志力的实效，造成更多的痛苦。<br>37.<br>自我批评会降低积极性和自控力，而且也是最容易导致抑郁的因素。相反，自我同情则会提示积极性和自控力。<br>38.<br>增强责任感的不是罪恶感，而是自我谅解。<br>39.<br>当我们面对罪恶感、焦虑和压力感到备受打击时，我们会想到一件能让自己快乐的事——决定做出改变。不行的是，就像奖励的承诺和缓解压力的承诺一样，改变的承诺也很少能朝我们希望的方向发展。<br>40.<br>当我们和诱惑正面交锋的时候，我们只愿意选择短期的、即时的奖励。即时奖励会激活更古老、更原始的奖励系统，刺激相应的多巴胺产生欲望。未来奖励则不太可能激活这个奖励系统。<br>41.<br>当我们想到未来的自己时，我们的欲望不会像现在一样紧迫，情绪不会像现在一样真切。<br>42.<br>大脑会把未来的自己当成别人，这种习惯对自控力影响极大。<br>43.<br>无意识的模仿，传染情绪和当我们看到别人屈服于诱惑时，我们的大脑也可能受到诱惑。这三种形式都会是我们的社会脑出现意志力实效。<br>44.<br>当我们看到别人忽视规则、受欲望支配的时候，我们更可能在任何冲动面前选择屈服。<br>45.<br>社会传染病在人际网络中传播，那里面都是互相尊重、互相欣赏的人。<br>46.<br>当群体里的其他人都在做某件事时，我们很容易认为这件事是应该做的聪明事情。我们的日常行为受到“社会认同”的巨大影响。<br>47.<br>戒掉恶习并培养新的美德会让我们在自己最重视的群体中站稳脚跟，我们或许会愿意这么做。<br>48.<br>在考虑如何做出选择是，我们经常想象自己是别人评估的对象。这位人们自控提供了强大的精神支持。<br>49.<br>我们的大脑会把别人的目标、信念和行为整合到自己的决策中。我们的行为也影响了其他无数人，我们做的每个选择对别人来说也是一种鼓励或诱惑。<br>50.<br>把我不要的力量用在涉及思想、情感的内心世界，他就会实效。<br>51.<br>当人们视图摆脱一种想法，他却不断回到脑海中时，人们很可能认为他一定是真的。这种认知的偏见似乎已经在人类的大脑中根深蒂固了。人们会根据想起事情的难易程度来判断它的可能性或真实性。<br>52.<br>当人们不再试图控制那些不希望出现的想法和情绪时，他们也就不会再来烦你。<br>53.<br>直面自身欲望，但不要付诸行动。驾驭冲动。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1.<br>“说不”属于意志力的一部分，而且是最不可或缺的部分。<br>2.<br>意志力就是要驾驭“我要做”、“我不要”和“我想要”这三种力量。<br>3.<br>自控力比智商高更有助于拿高分，比个人魅力更有助于领导别人，比同理心跟有助于维持婚姻幸福。<br>3.<br>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ngrok实现内网穿透]]></title>
    <link href="http://yoursite.com/2016/08/18/%E4%BD%BF%E7%94%A8ngrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://yoursite.com/2016/08/18/使用ngrok实现内网穿透/</id>
    <published>2016-08-18T13:52:33.000Z</published>
    <updated>2016-09-18T09:37:18.000Z</updated>
    <content type="html"><![CDATA[<p>在很多时候我需要把内网的东西暴露给外网，但是又没有外网IP。这个时候我们可以借助一些内网穿透工具达到这个目的，例如花生壳之类。但是这些收费的。ngrok是一个开源的内网穿透服务，可以在他的官网注册账号实现内网穿透，但是现在应被墙了。不过我们可以用他的源码在自己的VPS上搭建这个服务。ngrok可以做TCP端口转发，对于Linux可以将其映射到22端口进行SSH连接。Windows的远程桌面可以将其映射到3389端口来实现。同理，如果要做MySQL的远程连接，只需映射3306端口即可。本文详细记录了整个搭建过程。</p>
<h2 id="编译Ngrok">编译Ngrok</h2><p>以Ubuntu 14.04 为例<br>1、安装必备工具</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">sudo</span> apt-<span class="preprocessor">get</span> install <span class="keyword">build-essential </span>mercurial git</span><br></pre></td></tr></table></figure>
<p>2、配置Go环境<br>下载Go源码</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O <span class="string">https:</span><span class="comment">//storage.googleapis.com/golang/go1.6.linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure>
<p>注意：同过apt-get 方式下载的Go可能会由于版本低而导致无法编译</p>
<p>解压源码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tar</span> <span class="tag">xvf</span> <span class="tag">go1</span><span class="class">.6</span><span class="class">.linux-amd64</span><span class="class">.tar</span><span class="class">.gz</span></span><br></pre></td></tr></table></figure>
<p>Go目录的权限改为root，并把它移动到/usr/local目录</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R roo<span class="variable">t:root</span> ./<span class="keyword">go</span></span><br><span class="line">sudo mv <span class="keyword">go</span> /usr/local</span><br></pre></td></tr></table></figure>
<p>配置环境变量，打开.profile 文件</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vi</span> ~/.<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>
<p>在末尾加入下面两行</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=<span class="variable">$HOME</span>/work </span><br><span class="line">export PATH=<span class="variable">$PATH</span>:/usr/local/go/bin:<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>
<p>编译使其生效</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> ~/.<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>
<p>测试Go是否安装成功</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="keyword">version</span></span><br></pre></td></tr></table></figure>
<p>3、编译ngrok源码</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/tutumcloud/ngrok.git ngrok</span><br><span class="line"><span class="keyword">cd</span> ngrok</span><br></pre></td></tr></table></figure>
<p>生成并替换源码里默认的证书，注意域名修改为你自己的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NGROK_DOMAIN=<span class="string">"geekzph.com"</span></span><br><span class="line"></span><br><span class="line">openssl genrsa -out base<span class="class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -new -x509 -nodes -key base<span class="class">.key</span> -days <span class="number">10000</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -out base<span class="class">.pem</span></span><br><span class="line">openssl genrsa -out server<span class="class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -new -key server<span class="class">.key</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -out server<span class="class">.csr</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server<span class="class">.csr</span> -CA base<span class="class">.pem</span> -CAkey base<span class="class">.key</span> -CAcreateserial -days <span class="number">10000</span> -out server<span class="class">.crt</span></span><br><span class="line"></span><br><span class="line">cp base<span class="class">.pem</span> assets/client/tls/ngrokroot.crt</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make GOOS=linux <span class="operator"><span class="keyword">release</span>-<span class="keyword">server</span> <span class="keyword">release</span>-<span class="keyword">client</span></span></span><br></pre></td></tr></table></figure>
<p>如果出现类似下面的错误</p>
<blockquote>
<p>GOOS=”” GOARCH=”” go get github.com/jteeuwen/go-bindata/go-bindata<br>bin/go-bindata -nomemcopy -pkg=assets -tags=debug \<br>-debug=true \<br>-o=src/ngrok/client/assets/assets_debug.go \<br>assets/client/…<br>make: bin/go-bindata：command not found<br>make: <em>*</em> [client-assets] error 127</p>
</blockquote>
<p>则可是<br>1、Go的环境变量没有设置好，需要重新检查环境变量<br>2、编译的时候GOOS没有设置为linux</p>
<p>如果编译成功的话，在ngrok/bin下应该有ngrok、ngrokd 两个可执行文件。</p>
<p>5、启动服务端</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ngrok/</span><br><span class="line">sudo ./bin/ngrokd -tlsKey=server<span class="class">.key</span> -tlsCrt=server<span class="class">.crt</span> -domain=<span class="string">"geekzph.com"</span> -httpAddr=<span class="string">":9090"</span> -httpsAddr=<span class="string">":9092"</span></span><br></pre></td></tr></table></figure>
<p>现在服务端已经运行起来了，ngrokd 会开一个 4443 端口用来跟客户端通讯。</p>
<p>6、配置域名解析<br>我用的DNSPOD的域名解析服务<br><img src="/media/Snip20160918_3.png" alt="Snip20160918_3"><br>把域名泛解析到 VPS 上,记录值为VPS的IP地址。这时候访问geekzph.com，会出现</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tunnel geekzph<span class="class">.com</span>:<span class="number">9091</span> not found</span><br></pre></td></tr></table></figure>
<p>说明一切已经就绪了。</p>
<p>7、客户端<br>由于我们刚才编译的是linux的客户端，如果需要在Windows上使用的话还需要编译一个Windows的客户端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切到go的安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/go/src </span><br><span class="line"><span class="comment">#给Go编译器加上交叉编译windows/amd64程序的功能 </span></span><br><span class="line">GOOS=windows GOARCH=amd64 ./make.bash</span><br></pre></td></tr></table></figure>
<p>开始编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#切回到ngrok目录 </span></span><br><span class="line">cd - </span><br><span class="line"><span class="preprocessor">#执行如下命令编译Windows <span class="number">64</span>位客户端 </span></span><br><span class="line">GOOS=windows GOARCH=amd64 make release-client </span><br><span class="line"><span class="preprocessor">#以上GOARCH=amd64指的是编译为<span class="number">64</span>位版本，如需<span class="number">32</span>位改成GOARCH=<span class="number">386</span>即可</span></span><br></pre></td></tr></table></figure>
<p>Windows客户端ngrok就编译成功了，我们可以在./bin/windows_amd64/目录下找到执行文件ngrok.exe。使用scp命令将其从vps上下载到Windows上。</p>
<p>然后在ngrok目录下新建一个配置文件，例如命名为grok.cfg：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server_addr:</span> gekezph.<span class="string">com:</span><span class="number">4443</span></span><br><span class="line"><span class="string">trust_host_root_certs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>打开命令提示符，切到ngrok.exe所在目录，并执行以下命令。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#启动ngrok客户端</span></span><br><span class="line"><span class="preprocessor">#注意：如果不加参数-subdomain=test，将会随机自动分配子域名。</span></span><br><span class="line"><span class="preprocessor">#</span></span><br><span class="line">ngrok -config=ngrok.cfg -subdomain=test <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>这样就配置成功了！访问。test.geekzph.com就可以看到网站内容了。以上是映射的http服务，还以映射tcp服务，这样就能ssh，远程桌面等功能。</p>
<p>我们以远程桌面为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#这里以远程桌面时的<span class="number">3389</span>端口为例 </span></span><br><span class="line">ngrok -proto=tcp <span class="number">3389</span></span><br></pre></td></tr></table></figure>
<p>之后出现下面提示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#客户端ngrok正常执行显示的内容 </span></span><br><span class="line">ngrok (Ctrl+C to quit) </span><br><span class="line">Tunnel Status online </span><br><span class="line">Version <span class="number">1.7</span>/<span class="number">1.7</span> </span><br><span class="line">Forwarding tcp:<span class="comment">//geekzph.com:98805 -&gt; 127.0.0.1:22 </span></span><br><span class="line">Web Interface <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4040</span> </span><br><span class="line"><span class="preprocessor"># Conn <span class="number">0</span> </span></span><br><span class="line">Avg Conn Time <span class="number">0.00</span>ms</span><br></pre></td></tr></table></figure>
<p>这个时候在远程桌面客户端的地址输入：geekzph.com:98805，就可以连接到位于内网的电脑了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在很多时候我需要把内网的东西暴露给外网，但是又没有外网IP。这个时候我们可以借助一些内网穿透工具达到这个目的，例如花生壳之类。但是这些收费的。ngrok是一个开源的内网穿透服务，可以在他的官网注册账号实现内网穿透，但是现在应被墙了。不过我们可以用他的源码在自己的VPS上搭建]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解快速排序]]></title>
    <link href="http://yoursite.com/2016/08/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2016/08/18/深入理解快速排序/</id>
    <published>2016-08-18T13:29:29.000Z</published>
    <updated>2016-08-18T13:29:30.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建Git服务器]]></title>
    <link href="http://yoursite.com/2016/03/05/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2016/03/05/搭建Git服务器/</id>
    <published>2016-03-05T15:42:53.000Z</published>
    <updated>2016-03-05T15:44:05.000Z</updated>
    <content type="html"><![CDATA[<h4 id="搭建Git服务器">搭建Git服务器</h4><h5 id="服务器端配置">服务器端配置</h5><p>1、安装Git</p>
<pre><code>$ sudo apt-<span class="keyword">get</span> install git
</code></pre><p>2、创建一个git用户，用来运行git服务。通过cd + 空格 转至当前用户目录为home/git。然后创建.ssh文件夹来存储SHH公钥。大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。</p>
<pre><code><span class="variable">$ </span>sudo adduser git
<span class="variable">$ </span>su git
<span class="variable">$ </span>cd
<span class="variable">$ </span>mkdir .ssh
</code></pre><p>3、初始化Git仓库</p>
<pre><code><span class="variable">$ </span>cd /opt/git
<span class="variable">$ </span>mkdir project.git
<span class="variable">$ </span>cd project.git
<span class="variable">$ </span>git --bare init
</code></pre><p>4、owner改为git,此命令在/opt/git下执行</p>
<pre><code>$ sudo chown -R git:git project<span class="class">.git</span>    
</code></pre><p>如果出现下述错误提示，就是因为权限没有修改，执行上述命令即可</p>
<pre><code>remote: <span class="keyword">error</span>: insufficient permission <span class="keyword">for</span> adding an <span class="built_in">object</span> <span class="keyword">to</span> repository database ./objects
remote: fatal: failed <span class="keyword">to</span> write <span class="built_in">object</span>
<span class="keyword">error</span>: unpack failed: unpack-objects abnormal <span class="keyword">exit</span>
</code></pre><p>5、测试本机SSH是否可以正常工作。如果出现connetction refused证明ssh不能使用，需要安装ssh</p>
<pre><code><span class="variable">$ </span>ssh localhost
</code></pre><p> 如果在客户端出现下述错误提示，则很有可能是ssh没有安装，或没有运行：</p>
<pre><code>IOperation timed <span class="keyword">out</span> fatal: Could <span class="keyword">not</span> <span class="keyword">read</span> <span class="keyword">from</span> remote rIepository.
git server Could <span class="keyword">not</span> <span class="keyword">read</span> <span class="keyword">from</span> remote repository.
</code></pre><p>这时候就需要来安装ssh</p>
<pre><code>$ sudo apt-get <span class="operator"><span class="keyword">install</span> openssh-<span class="keyword">server</span></span>
</code></pre><p>然后确认sshserver是否启动了：</p>
<pre><code><span class="keyword">ps</span> -<span class="keyword">e</span> |<span class="keyword">grep</span> ssh
</code></pre><p>如果看到sshd那说明ssh-server已经启动了。<br>如果没有则可以这样启动：</p>
<pre><code>sudo /etc/init.d/ssh <span class="built_in">start</span>
</code></pre><h5 id="客服端配置">客服端配置</h5><p>1、生成ssh公钥<br>Mac和Linux可直接用下面命令生成。</p>
<pre><code><span class="variable">$ </span>ssh-keygen
</code></pre><p>数次回车之后就会在.ssh/id_rsa目录下生成公钥id_dsa.pub，将其复制到服务器上/tmp/id_rsa.pub，最后只要把它写入 authorized_keys 文件。</p>
<pre><code>cat /tmp/id_rsa.pub <span class="prompt">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys
</code></pre><p>2、将本机已有仓库与远程仓库关联</p>
<pre><code><span class="variable">$ </span>mkdir testgit
<span class="variable">$ </span>cd testgit
<span class="variable">$ </span>git init
<span class="variable">$ </span>git add .
<span class="variable">$ </span>git commit -m <span class="string">'initial commit'</span>
<span class="variable">$ </span>git remote add origin git<span class="variable">@ip</span><span class="symbol">:/opt/git/project</span>.git
<span class="variable">$ </span>git push origin master
</code></pre><p>这样就实现了本地仓库与远程仓库的关联。</p>
<p>3、在另一台电脑上可以clone下来</p>
<pre><code><span class="variable">$ </span>git clone git<span class="variable">@ip</span><span class="symbol">:/opt/git/project</span>.git
</code></pre><h6 id="Git_服务器演示">Git 服务器演示</h6><p>1、在Mac端将本地仓库test与服务器端project2仓库关联，test有readme.txt,git服务器的地址为10.211.55.3。</p>
<p><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1ezpzv0gc32j311w0wiajp.jpg" alt="image"></p>
<p>readme.txt的内容为</p>
<p><img src="http://ww3.sinaimg.cn/large/005FcoR8gw1ezpzvuxzxmj313y0t40u8.jpg" alt="image"></p>
<p>2、在Mac客户端克隆仓库到用户目录<br><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1ezpzxnogjvj311w0wijxv.jpg" alt="image"></p>
<p>3、在Windows客服端克隆仓库</p>
<p><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1ezpzyll0fwj30jo0jwwlc.jpg" alt="image"><br>4、改变readme.txt的内容</p>
<p><img src="http://ww3.sinaimg.cn/large/005FcoR8gw1ezpzzf5cc9j313y0t4gnl.jpg" alt="image"></p>
<p>5、分别在Mac端和Windows端克隆</p>
<p><img src="http://ww3.sinaimg.cn/large/005FcoR8gw1ezpzzf5cc9j313y0t4gnl.jpg" alt="image"></p>
<p><img src="http://ww4.sinaimg.cn/large/005FcoR8gw1ezq017oofaj30ja0jowlq.jpg" alt="image"></p>
<h5 id="关于Git整合代码统计的思考">关于Git整合代码统计的思考</h5><p>应该在Git源码中加入监视模块，一旦有新的代码改动push服务器，就会触发器代码统计功能。它会在发生改动的文件夹执行，以此完成此项功能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="搭建Git服务器">搭建Git服务器</h4><h5 id="服务器端配置">服务器端配置</h5><p>1、安装Git</p>
<pre><code>$ sudo apt-<span class="keyword">get</span> install git
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[代码行数统计]]></title>
    <link href="http://yoursite.com/2016/03/05/%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/03/05/代码行数统计/</id>
    <published>2016-03-05T15:40:52.000Z</published>
    <updated>2016-03-05T15:41:41.000Z</updated>
    <content type="html"><![CDATA[<h4 id="一、_代码统计">一、    代码统计</h4><p>设计思想为各个类的方法名用正则表达式来匹配，每个放的行数使用栈来计算，类之间的引用关系使用图存储。通过判断是否存在环来判断是否有循环引用。使用Python实现。</p>
<p>#####1、类SourceCodeANA</p>
<p>方法：ListAllFile()</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">ListAllFile</span><span class="params">()</span>:</span>    <span class="comment">#获取目录下所有的文件名及其路径</span>
    path = os.getcwd()   <span class="comment">#获取当前目录</span>
    file_paths=[]
    new_path = os.path.join(path,<span class="string">'SLRtableProducer'</span>)
    listfile=os.listdir(new_path)  <span class="comment">#列出目录下所有文件</span>
    <span class="keyword">for</span> files <span class="keyword">in</span> listfile:
        file_paths.append(os.path.join(new_path,files))
    <span class="keyword">return</span> listfile,file_paths      <span class="comment">#返回所有文件名lisfile,返回所有文件的路径.</span>
</code></pre><p>此方法的功能为遍历当前目录下多有的文件，返回其文件名和完整路径。</p>
<p>1.2 方法：GetName（）</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">GetName</span><span class="params">()</span>:</span>   <span class="comment">#生成类名字典</span>
    listfile,file_paths = ListAllFile()
    i = <span class="number">0</span>
    class_dict={}
    <span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:
        dotposition=file_path.rfind(<span class="string">'.'</span>)
        extention_name=file_path[dotposition+<span class="number">1</span>:]  <span class="comment">#获取扩展名</span>
        class_name=file_path[file_path.rfind(<span class="string">'/'</span>)+<span class="number">1</span>:]  <span class="comment">#类名,带.h</span>
        <span class="keyword">if</span> extention_name==<span class="string">'h'</span>:
            class_dict[class_name]=i
            newclass_dict[i]=class_name
            i=i+<span class="number">1</span>
    <span class="keyword">return</span> class_dict
</code></pre><p>此方法的功能为为每个类名生成键值对，已方便生成类引用图时表示的方便。返回类似这样的结果：{‘AnalysisTable.h’: 0, ‘global.h’: 1, ‘LexerSupport.h’: 2}</p>
<p>1.3 方法：CountLine(file_path)</p>
<pre><code>def <span class="function"><span class="title">CountLine</span><span class="params">(file_path)</span></span>:  #计算方法行数,利用栈
s=<span class="function"><span class="title">Stack</span><span class="params">()</span></span>
f=<span class="function"><span class="title">open</span><span class="params">(file_path,<span class="string">'r'</span>)</span></span>
i=<span class="number">0</span>
function_line=[]
<span class="keyword">for</span> lines <span class="keyword">in</span> f.<span class="function"><span class="title">readlines</span><span class="params">()</span></span>:
    <span class="keyword">if</span> lines.<span class="function"><span class="title">find</span><span class="params">(<span class="string">'{'</span>)</span></span>!=-<span class="number">1</span>:
        s.<span class="function"><span class="title">push</span><span class="params">(<span class="number">1</span>)</span></span>
        i=<span class="number">0</span>
    <span class="keyword">if</span> lines.<span class="function"><span class="title">find</span><span class="params">(<span class="string">'}'</span>)</span></span>!=-<span class="number">1</span>:
        s.<span class="function"><span class="title">pop</span><span class="params">()</span></span>
        <span class="keyword">if</span> s.<span class="function"><span class="title">isEmpty</span><span class="params">()</span></span>==True:
            function_line.<span class="function"><span class="title">append</span><span class="params">(i)</span></span>
            i=<span class="number">0</span>
    i=i+<span class="number">1</span>
return function_line
</code></pre><p>此方法的作用统计每个方法的行数。每当遇到’{‘时就入栈，每当遇到’}’时就出栈，当栈为空是即为这个方法已经结束。每个从文件读入一行，每次读入累加器就会加1，以此来统计行数。</p>
<p>1.4 方法：ShowReference(file_paths,class_dict)</p>
<pre><code>def <span class="function"><span class="title">ShowReference</span><span class="params">(file_paths,class_dict)</span></span>:  #生成类之间引用关系的图,用邻接矩阵存储
ReturnMat = numpy.<span class="function"><span class="title">zeros</span><span class="params">((<span class="number">21</span>,<span class="number">21</span>)</span></span>)
<span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:
    class_name=file_path[file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'/'</span>)</span></span>+<span class="number">1</span>:]
    extention_name=file_path[file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'.'</span>)</span></span>+<span class="number">1</span>:]  #获取扩展名
    <span class="keyword">if</span> os<span class="class">.path</span><span class="class">.exists</span>(file_path)==True and extention_name==<span class="string">'h'</span>:
        f=<span class="function"><span class="title">open</span><span class="params">(file_path,<span class="string">'r'</span>)</span></span>
        <span class="attribute">content</span>=f.<span class="function"><span class="title">read</span><span class="params">()</span></span>
        result1=re.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'#include "(.*)"'</span>,content)</span></span>
        result2=re.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'#include &lt;(.*)&gt;'</span>,content)</span></span>
        result1.<span class="function"><span class="title">extend</span><span class="params">(result2)</span></span>

        <span class="keyword">for</span> result <span class="keyword">in</span> result1:
            <span class="keyword">if</span> class_dict.<span class="function"><span class="title">has_key</span><span class="params">(class_name)</span></span>==True and class_dict.<span class="function"><span class="title">has_key</span><span class="params">(result)</span></span>==True:
                ReturnMat[class_dict[class_name]][class_dict[result]]=<span class="number">1</span>
return ReturnMat
</code></pre><p>此方法的作用为生成类之间引用关系的有向图,用邻接矩阵存储。</p>
<p>1.5 方法：dfs（）</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,m)</span>:</span>
<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">20</span>):
    <span class="keyword">if</span> dataSet[i][j] == <span class="number">1</span>:

        <span class="keyword">if</span> m!=i:
            <span class="keyword">print</span> <span class="string">'----------------------------------------------------------'</span>
        <span class="keyword">print</span> newclass_dict[i],<span class="string">'-&gt;'</span>,newclass_dict[j]
        dataSet[i][j]=<span class="number">2</span>
        m=j
        dfs(j,m)
</code></pre><p>这个方法是用来遍历类引用关系生成的邻接矩阵，采用了深度优先遍历，以此来得到类之间的引用关系。</p>
<p>1.6 方法：Main（）</p>
<pre><code>def <span class="function"><span class="title">Main</span><span class="params">()</span></span>:
listfile,file_paths=<span class="function"><span class="title">ListAllFile</span><span class="params">()</span></span>
class_count=<span class="number">0</span>      #类的个数
class_name=<span class="string">''</span>      #类名
function_lines=<span class="number">0</span>   #方法行数
reclass=[]         #类中所引用的类

<span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:  #遍历所有文件
    isCycle=<span class="string">'否'</span>      #是否存在循环引用
    reclass=[]       #引用类list
    dotposition=file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'.'</span>)</span></span>
    extention_name=file_path[dotposition+<span class="number">1</span>:]  #获取扩展名
    <span class="keyword">if</span> extention_name==<span class="string">'h'</span>:  #利用.h文件计算方法个数
        class_count=class_count+<span class="number">1</span>  #类的个数
        class_name=file_path[file_path.<span class="function"><span class="title">rfind</span><span class="params">(<span class="string">'/'</span>)</span></span>+<span class="number">1</span>:dotposition]  #类名,不带<span class="class">.h</span>
        class_name_h=class_name+<span class="string">'.h'</span>   #类名,带<span class="class">.h</span>
        cppfile_path=file_path[:dotposition]+<span class="string">'.cpp'</span>    #.cpp文件路径

        <span class="keyword">if</span> os<span class="class">.path</span><span class="class">.exists</span>(cppfile_path)==True:    #通过cpp计算方法行数
            function_lines=<span class="function"><span class="title">CountLine</span><span class="params">(cppfile_path)</span></span>
        <span class="keyword">else</span>:
            function_lines=<span class="number">0</span>

        #打开.h文件,统计方法
        f=<span class="function"><span class="title">open</span><span class="params">(file_path,<span class="string">'r'</span>)</span></span>
        <span class="attribute">content</span>=f.<span class="function"><span class="title">read</span><span class="params">()</span></span>
        reresult=re.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'(\w*)\((.*?)\);| (\w*)\((.*?)\)\s*\{'</span>,content)</span></span>
        function_count=<span class="function"><span class="title">len</span><span class="params">(reresult)</span></span>
        <span class="keyword">for</span> name <span class="keyword">in</span> reresult:  #方法名加入list
            <span class="keyword">if</span> name[<span class="number">0</span>]!=<span class="string">''</span>:
                function_name.<span class="function"><span class="title">append</span><span class="params">(name[<span class="number">0</span>])</span></span>

        print <span class="string">'类名为:'</span>,class_name
        print <span class="string">'方法个数为:'</span>,function_count
        <span class="keyword">if</span> function_count!=<span class="number">0</span> and function_lines!=<span class="number">0</span>:
            print <span class="function"><span class="title">sorted</span><span class="params">(function_lines)</span></span>
            print <span class="string">'最长的方法有:'</span>,<span class="function"><span class="title">sorted</span><span class="params">(function_lines)</span></span>[<span class="number">0</span>],<span class="string">'行'</span>
            print <span class="string">'最短的方法有:'</span>,<span class="function"><span class="title">sorted</span><span class="params">(function_lines)</span></span>[<span class="function"><span class="title">len</span><span class="params">(function_lines)</span></span>-<span class="number">1</span>],<span class="string">'行'</span>
            print <span class="string">'引用的类有:'</span>,reclass
            print <span class="string">'是否存在循环引用:'</span>,isCycle
            print <span class="string">'------------------------------'</span>
        <span class="keyword">else</span>:
            print <span class="string">'------------------------------'</span>
</code></pre><p>此函数为主函数，主要为获取各个函数名，以及输出最后的结果。</p>
<p>#####2、类Stack</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span>
<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,size = <span class="number">16</span>)</span>:</span>
    self.stack = []
    self.size = size
    self.top = -<span class="number">1</span>
<span class="function"><span class="keyword">def</span> <span class="title">setSize</span><span class="params">(self, size)</span>:</span>
    self.size = size
<span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.top == -<span class="number">1</span>:
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="keyword">False</span>
<span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.top +<span class="number">1</span> == self.size:
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">else</span>:
        <span class="keyword">return</span> <span class="keyword">False</span>
<span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.isEmpty():
        <span class="keyword">raise</span> Exception(<span class="string">"StackIsEmpty"</span>)
    <span class="keyword">else</span>:
        <span class="keyword">return</span> self.stack[self.top]
<span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,obj)</span>:</span>
    <span class="keyword">if</span> self.isFull():
        <span class="keyword">raise</span> Exception(<span class="string">"StackOverFlow"</span>)
    <span class="keyword">else</span>:
        self.stack.append(obj)
        self.top +=<span class="number">1</span>
<span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.isEmpty():
        <span class="keyword">raise</span> Exception(<span class="string">"StackIsEmpty"</span>)
    <span class="keyword">else</span>:
        self.top -= <span class="number">1</span>
        <span class="keyword">return</span> self.stack.pop()
<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span>
    print(self.stack)
</code></pre><p>这个类实现了栈这种数据结构，用来统计代码行数。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="一、_代码统计">一、    代码统计</h4><p>设计思想为各个类的方法名用正则表达式来匹配，每个放的行数使用栈来计算，类之间的引用关系使用图存储。通过判断是否存在环来判断是否有循环引用。使用Python实现。</p>
<p>#####1、类SourceCod]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[经济学人词频统计]]></title>
    <link href="http://yoursite.com/2015/12/15/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%BA%BA%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"/>
    <id>http://yoursite.com/2015/12/15/经济学人词频统计/</id>
    <published>2015-12-15T06:55:39.000Z</published>
    <updated>2015-12-15T06:55:39.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用Python提取心跳节律信息]]></title>
    <link href="http://yoursite.com/2015/12/15/%E5%88%A9%E7%94%A8Python%E6%8F%90%E5%8F%96%E5%BF%83%E8%B7%B3%E8%8A%82%E5%BE%8B%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2015/12/15/利用Python提取心跳节律信息/</id>
    <published>2015-12-15T06:13:42.000Z</published>
    <updated>2015-12-15T06:36:20.000Z</updated>
    <content type="html"><![CDATA[<h4 id="心跳信息的提取分析：">心跳信息的提取分析：</h4><p>首先，ECG_signal.mat文件包含两组信息ECG_1和Time_Adjusted。其中ECG_1中存储的信息为心跳的数值，可以观察到大部分数值为负数。而波峰均为整数，可以通过计算两个相邻波峰之间的实际来得到周期，从而计算出心跳的次数。</p>
<h4 id="具体实现过程：">具体实现过程：</h4><p>使用Pyhton第三方库scipy中的loadmat来加载mat文件，格式为字典，因为此文件包含两个量，所以就有两个键。以正负变化的点作为分割点对ECG_1进行划分，把正负改变点放在list中。计算list中每两个相邻索引之间最大值的下标，这些小标就是心跳图形波峰的下标。利用这些下标在Time_Adjusted中得到波峰的采样时间点，两个波峰之间的时间差就是一个周期的实际，把计算出的每个周期时间相加再除以个数，就获得了平均周期时间。所以一分钟心跳次数=60/周期</p>
<h4 id="Python代码">Python代码</h4><pre><code><span class="comment"># -*- coding: UTF-8 –*-</span>
<span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt
data = sio.loadmat(<span class="string">'ECG_signal.mat'</span>)   <span class="comment"># 加载mat文件</span>
mylist=[]                     <span class="comment"># 存储正负改变点的索引</span>
ecg=data[<span class="string">'ECG_1'</span>]             <span class="comment"># ecg为numpy.ndarray型</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(ecg)-<span class="number">1</span>,<span class="number">1</span>):
    <span class="keyword">if</span> (ecg[i]&lt;<span class="number">0</span> <span class="keyword">and</span> ecg[i+<span class="number">1</span>]&gt;=<span class="number">0</span>) <span class="keyword">or</span> (ecg[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> ecg[i+<span class="number">1</span>]&lt;<span class="number">0</span>):
        mylist.append(i)

maxindex=[]                   <span class="comment"># 最大值的索引</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(mylist),<span class="number">2</span>):
    maxindex.append(mylist[i]+ecg[mylist[i]:mylist[i+<span class="number">1</span>]].argmax())

period = []                            <span class="comment"># 分别存储各个周期</span>
time_adjusted=data[<span class="string">'Time_Adjusted'</span>][<span class="number">0</span>] <span class="comment"># 取第0行的数据</span>
count = <span class="number">0</span>                              <span class="comment"># 周期个数</span>
<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(maxindex)-<span class="number">1</span>,<span class="number">1</span>):
    period.append(time_adjusted[maxindex[i+<span class="number">1</span>]]-time_adjusted[maxindex[i]]) <span class="comment"># 各个周期加入list中</span>
count = count + <span class="number">1</span>

<span class="keyword">print</span> <span class="string">'原始数据的周期个数:'</span>,count
total_time=<span class="number">0</span>
<span class="keyword">for</span> i <span class="keyword">in</span> period:
    total_time= total_time+i
<span class="keyword">print</span> <span class="string">'原始数据的周期为:'</span>,total_time/count
<span class="keyword">print</span> ‘一分钟的心跳次数为:<span class="string">',60/(total_time/count)</span>
</code></pre><h4 id="运行结果：">运行结果：</h4><p>原始数据的周期个数: 24</p>
<p>原始数据的周期为: 0.813541666667</p>
<p>一分钟的心跳次数为: 73.7516005122</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="心跳信息的提取分析：">心跳信息的提取分析：</h4><p>首先，ECG_signal.mat文件包含两组信息ECG_1和Time_Adjusted。其中ECG_1中存储的信息为心跳的数值，可以观察到大部分数值为负数。而波峰均为整数，可以通过计算两个相邻波峰之间的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下Java环境变量的配置]]></title>
    <link href="http://yoursite.com/2015/12/08/Linux%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2015/12/08/Linux下Java环境变量的配置/</id>
    <published>2015-12-08T06:19:19.000Z</published>
    <updated>2015-12-08T06:19:19.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python爬虫爬取动态网页]]></title>
    <link href="http://yoursite.com/2015/12/08/Python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2015/12/08/Python爬虫爬取动态网页/</id>
    <published>2015-12-08T06:17:43.000Z</published>
    <updated>2015-12-15T06:26:49.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[《与时间做朋友》读书笔记]]></title>
    <link href="http://yoursite.com/2015/12/08/%E3%80%8A%E4%B8%8E%E6%97%B6%E9%97%B4%E5%81%9A%E6%9C%8B%E5%8F%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/12/08/《与时间做朋友》读书笔记/</id>
    <published>2015-12-08T06:17:03.000Z</published>
    <updated>2015-12-08T06:17:03.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Matlab实现基于内容的图像检索系统]]></title>
    <link href="http://yoursite.com/2015/12/06/Matlab%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E5%9B%BE%E5%83%8F%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2015/12/06/Matlab实现基于内容的图像检索系统/</id>
    <published>2015-12-06T13:39:21.000Z</published>
    <updated>2015-12-14T13:47:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、_检索方案">一、 检索方案</h3><p>常见的图像特征有:颜色、纹理、形状、空间关系。<br>此次检索的物体为汽车,汽车有比较明显的颜色特征,而在纹理特征方面也与其他物体也有一定的区别,因此本次实验选取了颜色和纹理做为两个检索特征。颜色特征是通 过颜色矩的方式来进行提取,颜色矩是一种简单有效的颜 色特征表示方法,有一阶矩(均值,mean)、二阶矩(方 差,viarance)和三阶矩(斜度,skewness)等,由于颜色信息 主要分布于低阶矩中,所以用一阶矩,二阶矩和三阶矩足 以表达图像的颜色分布,颜色矩已证明可有效地表示图像中的颜色分布。纹理特征是通过LBP方法来进行提取。LBP 是一种用来描述图像局部纹理特征的算法;它的作用是进行特征提取,提取图像的局部纹理特征。原始的LBP算法定义为在 3 <em> 3的窗口内,以窗口中心像素为阈值,将相邻的8个像素的灰度值与其进行比较,若周围像素值大于中 心像素值,则该像素点的位置被标记为 1,否则为0。3 </em> 3领域内的8个点可产生 8bit 的无符号数,即得到该窗口的 LBP 值,并用这个值来反映该区域的纹理信息。</p>
<h3 id="二、_实现方法">二、 实现方法</h3><p>共有100张图片,其中50张为汽车,另外50张为其他背景图片。首先要做的就是对这 100张图片建索引, 对这些图片分别提取纹理特征和颜色矩特征,并存mat文件。之后就可以进行检索了。纹理特征和颜色矩特征都是一维向量,检索的时候分别计算待检索图像和mat文件中颜色矩和纹理特征向量的欧几里得距离,并给予不同的权值。对这些距离进行升序排序,这样就得到了图像检索结果。</p>
<h3 id="三、_运行结果">三、 运行结果</h3><p><img src="http://ww2.sinaimg.cn/large/005FcoR8gw1eyziseb8n9j310e0kadkw.jpg" alt=""></p>
<p><a href="https://github.com/geekzph/CBIR" target="_blank" rel="external">https://github.com/geekzph/CBIR</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、_检索方案">一、 检索方案</h3><p>常见的图像特征有:颜色、纹理、形状、空间关系。<br>此次检索的物体为汽车,汽车有比较明显的颜色特征,而在纹理特征方面也与其他物体也有一定的区别,因此本次实验选取了颜色和纹理做为两个检索特征。颜色特征是通 过颜色矩的]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Matlab实现JPEG压缩]]></title>
    <link href="http://yoursite.com/2015/12/06/%E4%BD%BF%E7%94%A8Matlab%E5%AE%9E%E7%8E%B0JPEG%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2015/12/06/使用Matlab实现JPEG压缩/</id>
    <published>2015-12-06T13:07:50.000Z</published>
    <updated>2015-12-14T14:07:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="一、_图像压缩原理">一、 图像压缩原理</h3><p>图像分成 8*8 小块 –&gt; DCT 变换 –&gt;用量化表对其量化 –&gt;编码生成压缩数据</p>
<h3 id="二、_具体压缩过程">二、 具体压缩过程</h3><ul>
<li>1、将原始图像分为 8 * 8 的小块, 每个 block 里有 64 个像素。</li>
</ul>
<ul>
<li><p>2、 将图像中每个 8 <em> 8 的 block 进行 DCT 变换。8 </em> 8 的图象经过 DCT 变换后,其低频分量都集中在左上角,高频分量分布在右下角。由于该低频分量包含了图象的主要信息(如亮度),而高频与之相比,就不那么重要了,所以我们可以忽略高频分量。</p>
</li>
<li><p>3、 利用量化表抑制高频变量。量化操作,就是将某一个值除以量化表中对应的值。由 于量化表左上角的值较小,右上角的值较大,这样就起到了保持低频分量,抑制高 频分量的目的。压缩时候将彩色图像的颜色空间由 RGB 转化为 YUV 格式。其中 Y 分量代表了亮度信息,UV 分量代表了色差信息。相比而言,Y 分量更重要一些。 我们可以对 Y 采用细量化,对 UV 采用粗量化,可进一步提高压缩比。所以量化表 通常有两张,一张是针对 Y 的标准亮度量化表;一张是针对 UV 的标准色彩量化表。</p>
</li>
</ul>
<ul>
<li>4、 经过量化之后右下角大部分数据变成了 0,左上角为非零数据。这时使用 Z 字型(如 图所示)的顺序来重新排列数据生成一个整数数组,这样 0 就位于数组都后端。找到数组最后一个非零元素,将其后的数据都舍弃,并加上结束标志。</li>
</ul>
<h3 id="三、_关键代码">三、 关键代码</h3><h4 id="Compress-m">Compress.m</h4><pre><code>function [comp_image_Y,comp_image_U,comp_image_V] = Compress(orig_image)
RGB=orig_image<span class="comment">;</span>
%下面是对 RGB 三个分量进行分离 
R=RGB(:,:,1)<span class="comment">;</span>
G=RGB(:,:,2)<span class="comment">;</span>
B=RGB(:,:,3)<span class="comment">;</span>
%RGB-&gt;YUV Y=0.299*double(R)+0.587*double(G)    +0.114*double(B)<span class="comment">; </span>
[xm, xn] = size(Y)<span class="comment">;             </span>
U=-0.169*double(R)-0.3316*double(G)+0.5*double(B)<span class="comment">;     V=0.5*double(R)-0.4186*double(G)-0.0813*double(B);</span>
%产生一个 8*8 的 DCT 变换举证 
T=dctmtx(8)<span class="comment">;</span>
%进行 DCT 变换 BY BU BV 是 double 类型
BY=blkproc(Y,[8 8],'P1*x*P2',T,T')<span class="comment">; </span>
BU=blkproc(U,[8 8],'P1*x*P2',T,T')<span class="comment">; </span>
BV=blkproc(V,[8 8],'P1*x*P2',T,T')<span class="comment">;     %低频分量量化表</span>
a=[
<span class="number">16 11 10 16</span> <span class="number">24 40 51 61</span><span class="comment">;</span>
<span class="number">12 12 14 19</span> <span class="number">26 58 60 55</span><span class="comment">;</span>
<span class="number">14 13 16 24</span> <span class="number">40 57 69 55</span><span class="comment">;</span>
<span class="number">14 17 22 29</span> <span class="number">51 87 80 62</span><span class="comment">;</span>
<span class="number">18 22 37 56</span> <span class="number">68 109 103 77</span><span class="comment">; </span>
<span class="number">24 35 55 64</span> <span class="number">81 104 113 92</span><span class="comment">;                         </span>
49     <span class="number">64 78 87 103</span> <span class="number">121 120 101</span><span class="comment">;                     </span>
<span class="number">72 92 95 98</span> <span class="number">112 100 103 99</span><span class="comment">;</span>
]<span class="comment">; %高频分量量化表</span>
b=[<span class="number">17 18 24 47</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">18 21 26 66</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">24 26 56 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">47 66 99 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">; </span>
<span class="number">99 99 99 99</span> 99     99 99 99<span class="comment">; </span>
<span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;];</span>
%使用量化表对三个分量进行量化 
BY2=blkproc(BY,[8 8],'round(x./P1)',a)<span class="comment">; </span>
BU2=blkproc(BU,[8 8],'round(x./    P1)',b)<span class="comment">; </span>
BV2=blkproc(BV,[8 8],'round(x./P1)',b)<span class="comment">;</span>
%调用压缩函数 
comp_image_Y=img2jpg(BY2,1)<span class="comment">;         </span>
comp_image_U=img2jpg(BU2,2)<span class="comment">;                     </span>
comp_image_V=img2jpg(BV2,3)<span class="comment">;</span>
</code></pre><h4 id="img2jpg-m">img2jpg.m</h4><pre><code><span class="function"><span class="keyword">function</span> <span class="params">[ y ]</span> = <span class="title">img2jpg</span><span class="params">( x,flag )</span></span>
<span class="matrix">[xm, xn]</span> = <span class="built_in">size</span>(x);
<span class="comment">%z字型读取数据顺序表</span>
order = <span class="matrix">[<span class="number">1</span> <span class="number">9</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">10</span> <span class="number">17</span> <span class="number">25</span> <span class="number">18</span> <span class="number">11</span> <span class="number">4</span>  <span class="number">5</span>  <span class="number">12</span> <span class="number">19</span> <span class="number">26</span> <span class="number">33</span>  ...
    <span class="number">41</span> <span class="number">34</span> <span class="number">27</span> <span class="number">20</span> <span class="number">13</span> <span class="number">6</span>  <span class="number">7</span>  <span class="number">14</span> <span class="number">21</span> <span class="number">28</span> <span class="number">35</span> <span class="number">42</span> <span class="number">49</span> <span class="number">57</span> <span class="number">50</span>  ...
    <span class="number">43</span> <span class="number">36</span> <span class="number">29</span> <span class="number">22</span> <span class="number">15</span> <span class="number">8</span>  <span class="number">16</span> <span class="number">23</span> <span class="number">30</span> <span class="number">37</span> <span class="number">44</span> <span class="number">51</span> <span class="number">58</span> <span class="number">59</span> <span class="number">52</span>  ...
    <span class="number">45</span> <span class="number">38</span> <span class="number">31</span> <span class="number">24</span> <span class="number">32</span> <span class="number">39</span> <span class="number">46</span> <span class="number">53</span> <span class="number">60</span> <span class="number">61</span> <span class="number">54</span> <span class="number">47</span> <span class="number">40</span> <span class="number">48</span> <span class="number">55</span>  ...
    <span class="number">62</span> <span class="number">63</span> <span class="number">56</span> <span class="number">64</span>]</span>;

y = im2col(x, <span class="matrix">[<span class="number">8</span> <span class="number">8</span>]</span>, <span class="string">'distinct'</span>);  <span class="comment">% 将8x8 的块转化为列</span>
xb = <span class="built_in">size</span>(y, <span class="number">2</span>);                   <span class="comment">% 分块数</span>
y = y(order, :);                   <span class="comment">% 按照order的顺序排列数据</span>

eob = max(y(:)) + <span class="number">1</span>;               <span class="comment">% 设置块尾结束标志</span>
r = <span class="built_in">zeros</span>(<span class="built_in">numel</span>(y) + <span class="built_in">size</span>(y, <span class="number">2</span>), <span class="number">1</span>);
count = <span class="number">0</span>;
<span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:xb                       <span class="comment">% 每次处理一个块</span>
    <span class="built_in">i</span> = max(<span class="built_in">find</span>(y(:, <span class="built_in">j</span>)));         <span class="comment">% 找到最后一个非零元素</span>
    <span class="keyword">if</span> <span class="built_in">isempty</span>(<span class="built_in">i</span>)                   
          <span class="built_in">i</span> = <span class="number">0</span>;
    <span class="keyword">end</span>
    p = count + <span class="number">1</span>;
    q = p + <span class="built_in">i</span>;
    r(p:q) = <span class="matrix">[y(<span class="number">1</span>:i, j); eob]</span>;      <span class="comment">% 加入块结束标志</span>
    count = count + <span class="built_in">i</span> + <span class="number">1</span>;          <span class="comment">% 计数</span>
<span class="keyword">end</span>

r((count + <span class="number">1</span>):<span class="keyword">end</span>) = <span class="matrix">[]</span>;           <span class="comment">% 删除r 中不需要的元素</span>
<span class="matrix">[r1,r2]</span>=<span class="built_in">size</span>(r);
y           = struct;
y.realsize = r1;
y.<span class="built_in">size</span>      = uint16(<span class="matrix">[xm xn]</span>);
y.numblocks = uint16(xb);
y.r   = r;
y.flag = flag;

<span class="keyword">end</span>
</code></pre><h4 id="jpg2img">jpg2img</h4><pre><code>function [ x ] = jpg2img( y )
%低频分量量化表   
a=[
<span class="number">16 11 10 16</span> <span class="number">24 40 51 61</span><span class="comment">;  </span>
<span class="number">12 12 14 19</span> <span class="number">26 58 60 55</span><span class="comment">;  </span>
<span class="number">14 13 16 24</span> <span class="number">40 57 69 55</span><span class="comment">;  </span>
<span class="number">14 17 22 29</span> <span class="number">51 87 80 62</span><span class="comment">;  </span>
<span class="number">18 22 37 56</span> <span class="number">68 109 103 77</span><span class="comment">;  </span>
<span class="number">24 35 55 64</span> <span class="number">81 104 113 92</span><span class="comment">;  </span>
<span class="number">49 64 78 87</span> <span class="number">103 121 120 101</span><span class="comment">;  </span>
<span class="number">72 92 95 98</span> <span class="number">112 100 103 99</span><span class="comment">;</span>

]<span class="comment">;  </span>
%高频分量量化表    
b=[<span class="number">17 18 24 47</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">18 21 26 66</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">24 26 56 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">47 66 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;  </span>
 <span class="number">99 99 99 99</span> <span class="number">99 99 99 99</span><span class="comment">;]; </span>

order = [1 9  2  3  <span class="number">10 17 25 18</span> 11 4  5  <span class="number">12 19 26 33</span>  ...
    <span class="number">41 34 27 20</span> 13 6  7  <span class="number">14 21 28 35</span> <span class="number">42 49 57 50</span>  ...
    <span class="number">43 36 29 22</span> 15 8  <span class="number">16 23 30 37</span> <span class="number">44 51 58 59</span> 52  ...
    <span class="number">45 38 31 24</span> <span class="number">32 39 46 53</span> <span class="number">60 61 54 47</span> 40 48 55  ...
    <span class="number">62 63 56 64</span>]<span class="comment">;</span>
rev = order<span class="comment">;                          % 计算反序</span>
for k = 1:length(order)
    rev(k) = find(order == k)<span class="comment">;</span>
end

xb = double(y.numblocks)<span class="comment">;             % 块的个数</span>
sz = double(y.size)<span class="comment">;</span>
xn = sz(2)<span class="comment">;                           % 列数</span>
xm = sz(1)<span class="comment">;                           % 行数</span>
x = y.r<span class="comment">;                              % 压缩后的数据</span>
eob = max(x(:))<span class="comment">;                      % 返回块尾标志</span>

z = zeros(64, xb)<span class="comment">;   k = 1;           % 生成 64 * xb 的零矩阵</span>
for j = 1:xb                          % x中的值放入z中，如果遇到eob就转入下一列
    for i = 1:64                       
          if x(k) == eob                  
             k = k + 1<span class="comment">;   </span>
             break<span class="comment">;          </span>
          else
             z(i, j) = x(k)<span class="comment">;</span>
             k = k + 1<span class="comment">;</span>
          end
    end
end
T=dctmtx(8)<span class="comment">;                                   %产生一个8*8的DCT变换举证  </span>
z = z(rev, :)<span class="comment">;                                 % 按order恢复之前排列</span>
x = col2im(z, [8 8], [xm xn], 'distinct')<span class="comment">;     % 生成矩阵</span>
if y.flag==1
    x = blkproc(x, [8 8], 'x .* P1', a)<span class="comment">;       % 反量化，乘量化表的值</span>
else
    x = blkproc(x, [8 8], 'x .* P1', b)<span class="comment">;</span>
end
x = blkproc(x, [8 8], 'P1 * x * P2', T', T)<span class="comment">;   % 反DCT变换</span>
end
</code></pre><h4 id="Decompress-m">Decompress.m</h4><pre><code>function reco_image = Decompress(orig_image_Y,orig_image_U,orig_image_V) %解压缩
YI=jpg2img(orig_image_Y)<span class="comment">;</span>
UI=jpg2img(orig_image_U)<span class="comment">;</span>
VI=jpg2img(orig_image_V)<span class="comment">;</span>
%YUV 转为 RGB
RI=YI-0.001*UI+1.402*VI<span class="comment">; </span>
GI=YI-0.344*UI-0.714*VI<span class="comment">; </span>
BI=YI+1.772*UI+0.001*VI<span class="comment">;</span>
%经过 DCT 变换和量化后的 YUV 图像 
RGBI=cat(3,RI,GI,BI)<span class="comment">;</span>
RGBI=uint8(RGBI)<span class="comment">;</span>
reco_image = RGBI<span class="comment">;</span>
</code></pre><h4 id="运行结果">运行结果</h4><p><img src="http://ww4.sinaimg.cn/large/005FcoR8jw1eys83bfllhj30fk0bojs7.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005FcoR8jw1eys82m17wfj30fk0bo755.jpg" alt=""></p>
<p><a href="https://github.com/geekzph/JPEGCompression" target="_blank" rel="external">https://github.com/geekzph/JPEGCompression</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、_图像压缩原理">一、 图像压缩原理</h3><p>图像分成 8*8 小块 –&gt; DCT 变换 –&gt;用量化表对其量化 –&gt;编码生成压缩数据</p>
<h3 id="二、_具体压缩过程">二、 具体压缩过程</h3><ul>
<li>1、将原始]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python读取mat文件]]></title>
    <link href="http://yoursite.com/2015/10/22/Python%E8%AF%BB%E5%8F%96mat%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2015/10/22/Python读取mat文件/</id>
    <published>2015-10-22T08:09:53.000Z</published>
    <updated>2015-10-25T10:01:20.000Z</updated>
    <content type="html"><![CDATA[<h4 id="读取mat文件">读取mat文件</h4><p>mat数据格式是Matlab的数据存储的标准格式。在Matlab中主要使用load()函数导入一个mat文件，使用save()函数保存一个mat文件。在Python中处理mat文件，需要导入scipy库，它的load函数可以加载mat文件。读取进来的数据是字典格式。</p>
<pre><code><span class="import"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span>
<span class="typedef"><span class="keyword">data</span> = sio.loadmat<span class="container">('<span class="type">ECG_signal</span>.<span class="title">mat'</span>)</span>   # 加载mat文件</span>
<span class="title">print</span> <span class="typedef"><span class="keyword">type</span><span class="container">(<span class="title">data</span>)</span>                       #查看数据格式</span>
</code></pre><p>我的mat文件中有两个量，一个是ECG_1，另一个是Time_Adjusted，可以用print显示出来</p>
<pre><code>#加载后的文件为字典,打印数据
<span class="function"><span class="title">print</span><span class="params">(<span class="string">'\nThe vaulue of Time_Adjusted:'</span>)</span></span>
<span class="function"><span class="title">print</span><span class="params">(data[<span class="string">'Time_Adjusted'</span>])</span></span>
<span class="function"><span class="title">print</span><span class="params">(<span class="string">'\nThe vaulue of ECG:'</span>)</span><span class="title">r</span></span>
<span class="function"><span class="title">print</span><span class="params">(data[<span class="string">'ECG_1'</span>])</span></span>
</code></pre><p>还可以用matplotlib库，绘制图形。</p>
<pre><code>#绘图
plt.<span class="function"><span class="title">figure</span><span class="params">(<span class="number">1</span>)</span></span>
plt.<span class="function"><span class="title">plot</span><span class="params">(data[<span class="string">'ECG_1'</span>])</span></span>
plt.<span class="function"><span class="title">figure</span><span class="params">(<span class="number">2</span>)</span></span>
plt.<span class="function"><span class="title">plot</span><span class="params">(data[<span class="string">'Time_Adjusted'</span>])</span></span>
plt.<span class="function"><span class="title">show</span><span class="params">()</span></span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="读取mat文件">读取mat文件</h4><p>mat数据格式是Matlab的数据存储的标准格式。在Matlab中主要使用load()函数导入一个mat文件，使用save()函数保存一个mat文件。在Python中处理mat文件，需要导入scipy库，它的load]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu下安装软件方法总结]]></title>
    <link href="http://yoursite.com/2015/10/16/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2015/10/16/Ubuntu下安装软件方法总结/</id>
    <published>2015-10-16T13:31:07.000Z</published>
    <updated>2015-10-19T10:26:48.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>sudo apt-get install packagename 命令<br>apt-get是ubuntu下一个强大的命令行工具。可以用它来安装新的软件包，升级现有的软件包，升级列表索引，甚至升级整个系统。如果出现could not get lock /var/lib/dpkg/lock -open等 ，类似这样的提示，是因为有另外一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因，可能是上次安装时没正常完成，而导致出现此状况。输入下面命令就行了。</p>
<p> sudo rm /var/cache/apt/archives/lock</p>
<p> sudo rm /var/lib/dpkg/lock</p>
</li>
<li>deb格式文件是Ubuntu可安装类型，可以通过双击来直接安装。也可以使用dkpg命令来安装：dpkg -i xxx.deb ，参数i表示可安装的意思</li>
<li>rpm格式是Red Hat Package Manager的简称。在Ubuntu不能通过双击来安装。一般使用alien命令把rpm转换为deb格式后在安装。首先要安装alien命令：sudo apt-get install alien ，然后用alien来转换：sudo alien xxx.rpm 之后会在同文件夹生成同名的deb文件，然后就可以安装了</li>
<li>tar.gz和tar.bz2格式文件的安装。一般需要先解压：tar -zxvf FileName.tar.gz ，然后根据解压后的情况来安装。如果是源码的话，在解压后文件夹里会有confiure文件，源码文件的安装，首先执行：./configure  来进行配置，然后执行make来进行编译，最后执行make install 安装。make uninstall 来进行卸载。或者在配置时指定软件将要安装到目标路径：./configure –prefix=目录名，这样可以使用“rm -rf 软件目录名”命令来进行干净彻底的卸载。</li>
<li>run格式文件的安装。首先执行 chmod +x xxx.run来增加执行权限，然后执行sudo ./xxx.run就可以安装了</li>
<li><p>sh 格式文件。直接 ./xxx.sh 来进行安装。如果遇到这样情况</p>
<p> Configuring the installer…<br> Searching for JVM on the system…<br> Extracting installation data…<br> Installer file /home/jiangkai/netbeans-7.2.1-ml-linux.sh seems to be corrupted<br>很可能是下载文件不完整，建议重新下载在安装。</p>
</li>
</ol>
<p>常用的apt命令</p>
<pre><code>apt-<span class="operator"><span class="keyword">cache</span> <span class="keyword">search</span> <span class="keyword">package</span> 搜索包
apt-<span class="keyword">cache</span> <span class="keyword">show</span> <span class="keyword">package</span> 获取包的相关信息，如说明、大小、版本等
sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> <span class="keyword">package</span> 安装包
sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> <span class="keyword">package</span> - - reinstall 重新安装包
sudo apt-<span class="keyword">get</span> -<span class="keyword">f</span> <span class="keyword">install</span> 修复安装<span class="string">"-f = - -fix-missing"</span>
sudo apt-<span class="keyword">get</span> remove <span class="keyword">package</span> 删除包
sudo apt-<span class="keyword">get</span> remove <span class="keyword">package</span> - - <span class="keyword">purge</span> 删除包，包括删除配置文件等
sudo apt-<span class="keyword">get</span> <span class="keyword">update</span> 更新源
sudo apt-<span class="keyword">get</span> <span class="keyword">upgrade</span> 更新已安装的包
sudo apt-<span class="keyword">get</span> dist-<span class="keyword">upgrade</span> 升级系统
sudo apt-<span class="keyword">get</span> dselect-<span class="keyword">upgrade</span> 使用 dselect 升级
apt-<span class="keyword">cache</span> depends <span class="keyword">package</span> 了解使用依赖
apt-<span class="keyword">cache</span> rdepends <span class="keyword">package</span> 是查看该包被哪些包依赖
sudo apt-<span class="keyword">get</span> <span class="keyword">build</span>-dep <span class="keyword">package</span> 安装相关的编译环境
apt-<span class="keyword">get</span> <span class="keyword">source</span> <span class="keyword">package</span> 下载该包的源代码
sudo apt-<span class="keyword">get</span> clean &amp;&amp; sudo apt-<span class="keyword">get</span> autoclean 清理无用的包
sudo apt-<span class="keyword">get</span> <span class="keyword">check</span> 检查是否有损坏的依赖</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>sudo apt-get install packagename 命令<br>apt-get是ubuntu下一个强大的命令行工具。可以用它来安装新的软件包，升级现有的软件包，升级列表索引，甚至升级整个系统。如果出现could not get lock /v]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下Parallels Desktop安装Ubuntu无法全屏]]></title>
    <link href="http://yoursite.com/2015/10/16/Mac%E4%B8%8BParallels-Desktop%E5%AE%89%E8%A3%85Ubuntu%E6%97%A0%E6%B3%95%E5%85%A8%E5%B1%8F/"/>
    <id>http://yoursite.com/2015/10/16/Mac下Parallels-Desktop安装Ubuntu无法全屏/</id>
    <published>2015-10-16T13:14:03.000Z</published>
    <updated>2015-10-16T13:31:38.000Z</updated>
    <content type="html"><![CDATA[<p>在Mac中，Parallels Desktop安装Ubuntu无法全屏问题出现，是由于在安装ubuntn是没有选择快速安装，因此在安装过程中就没有安装Parallels Tools。因此就会出现比如分辨率问题，或者终端窗口显示不正常等一些问题。解决这个问题方法就是安装Parallels Tools。可按照以下步骤安装：</p>
<ol>
<li>启动虚拟机。</li>
<li>确保虚拟机的 CD/DVD 驱动指向默认的空驱动</li>
<li>操作系统启动后请点击PD顶部菜单里的操作-&gt;安装Parallels Tools。<br>prl-tools-lin.iso 镜像文件将会加载至虚拟机的 CD/DVD 驱动器中。<br>如果上述方法没有加载成功，您也可手动连接并安装 Parallels Tools ISO 镜像文件。<br>右击虚拟机窗口的状态栏中的 CD/DVD 驱动图标并选择连接镜像。在弹出的 Finder 窗口中，进入硬盘文件夹（通常名为 “Macintosh HD”），选择 /Library/Parallels/Tools/ 文件夹（针对Parallels Desktop 7）或 /Applications/Parallels Desktop.app/Contents/Resources/Tools/ （针对 Parallels Desktop 8），选择prl-tools-lin.iso文件，然后点击打开连接至虚拟机。</li>
<li>在您的 Ubuntu 虚拟机中启动 终端。</li>
<li><p>在终端中找到光驱的位置：</p>
<p> cd /media/username/Parallels\ Tools/</p>
</li>
</ol>
<p>输入以下命令安装：</p>
<pre><code>sudo ./<span class="keyword">install</span>
</code></pre><p>根据 Parallels Tools 安装程序的提示完成安装。在 Parallels Tools 安装完成后，重新启动虚拟机。</p>
<blockquote>
<p>注意：1.上述命令中的Parallels\ Tools/的斜杠是因为路径名字包含空格，使用\作为转义字符代替空格<br> 2.不要在光驱中双击install-gui来安装，那样是无法安装的，必须在命令行下才可以安装</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Mac中，Parallels Desktop安装Ubuntu无法全屏问题出现，是由于在安装ubuntn是没有选择快速安装，因此在安装过程中就没有安装Parallels Tools。因此就会出现比如分辨率问题，或者终端窗口显示不正常等一些问题。解决这个问题方法就是安装Par]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客（二）]]></title>
    <link href="http://yoursite.com/2015/10/12/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2015/10/12/使用Hexo搭建个人博客（二）/</id>
    <published>2015-10-12T13:37:01.000Z</published>
    <updated>2015-10-16T13:11:00.000Z</updated>
    <content type="html"><![CDATA[<p>上篇文章介绍了如何通过Hexo来搭建博客，通过上篇文章相信搭建已经可以一个简单的博客了。但是这还不够，因为默认的博客还比较简陋，还需要进一步的去配置，使其更加完善。</p>
<p>官方提供了很多主题供大家来选择</p>
<ul>
<li>Hexo Themes - <a href="http://hexo.io/themes" target="_blank" rel="external">http://hexo.io/themes</a></li>
<li>NexT - <a href="http://theme-next.iissnan.com" target="_blank" rel="external">http://theme-next.iissnan.com</a></li>
<li>jacman - <a href="https://github.com/wuchong/jacman" target="_blank" rel="external">https://github.com/wuchong/jacman</a></li>
</ul>
<p>本文以Next为例来介绍主题使用方法</p>
<h4 id="下载NexT主题">下载NexT主题</h4><p>两种方法</p>
<ol>
<li><p>在终端窗口下，定位到 Hexo 站点目录下</p>
<p> $ cd your-hexo-site</p>
<p> $ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a>     themes/next</p>
</li>
<li><p>前往 NexT 版本 发布页面，选择你所需要的版本，下载 Download 下的 Source Code (zip) 到本地。解压所下载的压缩包至站点的 themes 目录下，并将 解压后的文件夹名称（hexo-theme-next-0.4.0）更改为 next</p>
</li>
</ol>
<h4 id="启用NexT主题">启用NexT主题</h4><p>克隆/下载 完成后，打开 站点配置文件，找到 theme 字段，并将其值更改为 next。<br>运行 hexo s –debug，并访问 <a href="http://localhost:4000，确保站点正确运行。" target="_blank" rel="external">http://localhost:4000，确保站点正确运行。</a></p>
<h4 id="主题设定">主题设定</h4><ol>
<li><p>语言设置：编辑 站点配置文件，将 language 设置成你所需要的语言。<br>例如选用正体中文，则配置为：</p>
<p> language: zh-hk</p>
</li>
</ol>
<ol>
<li><p>菜单设置：菜单配置在 主题配置文件 的 menu。 若你的站点运行在子目录中，请将链接前缀的 / 去掉。默认支持的菜单项有：</p>
<p> menu:</p>
<p> home: /</p>
<p> archives: /archives</p>
<p> about: /about</p>
<p> categories: /categories</p>
<p> tags: /tags</p>
<p> commonweal: /404.html</p>
</li>
<li><p>侧栏设置：默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示。可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。</p>
</li>
<li>头像设置：编辑 站点配置文件，新增字段 avatar， 值设置成头像的链接地址。</li>
<li>作者名称：编辑 站点配置文件，设置 author 为你的昵称。</li>
<li>站点描述设置：编辑 站点配置文件，设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:)</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>上篇文章介绍了如何通过Hexo来搭建博客，通过上篇文章相信搭建已经可以一个简单的博客了。但是这还不够，因为默认的博客还比较简陋，还需要进一步的去配置，使其更加完善。</p>
<p>官方提供了很多主题供大家来选择</p>
<ul>
<li>Hexo Themes - <a h]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客（一）]]></title>
    <link href="http://yoursite.com/2015/10/11/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2015/10/11/使用Hexo搭建个人博客（一）/</id>
    <published>2015-10-11T13:59:13.000Z</published>
    <updated>2015-10-12T13:35:08.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Hexo是什么">Hexo是什么</h3><p>Hexo是一款基于Node.js的快速，简单并且强大的静态博客框架，可以用Markdown写博客然后Hexo会在几秒钟之内生成漂亮的静态网页。生成后的静态网页可以直接部署到到Github Pages上。本文将介绍mac下的具体搭建方法。</p>
<h3 id="如何安装">如何安装</h3><h5 id="安装需求">安装需求</h5><p>安装Hexo非常简单。只需要先安装下面两个软件</p>
<ul>
<li><a href="http://nodejs.org" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://www.github.com" target="_blank" rel="external">Git</a></li>
</ul>
<p>安装Git</p>
<pre><code>$ <span class="keyword">brew </span>install git
</code></pre><p>安装Node.js最好的方法是用nvm，nvm全称Node Version Manager，之所以需要这个工具是因为Node.js的各种特性没有稳定下来，可以使用它切换版本</p>
<pre><code>$ curl http<span class="variable">s:</span>//raw.github.<span class="keyword">com</span>/creationix/nvm/master/install.<span class="keyword">sh</span> | <span class="keyword">sh</span>
</code></pre><p>nvm安装完成之后就可以安装Node.js了</p>
<pre><code>$ nvm <span class="keyword">install</span> <span class="number">0.12</span>
</code></pre><p>接着安装Hexo</p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo-cli</span>
</code></pre><h4 id="安装Hexo">安装Hexo</h4><p>安装Hexo只需要一条命</p>
<pre><code>$ npm <span class="operator"><span class="keyword">install</span> hexo-cli -<span class="keyword">g</span></span>
</code></pre><h3 id="配置">配置</h3><p>接下来需要新建一个文件夹来存放博客内容，这里我创建在~/blog 目录下<br>然后把路径切换至这个目录下面</p>
<pre><code><span class="char">$ </span>hexo init ~/blog
<span class="char">$ </span>npm install
</code></pre><p>配置好了之后，文件夹内容如下所示</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── scripts
├── source
<span class="string">|   ├── _drafts</span>
<span class="string">|   └── _posts</span>
└── themes
</code></pre><p>安装常用插件</p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save    #索引</span>
npm <span class="keyword">install</span> hexo-generator-<span class="keyword">archive</span> <span class="comment">--save  #归档</span>
npm <span class="keyword">install</span> hexo-generator-<span class="keyword">category</span> <span class="comment">--save #分类</span>
npm <span class="keyword">install</span> hexo-generator-tag <span class="comment">--save      #标签</span>
npm <span class="keyword">install</span> hexo-<span class="keyword">server</span> <span class="comment">--save             #本地服务器</span>
npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save       #git部署</span>
npm <span class="keyword">install</span> hexo-generator-feed@<span class="number">1</span> <span class="comment">--save   #生成rss</span>
npm <span class="keyword">install</span> hexo-generator-sitemap@<span class="number">1</span> <span class="comment">--save#生成站点地图</span></span>
</code></pre><h3 id="写文章">写文章</h3><p>使用下面命令写文章</p>
<pre><code>$ hexo new <span class="string">[layout]</span> &lt;title&gt;
</code></pre><p>Hexo提供了三种布局：post，page和draft，默认值为：post。例如写一篇名为“Hexo简介”的文章，命令为</p>
<pre><code>$ hexo <span class="keyword">new</span> <span class="string">"Hexo简介"</span>
</code></pre><p>命令执行后文章文件被保存到source/_posts下，名为“Hexo简介.md”为md格式文件，打开即可编辑文章的内容。打开内容入下</p>
<pre><code>title: Hello World
date: 2013/7/13 20:46:25
<span class="header">tag:
---</span>
</code></pre><p>可编辑tag的值，并且添加categories等字段，例如</p>
<pre><code>title: Hello World
date: <span class="number">2013</span>/<span class="number">7</span>/<span class="number">13</span> <span class="number">20</span>:<span class="number">46</span>:<span class="number">25</span>
categories:
- 随笔
tags:
- Python
- 算法
comments: <span class="literal">false</span>   <span class="preprocessor">#不显示评论</span>
</code></pre><p>执行下面命令,打开<a href="http://0.0.0.0:4000,本地查看效果" target="_blank" rel="external">http://0.0.0.0:4000,本地查看效果</a></p>
<pre><code>$ hexo <span class="keyword">server</span>    <span class="preprocessor">#简写命令 hexo s</span>
</code></pre><blockquote>
<p>如果无法正常打开，请关闭各种代理或fq软件</p>
</blockquote>
<h3 id="部署到Github上">部署到Github上</h3><h4 id="生成Github_Pages">生成Github Pages</h4><ol>
<li>登陆到Github</li>
<li>在主页右上角创建New repository，Repository name必须为用户名yourname,github.io，比如我的用户名为geekzph，因此应设置为geekzph.github.io</li>
<li>选为public，点击Create</li>
<li>在打开的页面右侧点Settigs，之后点Launch automatic page generator，这样Github Pages就已经生成了</li>
</ol>
<h4 id="发布博客到Github上">发布博客到Github上</h4><p>打开博客目录下的站点配置文件_config.yml，添加以下字段，注意冒号后面都得有空格，否则会出错，yourname为自己的Github账户名字</p>
<pre><code><span class="attribute">deploy</span>:
  <span class="attribute">type</span>: git
  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/yourname/yourname.github.io.git</span>
  <span class="attribute">branch</span>: master
</code></pre><p>生成静态网页</p>
<pre><code><span class="variable">$ </span>hexo generate <span class="comment">#简写命令 hexo g    </span>
</code></pre><p>执行下面命令部署</p>
<pre><code><span class="variable">$ </span>hexo deploy    <span class="comment">#简写命令 hexo d</span>
</code></pre><p>输入Github的用户名和密码。<br>这时候就可以打开Github查看效果了。</p>
<blockquote>
<p>注意：执行 hexo server 等命令时需要先到博客所在目录才可以。mac下如出现编译错误需要从App Store安装Xcode。安装之后打开Xcode， Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 来安装命令行工具，或者使用命令 $ xcode–select –install。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Hexo是什么">Hexo是什么</h3><p>Hexo是一款基于Node.js的快速，简单并且强大的静态博客框架，可以用Markdown写博客然后Hexo会在几秒钟之内生成漂亮的静态网页。生成后的静态网页可以直接部署到到Github Pages上。本文将介绍ma]]>
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[google's new logo]]></title>
    <link href="http://yoursite.com/2015/10/10/google-s-new-logo/"/>
    <id>http://yoursite.com/2015/10/10/google-s-new-logo/</id>
    <published>2015-10-10T14:00:47.000Z</published>
    <updated>2015-10-11T14:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>Google的logo使用的复杂的衬线字体，这种字体只能使用贝塞尔曲线创建曲线。所有加在一起，一共有100锚点，导致其为一个6kb的文件。经过压缩，大小变为3kb。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/128240-41db0110e79feef2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="old_google_logo.png"><br>经过简化的新logo，从另一方面来说，可以用圆形和矩形进行创建（除了小写e）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/128240-6e95a06f09d0b95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new_google_logo.png"><br>整个logo包括：</p>
<ul>
<li>10个圆形</li>
<li>5个矩形</li>
</ul>
<h5 id="305字节是真实的大小吗？">305字节是真实的大小吗？</h5><p>尽管Google没有发布优化的305字节的logo，并且似乎网上也找不到，但是我相信他们大小降到了他们宣称的305字节。</p>
<p>为了验证这一点，我用SVG格式重画了第一个字母G，最终未经压缩的大小为302字节，压缩后未195字节。</p>
<p>下面是整个未经压缩的图像，包括两个圆和两个矩形。</p>
<pre><code>&lt;svg xmlns=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;                                                        
&lt;circle r=<span class="string">"100"</span> cy=<span class="string">"100"</span> cx=<span class="string">"100"</span> <span class="built_in">fill</span>=<span class="string">"#4885ed"</span>/&gt;
&lt;circle r=<span class="string">"70"</span> cy=<span class="string">"100"</span> cx=<span class="string">"100"</span> <span class="built_in">fill</span>=<span class="string">"#ffffff"</span>/&gt;
&lt;<span class="built_in">rect</span> transform=<span class="string">"rotate(-40 166,67)"</span> <span class="variable">height</span>=<span class="string">"78"</span> <span class="variable">width</span>=<span class="string">"99"</span> y=<span class="string">"27"</span> x=<span class="string">"117"</span> <span class="built_in">fill</span>=<span class="string">"#ffffff"</span>/&gt;
&lt;<span class="built_in">rect</span> <span class="variable">height</span>=<span class="string">"30"</span> <span class="variable">width</span>=<span class="string">"88"</span> y=<span class="string">"87"</span> x=<span class="string">"111"</span> <span class="built_in">fill</span>=<span class="string">"#4885ed"</span>/&gt;
&lt;/svg&gt;
</code></pre><p>生成的图形：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/128240-da22ac8e7d7f64fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="crate_logo.png"></p>
<h5 id="为什么这很重要">为什么这很重要</h5><p>正如Google在他们的blog中写到的：</p>
<blockquote>
<p>旧的logo由于其复杂的衬线字体和过大的文件尺寸，使我们不得不为低带宽的用户提供了一个文本近似的logo。新的logo减少了文件尺寸从而避免了这一变通方案，当考虑到我们的目标是使Google变得更加容易访问和有用，这一改变是有重大影响的。</p>
</blockquote>
<p>译自：<a href="https://www.quora.com/How-could-Googles-new-logo-be-only-305-bytes-while-its-old-logo-is-14-000-bytes" target="_blank" rel="external">https://www.quora.com/How-could-Googles-new-logo-be-only-305-bytes-while-its-old-logo-is-14-000-bytes</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Google的logo使用的复杂的衬线字体，这种字体只能使用贝塞尔曲线创建曲线。所有加在一起，一共有100锚点，导致其为一个6kb的文件。经过压缩，大小变为3kb。<br>]]>
    
    </summary>
    
      <category term="google" scheme="http://yoursite.com/tags/google/"/>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2015/09/27/hello-world/"/>
    <id>http://yoursite.com/2015/09/27/hello-world/</id>
    <published>2015-09-27T13:41:23.000Z</published>
    <updated>2015-09-27T13:41:23.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[geekzph's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://geekzph.github.io/"/>
  <updated>2017-08-24T02:29:03.000Z</updated>
  <id>http://geekzph.github.io/</id>
  
  <author>
    <name><![CDATA[geekzph]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[面试那些事儿之数据结构]]></title>
    <link href="http://geekzph.github.io/2017/08/24/%E9%9D%A2%E8%AF%95%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://geekzph.github.io/2017/08/24/面试那些事儿之数据结构/</id>
    <published>2017-08-24T02:28:34.000Z</published>
    <updated>2017-08-24T02:29:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-哈希构造函数有哪几种？处理冲突的方法。解决哈希冲突的方法有哪几种？哈希表的时间复杂度。">1.哈希构造函数有哪几种？处理冲突的方法。解决哈希冲突的方法有哪几种？哈希表的时间复杂度。</h3><p>哈希函数的构造方法有很多，但应注意两个原则：第一，函数值应在1至记录总数之间；第二，尽可能避免冲突。<br>设要存放的数据元素有n个，存放数据元素的内存单元有m个，设计哈希函数的目标就是要使通过哈希函数得到的n个数据元素的哈希地址尽可能均匀地分布在m个连续内存单元上，同时使计算过程尽可能简单以达到尽可能高的时间效率。<br>哈希构造函数：1．直接定址法2．数字分析法3．折叠法4．平方取中法<br>5.减去法7.除留余数法8．随机乘数法10.旋转法11.伪随机数法<br>处理冲突方法：1.链地址法 2.开放定址法 3.再散列法 4.建立一个公共溢出区 5.线性探测法 6.二次探测法 7.伪随机探测法<br>装填因子 = 关键字个数 / 表长度<br>时间复杂度O(1)</p>
<h3 id="哈希表在桶固定的情况下，时间复杂度，怎么优化。多线程中哈希表保证线程安全。哈希表特别大，桶特别多的时候怎么加锁？">哈希表在桶固定的情况下，时间复杂度，怎么优化。多线程中哈希表保证线程安全。哈希表特别大，桶特别多的时候怎么加锁？</h3><p>由于Hash桶容量的限制，所以，有可能发生Hash表填不满的情况，也就是，虽然Hash表里面还有空位，但是新建的表项由于冲突过多，而不能装入Hash表中。不过，这样的实现也有其好处，就是查表的最大开销是可以确定的，因为最多处理的冲突数是确定的，所以算法的时间复杂度为O(1)+O(m)，其中m为Hash桶容量。</p>
<h3 id="2-什么是索引？优点是什么？有哪几种索引？索引的底层实现，为什么要用B+树而不用红黑树?">2.什么是索引？优点是什么？有哪几种索引？索引的底层实现，为什么要用B+树而不用红黑树?</h3><p>关系数据库中，索引是一种单独的、物理的数对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。<br>Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。<br>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的<br>InnoDB也使用B+Tree作为索引结构，第一个重大区别是InnoDB的数据文件本身就是索引文件。第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<h3 id="6-set,map的底层实现？为什么要用红黑树？而不用AVL树？_插入删除的复杂度。">6.set,map的底层实现？为什么要用红黑树？而不用AVL树？ 插入删除的复杂度。</h3><p>红黑树</p>
<ol>
<li>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</li>
<li>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</li>
<li>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。<br>插入、删除、查找时的复杂度都为 O(log n)</li>
</ol>
<h3 id="7-hashmap的实现方式_，，实现unordered_map过程中的冲突解决办法">7.hashmap的实现方式 ，，实现unordered_map过程中的冲突解决办法</h3><p>hash_map内部是一个hash_table一般是由一个大vector，vector元素节点可挂接链表来解决冲突，来实现。hash_map其插入过程是：<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>存放key和value在桶内。</p>
<p>其取值过程是:<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>比较桶的内部元素是否与key相等，若都不相等，则没有找到。<br>取出相等的记录的value。</p>
<h3 id="hash函数如何保证冲突最小">hash函数如何保证冲突最小</h3><p>1、增大 映射空间/原空间 的大小<br>2、尽可能把原数据集均匀映射到较小空间<br>3、结合原空间数据的数据特征<br>设m和n分别表示表长和表中填人的结点数，则将α=n/m定义为散列表的装填因子(load factor)。α越大，表越满，冲突的机会也越大。</p>
<h3 id="hashmap的iterator读取时是否会读到另一个线程put的数据">hashmap的iterator读取时是否会读到另一个线程put的数据</h3><h3 id="vector使用的注意点及其原因_频繁对vector调用push_back()对性能的影响和原因">vector使用的注意点及其原因 频繁对vector调用push_back()对性能的影响和原因</h3><p>1.vector支持随机存取，因此你只要知道元素的位置，可以在常数时间内存取任何一个元素；<br>2.在末端附加或删除元素，vector的性能相当好，但是在前端或中部安插或删除元素，性能就不行了，因为操作点之后的每一个元素都必须向后移动，而每一次移动都得调assignment操作符；<br>3.合适的vector大小很重要，因为capacity()返回的实际容纳的元素数量过小，vector就必须重新配置内存存储器，vector是一个动态数组，里面有一个指针指向一片连续的内存空间，当空间不够装下数据时会自动申请另一片更大的空间，然后把原有数据拷贝过去，接着释放原来的那片空间。可以使用 vector::reserve 先预留一个较大的容量。 这样在push_back 的时候就无需频繁的内存重新分配，直到预留的容量已经使用完了。<br>(1)一旦内存重新配置，和vector元素相关的所有references,pointers,iterators都会失效；<br>(2)内存重新配置很耗时间；<br>4.发生以下情况vector迭代器失效：<br>(1)使用者在一个较小索引位置上安插或移除元素<br>(2)由于容量变化而引起重新分配<br>5.vector只支持最低限度的逻辑错误检查。下标操作符的安全版本at()，是唯一被标准规格书要求可能抛出异常的一个函数，其他函数都不做检查，如果发生越界存取，会引发未定义的行为；</p>
<h3 id="红黑树的了解_,红黑树的特性与其在C++_STL中的应用,红黑树的调整_,讲讲B+树，红黑树_,红黑树的了解与其查找复杂度（红黑树的特性和复杂度是热门问题）">红黑树的了解 ,红黑树的特性与其在C++ STL中的应用,红黑树的调整 ,讲讲B+树，红黑树 ,红黑树的了解与其查找复杂度（红黑树的特性和复杂度是热门问题）</h3><p>1.每个节点不是红色就是黑色<br>2.根节点为黑色<br>3.如果子节点为红，其子节点必须为黑<br>4.任一节点至NULL的任何路径，所包含之黑节点数必须相同 </p>
<p>12.平衡二叉树转化为双向链表？</p>
<p>20.介绍更高效的建树判重数据结构 </p>
<h3 id="37-问STL内存分配，vector的实现内存管理，deque的内存管理，list的排序">37.问STL内存分配，vector的实现内存管理，deque的内存管理，list的排序</h3><p>STL分为两级配置器，当请求的内存大于128b的时候调用第一级配置器，当请求的内存小于等于128b的时候调用第二级配置器。</p>
<h3 id="51-InnoDB和MyISAM区别，对数据库包括其引擎的区别与了解">51.InnoDB和MyISAM区别，对数据库包括其引擎的区别与了解</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。MyISAM的索引方式也叫做“非聚集索引“</p>
<p>InnoDB也使用B+Tree作为索引结构。第一个重大区别是InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。<br>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<h3 id="217-B树、存储模型（B树、B+树与数据库引擎这块是热门问题）">217.B树、存储模型（B树、B+树与数据库引擎这块是热门问题）</h3><h3 id="数据库索引的作用">数据库索引的作用</h3><p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二，可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。<br>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四，在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<h3 id="mysql数据库实现层级树形结构，引擎，索引，查询优化">mysql数据库实现层级树形结构，引擎，索引，查询优化</h3><h3 id="B+树详细介绍，手画B+树">B+树详细介绍，手画B+树</h3><p>与B-Tree相比，B+Tree有以下不同点：<br>每个节点的指针上限为2d而不是2d+1。<br>内节点不存储data，只存储key；叶子节点不存储指针。</p>
<h3 id="数据库索引，联合索引，结合B+树分析">数据库索引，联合索引，结合B+树分析</h3><h3 id="数据库的索引分为哪几种，特点是什么。">数据库的索引分为哪几种，特点是什么。</h3><p>类型分类<br>1) 聚簇索引<br>按照数据存放物理位置为顺序。是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是记录指针。<br>2) 非聚簇索引<br>表数据的存储顺序和索引顺序无关。是一种密集索引，在数据页上一级索引页为每一个数据行存储一条索引记录。<br>3.2  功能分类<br>1) 唯一索引<br>不允许其中任何两行具有相同索引值的索引。<br>[数据中存在重复的键值时，大多数数据库系统不允许新创建的唯一索引和表保存，数据库中为此防止了重复数据添加。例如:在职工表姓氏上创建唯一索引，则任何两个员工都不能同姓。]<br>2) 主键索引<br>主键索引是唯一索引的特定类型。[数据库表创建主键后将自动生成主键索引，该索引要求主键中的每一个值都具有唯一性]<br>3) 聚集索引<br>表中行的物理顺序与键值的逻辑顺序相同，且一个数据表只能包含一个聚集索引。[与非聚集索引相比，聚集索引具有更快的访问速度]</p>
<p>mysql索引<br>从数据结构角度<br>1、B+树索引(O(log(n)))：关于B+树索引，可以参考 MySQL索引背后的数据结构及算法原理<br>2、hash索引：<br>a 仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询<br>b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引<br>c 只有Memory存储引擎显示支持hash索引<br>3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）<br>4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）<br>从物理存储角度<br>1、聚集索引（clustered index）<br>2、非聚集索引（non-clustered index）<br>从逻辑角度<br>1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值<br>2、普通索引或者单列索引<br>3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合<br>4、唯一索引或者非唯一索引<br>5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。</p>
<h3 id="数据库的ACID">数据库的ACID</h3><p>1）原子性（Atomicity）<br>所谓原子性就是将一组操作作为一个操作单元，是原子操作，即要么全部执行，要么全部不执行。<br>2）一致性（Consistency）<br>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。<br>3）隔离性（Isolation）<br>隔离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。<br>4）持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。即一旦一个事务提交，DBMS（Database Management System）保证它对数据库中数据的改变应该是永久性的，持久性通过数据库备份和恢复来保证。</p>
<h3 id="59-图的邻接矩阵和邻接表的表示，邻接表的数据结构。">59.图的邻接矩阵和邻接表的表示，邻接表的数据结构。</h3><p>195.LRU模仿一下内部实现，实现insert函数（插入），get(获得头部元素，但是也相当于对头部进行查询)，?<br>最开始用O(N)静态数组复杂度模拟两个函数.<br>能优化不？用堆+map标记时间复杂度降低到log(n)<br>还能优化不？<br>get函数使用双向循环链表，只是更改指针，时间复杂度降为O<1>,insert没想法优化到1了。最低logn</1></p>
<h3 id="字典树的概念，插入和删除需要注意些什么">字典树的概念，插入和删除需要注意些什么</h3><p>Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。</p>
<h3 id="字典树你有什么优化的地方">字典树你有什么优化的地方</h3><p>在标准Trie树的基础上，可以压缩：若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上的所有结点压缩成一个叶子结点。</p>
<h3 id="同样很多的字符串，你怎么尽可能少的压缩空间去存储，设计一种数据结构实现，不能使用字典树">同样很多的字符串，你怎么尽可能少的压缩空间去存储，设计一种数据结构实现，不能使用字典树</h3><h3 id="字典树构造及其优化与应用">字典树构造及其优化与应用</h3><p>对字母进行逐层划分。建立一个Trie树的过程就是不断添加新的单词的过程。由根节点向下扫描，如果不存在相应的节点则创建之。否则进入下一个层次，直到单词添加完毕。</p>
<h3 id="字典树与其在统计词频上的应用">字典树与其在统计词频上的应用</h3><p>Trie树的根为空节点，不存放数据。每个节点包含了一个指针数组，数组大小通常为26，即保存26个英文字母（如果要区分大小则数组大小为52，如果要包括数字，则要加上0-9，数组大小为62）。<br>可以想象它是一棵分支很庞大的树，会占用不少内存空间；不过它的树高不会唱过最长的字符串长度，所以查找十分快捷。典型的用空间换取时间。<br>rie树中检索的过程是走一条从跟节点开始到叶子节点的路径（不一定走到叶子节点，取决于你的Trie树的实现，如果规定每个单词以$结束，那么检索成功的话一定走到叶子节点）：如下图示意,检索单词bat的路径用红色标出。在Trie的node节点中添加count域后，可以统计单词出现的次数。统计的方法就是在插入单词的时候，令相应的count域加1（初始化为0）。代码见Trie插入部分。</p>
<h3 id="持久化数据结构，序列化与反序列化时机">持久化数据结构，序列化与反序列化时机</h3><p>可持久化数据结构 就是使数据结构可以返回历史版本<br>一般的实现方法是新建有修改的点 其他点与上一版本共用 这样做到空间复杂度带上一个或两个log<br>序列化：将程序中的对象或者数据结构转换成二进制串的过程。<br>反序列化：将在序列化过程中所生成的二进制串转换成对象或者数据结构的过程</p>
<h3 id="实现bitmap数据结构，包括数据的存储与插入方式">实现bitmap数据结构，包括数据的存储与插入方式</h3><p>位数组</p>
<h3 id="如果用bitmap解决大数量整数去重问题，计算当全为int型整数时需要消耗的内存">如果用bitmap解决大数量整数去重问题，计算当全为int型整数时需要消耗的内存</h3><p>int的最大为2^32, 内存为2^32*1byte/8/1024/1024 MB</p>
<h3 id="Bloom过滤器的实现">Bloom过滤器的实现</h3><p>位数组与hash函数联合使用，插入元素时，根据k个hash函数得到位数组的k位，将这些为置为1.查找时，利用k个hash函数得到k个位，若所有点为1，则在集合内。不是适合零错误的场合，用极少的错误换取了存储空间的极大节省。</p>
<h3 id="二叉树的遍历与实现">二叉树的遍历与实现</h3><h3 id="单链表的倒置">单链表的倒置</h3><p>网页解析的过程与实现方法<br>访问一个web页面的流程<br>有哪些地方可以做分流（DNS，服务器，数据库。。。），分别有哪些方式<br>快速排序的稳定化算法（此方法可百度到）</p>
<p>7微信红包的设计 开发 注意 用户数据的统计<br>DFA的过程与正则的区别<br>单源最短路你会哪些。说一下，时间复杂度都是多少？<br>dijska,spfa dij能优化不？(堆优化和优先队列优化两种)<br>191.给你个图，已经源点和终点，问先从源点到终点，在从源点回到终点，最短路径怎么求?时间复杂度怎么样？<br>建立两个对称图搜索+标记+剪枝<br>还有什么方法?<br>跑一点最短路。另一遍进行搜索判断 </p>
<p>2项目中的数据库备份，主从数据库、集群<br>3数据库的索引原理，b+树原理，trie树引申，二叉查找树的原理<br>4海量数据中查找一个单词，分布式计算map reduce ，或者用hsah映射筛选部分结果 </p>
<p>3、redis五种数据类型，当散列类型的value值非常大的时候怎么进行压缩，用redis怎么实现摇一摇与附近的人功能，redis主从复制过程， </p>
<p>6、其他的nosql存储<br>7、记不清了，应该还有一<br>数据库连接池用的是什么，配置文件呢，数据库驱动怎么下载的，持久层框架呢。<br>4为什么要用数据库连接池，有什么好处。 </p>
<p>7、sql，group by的理解<br>8、oracle与mysql的区别<br>9、redis了解多少<br>13 了解 数据库的存储数据的数据结构吗  不是很懂 说不会<br>14 讲讲你熟悉的nosql数据库  讲了一下redis 感觉他不是很满意<br>数据库中join的类型与区别（如果平时不怎么写业务代码，可一串int型整数存放磁盘上的压缩存储方式，包括写入与读取及内存无法一次性读取时的解决办法 </p>
<pre><code>•    Bloom过滤器的优点与原理 
•    字符串<span class="built_in">hash</span>成状态位的具体实现方式 
•    <span class="built_in">hash</span>函数如何保证冲突最小 
</code></pre><p>Bloom过滤器处理大规模问题时的持久化，包括内存大小受限、<br>数据库join的具体含义<br>mysql数据库连接池的驱动参数<br>数据库连接池如何防止失效<br>部署项目时tomcat 的参数 </p>
<p>红黑树的了解与其查找复杂度（红黑树的特性和复杂度是热门问题）<br>mysql数据库 实现层级树形结构 引擎 索引 查询优化 多方面<br>MySQL存储引擎, B+树<br>memcache了解<br>    对数据库的了解<br>    •    mysql执行的慢，如何分析<br>    •    数据库如何建立索引，以及索引的实现<br>    数据库索引，联合索引，结合B+树分析<br>    STL 相关: STL 中的内存管理(allocator)的原理, 以及如何让它线程安全。<br>    •    因为我对 STL 源码比较了解, 所以就很轻松地回答了 allocator 的实现原理, 相关实现可以参考《STL 源码剖析(侯捷)》。<br>    •    由于对线程安全了解的比较少, 所以直接我给面试官说我不知道。面试官也没多说。等到后面回答了线程安全的单例模式时, 面试官让我把那里线程安全的知识用在这里来。然后我就大概写了一下分配器工作的关键代码的伪代码, 然后试着去加锁。最后面试官还是觉得很满意的。<br>    9.超长字段有没有其他优化方式(搜索引擎？)<br>10.Redis数据结构<br>11.Redis持久化机制<br>12.基于快照的方式在持久化的过程中有其他更新怎么办<br>13.多版本并发控制<br>14.MySQL默认隔离级别？为什么(可以用next-key Lock防止幻影读)<br>15.Redis与Memcached区别<br>16.项目中Redis的使用<br>2.Redis的使用，Redis查找跟插入都很快，可以再考虑下Redis与MySQL的适用场景<br>5.MySQL索引底层实现<br>6.MySQL聚集索引与非聚集索引区别<br>7.有人建议给每张表都建一个自增主键，这样做有什么优点跟缺点<br>8.第三范式<br>3.hashmap和hashtable的区别<br>结构体和共用体区别<br>1.strcpy memcpy什么玩意的</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-哈希构造函数有哪几种？处理冲突的方法。解决哈希冲突的方法有哪几种？哈希表的时间复杂度。">1.哈希构造函数有哪几种？处理冲突的方法。解决哈希冲突的方法有哪几种？哈希表的时间复杂度。</h3><p>哈希函数的构造方法有很多，但应注意两个原则：第一，函数值应在1至]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 5]]></title>
    <link href="http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-5/"/>
    <id>http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-5/</id>
    <published>2017-08-24T02:01:31.000Z</published>
    <updated>2017-08-24T02:01:31.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 4]]></title>
    <link href="http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-4/"/>
    <id>http://geekzph.github.io/2017/08/24/LeetCode-Top-100-Liked-Question-4/</id>
    <published>2017-08-24T02:01:16.000Z</published>
    <updated>2017-08-24T02:01:16.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 3]]></title>
    <link href="http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-3/"/>
    <id>http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-3/</id>
    <published>2017-08-19T10:48:52.000Z</published>
    <updated>2017-08-24T01:49:46.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 2]]></title>
    <link href="http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-2/"/>
    <id>http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-2/</id>
    <published>2017-08-19T10:48:44.000Z</published>
    <updated>2017-08-24T01:49:38.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode Top 100 Liked Question 1]]></title>
    <link href="http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-1/"/>
    <id>http://geekzph.github.io/2017/08/19/LeetCode-Top-100-Liked-Question-1/</id>
    <published>2017-08-19T10:48:40.000Z</published>
    <updated>2017-08-24T01:37:22.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>Two Sum ：从数组中找到两个数相加和为目标值</li>
<li>Add Two Numbers ：将两个链表表示的数相加</li>
<li>Longest Substring Without Repeating Characters ：没有重复元素的最长子字符串</li>
<li>Median of Two Sorted Arrays ：找到两个有序数组的中位数</li>
<li>Longest Palindromic Substring ：最长回文子字符串</li>
<li>Regular Expression Matching ：判断表达式是否匹配，含有正则 . 和 * 。</li>
<li>Container With Most Water ：数组中任意两个点与x坐标组成的水桶，求最多能装多少水</li>
<li>3Sum ：数组中三个数能否相加后为0。求出所有组合，相同元素只算一次。</li>
<li>Letter Combinations of a Phone Number ：递归、回溯经典题</li>
<li>Remove Nth Node From End of List ：删除列表中从后往前数第n个结点</li>
<li>Valid Parentheses ：求括号是否符合规定。栈</li>
<li>Merge Two Sorted Lists ：合并两个有序链表。</li>
<li>Generate Parentheses ：给定括号对数，写出所有合法的组合。回溯</li>
<li>Merge k Sorted Lists ：合并k个有序链表。优先对队列或归并排序</li>
<li>Longest Valid Parentheses ：找括号合法的最长子字符串。栈</li>
<li>Search in Rotated Sorted Array ：在旋转有序数组中找目标值。二分查找</li>
<li>Search for a Range ：找到升序数组中目标值的范围。二分查找</li>
<li>Combination Sum ：在数组中找到所有可以相加得到目标值的组合。回溯</li>
<li>Trapping Rain Water ：接水量。左右指针</li>
<li>Permutations ：全排列。回溯</li>
</ul>
<h3 id="Two_Sum_[34-5%]_[Easy]"><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">Two Sum [34.5%] [Easy]</a></h3><ul>
<li>题意 ：给定一个整数数组，返回两个数字的索引，使它们相加到一个特定的目标。假定只有一个解，不能使用相同元素两次。</li>
<li><p>例子 :<br>对于数组nums = [2, 7, 11, 15]，目标值target为9，</p>
<pre><code>因为nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>，所以返回[<span class="number">0</span>, <span class="number">1</span>]。
</code></pre></li>
<li>思路：两根指针分别从前，和从后想中间扫描</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; twoSum(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[start] + nums[<span class="keyword">end</span>]) == target)&#123;</span><br><span class="line">                <span class="literal">result</span>.push_back(start);</span><br><span class="line">                <span class="literal">result</span>.push_back(<span class="keyword">end</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] + nums[<span class="keyword">end</span>] &lt; target) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] + nums[<span class="keyword">end</span>] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">end</span>--;</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="literal">result</span>.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Add_Two_Numbers[27-7%]_[Medium]"><a href="https://leetcode.com/problems/add-two-numbers" target="_blank" rel="external">Add Two Numbers[27.7%] [Medium]</a></h3><ul>
<li>题意 ：给定两个非空的链表，表示两个非负整数， 低位在前，高位在后 。将两个数字相加并作为链表返回。假定两个数字不包含任何前导零，除了数字0本身。</li>
<li>例子：<br>输入 (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出 7 -&gt; 0 -&gt; 8</li>
<li>思路：按链表依次相加，注意进位</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">      <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">      ListNode* res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      ListNode* p1 = l1; </span><br><span class="line">      ListNode* p2 = l2;</span><br><span class="line">      ListNode* p3 = res;</span><br><span class="line">      <span class="keyword">while</span>(p1 != <span class="keyword">NULL</span> || p2 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(p1 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">              carry += p1-&gt;val;</span><br><span class="line">              p1 = p1-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(p2 != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">              carry += p2-&gt;val;</span><br><span class="line">              p2 = p2-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          p3-&gt;next = <span class="keyword">new</span> ListNode(carry % <span class="number">10</span>);</span><br><span class="line">          p3 = p3-&gt;next;</span><br><span class="line">          carry = carry / <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">      p3-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Longest_Substring_Without_Repeating_Characters_[24-3%]_[Medium]"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="external">Longest Substring Without Repeating Characters [24.3%] [Medium]</a></h3><ul>
<li>题意 ：求无重复字符的最长子字符串</li>
<li>例子：<br>给定“abcabcbb”，答案是“abc”，长度为3。<br>给定“bbbbb”，答案是“b”，长度为1。<br>给定“pwwkew”，答案是“wke”，长度为3。请注意，答案必须是子字符串，“pwke”是子序列而不是子字符串。</li>
<li>思路：假设子字符串有重复字符，则父字符串一定含有重复字符，单个子问题就可以决定父问题，因此可以用贪心法。从左到右扫描，当遇到重复字母时，以上一个重复字母index+1，作为新的搜索位置，知道最后一个字母，复杂度O(n);<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> ASCII_MAX = <span class="number">255</span>;</span><br><span class="line">        <span class="keyword">int</span> last[ASCII_MAX];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        fill(last, last + ASCII_MAX, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(last[s[i]] &gt;= start)&#123;</span><br><span class="line">                max_len = max(i - start, max_len);</span><br><span class="line">                start = last[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max((<span class="keyword">int</span>)s.size() - start, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Median_of_Two_Sorted_Arrays_[21-7%]_[Hard]"><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays [21.7%] [Hard]</a></h3><ul>
<li>题意 ：找到两个排序数组的中位数。整体运行时间复杂度要求为O（log（m + n））。</li>
<li>例子：<br>nums1 = [1, 3]，nums2 = [2]<br>The median is 2.0<br>nums1 = [1, 2]，nums2 = [3, 4]<br>The median is (2 + 3)/2 = 2.5</li>
<li>思路：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Longest_Palindromic_Substring_[25-2%]_[Medium]"><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="external">Longest Palindromic Substring [25.2%] [Medium]</a></h3><ul>
<li>给定一个字符串s，找到s中最长的 回文子字符串 。假定s的最大长度为1000。</li>
<li>例子：<br>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer<br>Input: “cbbd”<br>Output: “bb”</li>
<li>思路：以每个字符的中间向两边扩展，如果左右相等则增加距离。注意偶数回文字符串。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandFromCenter</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//int len = 0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandFromCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandFromCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; end - start)&#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> s.substr(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Regular_Expression_Matching_[24-1%]_[Hard]"><a href="https://leetcode.com/problems/regular-expression-matching" target="_blank" rel="external">Regular Expression Matching [24.1%] [Hard]</a></h3><ul>
<li>题意 ：判断表达式是否匹配，含有正则 . 和 <em> 。 . 匹配任何单个字符， </em> 匹配0个或多个前面的字符</li>
<li>例子：<br>isMatch(“aa”,”a”) ? false<br>isMatch(“aa”,”aa”) ? true<br>isMatch(“aaa”,”aa”) ? false<br>isMatch(“aa”, “a<em> “) ? true<br>isMatch(“aa”, “.</em> “) ? true<br>isMatch(“ab”, “.<em> “) ? true<br>isMatch(“aab”, “c</em> a* b”) ? true</li>
<li>思路：动态规划</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Container_With_Most_Water_[36-6%]_[Medium]"><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">Container With Most Water [36.6%] [Medium]</a></h3><ul>
<li><p>题意 ：给定一个非负整数数组，其中每个数表示坐标（i，ai）处的点。 绘制n条垂直线，使得线i的两个端点在（i，ai）和（i，0）处。 找到两条线，它们与x轴一起形成一个容器，使得容器含有最多的水。</p>
</li>
<li><p>例子：</p>
</li>
<li><p>思路 ： 两个指针分别在0和n - 1位置，记下此时的面积，比较这两个位置的大小，如果右边大，则左指针向右遍历；如果左边大，则右指针向左遍历。然后计算新的面积。保存最大的面积</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3Sum_[21-6%]_[Medium]"><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">3Sum [21.6%] [Medium]</a></h3><ul>
<li>题意 ：给定n个整数的数组S，S中是否有元素a，b，c，使得c + b + c = 0？ 找到数组中所有这样的三个元素，相同结果只记一次</li>
<li>例子 ：S = [-1, 0, 1, 2, -1, -4]，结果为[[-1, 0, 1], [-1, -1, 2]]</li>
<li>思路 ：转换成2Sum问题。对于S中所有的不同元素，求它们的twoSum，注意重复元素。</li>
</ul>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; threeSum(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        sort(nums.begin(), nums.<span class="keyword">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">while</span>(start &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (start &gt; i + <span class="number">1</span> &amp;&amp; nums[start - <span class="number">1</span>] == nums[start]) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] &lt; target)</span><br><span class="line">                    start++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] &gt; target)</span><br><span class="line">                    <span class="keyword">end</span>--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] + nums[<span class="keyword">end</span>] == target)&#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; triple;</span><br><span class="line">                    triple.push_back(nums[i]);</span><br><span class="line">                    triple.push_back(nums[start]);</span><br><span class="line">                    triple.push_back(nums[<span class="keyword">end</span>]);</span><br><span class="line">                    <span class="literal">result</span>.push_back(triple);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Letter_Combinations_of_a_Phone_Number_[34-4%]_[Medium]"><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="external">Letter Combinations of a Phone Number [34.4%] [Medium]</a></h3><ul>
<li>题意 ：给定一个数字字符串，返回数字可能代表的所有可能的字母组合。映射关系是手机的九宫格。</li>
<li>例子 ：<br>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</li>
<li>思路 ：回溯法<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">const</span> vector&lt;<span class="type">string</span>&gt; charmap &#123;<span class="string">" "</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="type">void</span> dfs(<span class="type">string</span>&amp; digits, <span class="type">int</span> start, <span class="type">string</span> path, vector&lt;<span class="type">string</span>&gt;&amp; <span class="literal">result</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == digits.size())&#123;</span><br><span class="line">            <span class="literal">result</span>.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">auto</span> i : charmap[digits[start] - '<span class="number">0</span>'])</span><br><span class="line">            dfs(digits, start + <span class="number">1</span>, path + i, <span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">string</span>&gt; letterCombinations(<span class="type">string</span> digits) &#123;</span><br><span class="line">        vector&lt;<span class="type">string</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        dfs(digits, <span class="number">0</span>, <span class="string">""</span>, <span class="literal">result</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Remove_Nth_Node_From_End_of_List_[33-5%]_[Medium]"><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="external">Remove Nth Node From End of List [33.5%] [Medium]</a></h3><ul>
<li>题意：给定一个链表，要求删除 从尾部数起 第n个节点，只允许遍历一次。</li>
<li>例子：<br>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</li>
<li>思路 ：快慢指针。快指针先走n + 1个结点，然后快慢指针一起遍历，当快指针到null时，慢指针就指向n前面的点</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Valid_Parentheses_[33-3%]_[Easy]"><a href="https://leetcode.com/problems/valid-parentheses" target="_blank" rel="external">Valid Parentheses [33.3%] [Easy]</a></h3><ul>
<li>题意 ：给定一个仅包含字符’（’，’）’，’{‘，’}’，’[‘和’]’的字符串，确定输入字符串是否有效。</li>
<li>例子 无</li>
<li>思路 ：利用栈，当输入是左括号时，栈中压入对应的右括号；当输入是右括号时，比较栈顶与该右括号是否相同。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; op_stack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>)</span><br><span class="line">                op_stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'&#123;'</span>)</span><br><span class="line">                op_stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>)</span><br><span class="line">                op_stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op_stack.empty() || op_stack.top() != c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                op_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> op_stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Merge_Two_Sorted_Lists_[39-0%]_[Easy]"><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="external">Merge Two Sorted Lists [39.0%] [Easy]</a></h3><ul>
<li>题意 ：合并两个有序链表</li>
<li>例子 无</li>
<li>思路 ：比较两个节点大小，小的节点放入新的链表中</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="keyword">NULL</span> &amp;&amp; l2 != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">NULL</span>) tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Generate_Parentheses_[45-0%]_[Medium]"><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="external">Generate Parentheses [45.0%] [Medium]</a></h3><ul>
<li>题意 ：给定n对括号，写一个函数来生成正确的括号的所有组合。</li>
<li>例子：<br>given n = 3, a solution set is:[“((()))”, “(()())”, “(())()”, “()(())”, “()()()”]</li>
<li>思路 ：回溯</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; path, <span class="built_in">string</span> str, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.size() == max * <span class="number">2</span>)&#123;</span><br><span class="line">            path.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open &lt; max)</span><br><span class="line">            backtrack(path, str+<span class="string">"("</span>, open+<span class="number">1</span>, close, max);</span><br><span class="line">        <span class="keyword">if</span>(close &lt; open)</span><br><span class="line">            backtrack(path, str+<span class="string">")"</span>, open, close+<span class="number">1</span>, max);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path;</span><br><span class="line">        backtrack(path, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>Two Sum ：从数组中找到两个数相加和为目标值</li>
<li>Add Two Numbers ：将两个链表表示的数相加</li>
<li>Longest Substring Without Repeating Characters ：没有重复元素的最长子]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++虚函数的的实现]]></title>
    <link href="http://geekzph.github.io/2017/08/06/C-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://geekzph.github.io/2017/08/06/C-虚函数的的实现/</id>
    <published>2017-08-06T15:50:42.000Z</published>
    <updated>2017-08-24T01:50:26.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="虚函数" scheme="http://geekzph.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="C++" scheme="http://geekzph.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不得不知的Linux命令]]></title>
    <link href="http://geekzph.github.io/2017/08/06/%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E7%9A%84Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://geekzph.github.io/2017/08/06/不得不知的Linux命令/</id>
    <published>2017-08-06T15:50:18.000Z</published>
    <updated>2017-08-24T01:49:55.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="命令" scheme="http://geekzph.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://geekzph.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP协议那些事儿]]></title>
    <link href="http://geekzph.github.io/2017/08/06/TCP%E5%8D%8F%E8%AE%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://geekzph.github.io/2017/08/06/TCP协议那些事儿/</id>
    <published>2017-08-06T15:49:52.000Z</published>
    <updated>2017-08-24T01:50:37.000Z</updated>
    <content type="html"><![CDATA[<p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看W.Richard Stevens的《TCP/IP 详解 卷1：协议》（当然，你也可以去读一下RFC793以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p>
<p>之所以想写这篇文章，目的有三个，</p>
<p>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。<br>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。<br>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。<br>所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。</p>
<p>我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<p>上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。<br>下篇中，重点介绍TCP的流迭、拥塞处理。<br>废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<p>TCP头格式<br>接下来，我们来看一下TCP头的格式</p>
<p>TCP头格式（图片来源）</p>
<p>你需要注意这么几点：</p>
<p>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。<br>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。<br>注意上图中的四个非常重要的东西：<br>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。<br>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。<br>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。<br>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。<br>关于其它的东西，可以参看下面的图示</p>
<p>（图片来源）</p>
<p>TCP的状态机<br>其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“TCP协议的状态机”（图片来源） 和 “TCP建链接”、“TCP断链接”、“传数据” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）</p>
<p>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<p>对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。<br>对于4次挥手，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</p>
<p>两端同时断连接（图片来源）</p>
<p>另外，有几个事情需要注意一下：</p>
<p>关于建连接时SYN超时。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。<br>关于SYN Flood攻击。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。<br>关于ISN的初始化。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – Wikipedia语条），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。<br>关于 MSL 和 TIME_WAIT。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》<br>关于TIME_WAIT数量太多。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫tcp_tw_reuse，另一个叫tcp_tw_recycle的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“It should not be changed without advice/request of technical experts”）。<br>关于tcp_tw_reuse。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下tcp_twsk_unique的源码 ）。我个人估计还是有一些场景会有问题。<br>关于tcp_tw_recycle。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 tcp_timewait_state_process）。<br>关于tcp_max_tw_buckets。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。<br>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（RFC 1122） </p>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个HTTP的KeepAlive有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<p>数据传输中的Sequence Number<br>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）</p>
<p>你可以看到，SeqNum的增加是和传输的字节数相关的。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p>注意：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<p>TCP重传机制<br>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<p>超时重传机制</p>
<p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<p>一种是仅重传timeout的包。也就是第3份数据。<br>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。<br>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<p>快速重传机制</p>
<p>于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p>
<p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<p>SACK 方法</p>
<p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》</p>
<p>Duplicate SACK – 重复收到数据的问题</p>
<p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。RFC-2883 里有详细描述和示例。下面举几个例子（来源于RFC-2883）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<p>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK<br>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK<br>示例一：ACK丢包</p>
<p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>Transmitted  Received    ACK Sent<br>Segment      Segment     (Including SACK Blocks)</p>
<p>3000-3499    3000-3499   3500 (ACK dropped)<br>3500-3999    3500-3999   4000 (ACK dropped)</p>
<h2 id="3000-3499_3000-3499_4000,_SACK=3000-3500">3000-3499    3000-3499   4000, SACK=3000-3500</h2><p> 示例二，网络延误</p>
<p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>Transmitted    Received    ACK Sent<br>Segment        Segment     (Including SACK Blocks)</p>
<p>500-999        500-999     1000<br>1000-1499      (delayed)<br>1500-1999      1500-1999   1000, SACK=1500-2000<br>2000-2499      2000-2499   1000, SACK=1500-2500<br>2500-2999      2500-2999   1000, SACK=1500-3000<br>1000-1499      1000-1499   3000</p>
<pre><code><span class="number">1000</span>-<span class="number">1499</span>   <span class="number">3000</span>, SACK=<span class="number">1000</span>-<span class="number">1500</span>
                       ---------
</code></pre><p>可见，引入了D-SACK，有这么几个好处：</p>
<p>1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p>
<p>2）是不是自己的timeout太小了，导致重传。</p>
<p>3）网络上出现了先发的包后到的情况（又称reordering）</p>
<p>4）网络上是不是把我的数据包给复制了。</p>
<p> 知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。</p>
<p>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看W.Richard Stevens的《TCP/IP 详解 卷1：协议》（]]>
    </summary>
    
      <category term="TCP" scheme="http://geekzph.github.io/tags/TCP/"/>
    
      <category term="网络" scheme="http://geekzph.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高频题目]]></title>
    <link href="http://geekzph.github.io/2017/08/06/%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE/"/>
    <id>http://geekzph.github.io/2017/08/06/高频题目/</id>
    <published>2017-08-06T15:48:57.000Z</published>
    <updated>2017-08-24T01:50:09.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[链表]]></title>
    <link href="http://geekzph.github.io/2017/08/05/%E9%93%BE%E8%A1%A8/"/>
    <id>http://geekzph.github.io/2017/08/05/链表/</id>
    <published>2017-08-05T13:00:25.000Z</published>
    <updated>2017-08-24T01:50:20.000Z</updated>
    <content type="html"><![CDATA[<p>Remove Duplicates from Sorted List<br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="external">https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/</a></p>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.<br>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node-&gt;next != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;val == node-&gt;next-&gt;val)&#123;</span><br><span class="line">                node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Remove Duplicates from Sorted List II<br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="external">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/</a><br>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.<br>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class <span class="constant">Solution </span>&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    <span class="constant">ListNode*</span> deleteDuplicates(<span class="constant">ListNode*</span> head) &#123;</span><br><span class="line">        if(head == <span class="constant">NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="constant">NULL;</span></span><br><span class="line">        <span class="constant">ListNode*</span> dummy = (<span class="constant">ListNode*</span>)malloc(sizeof(<span class="constant">ListNode)</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line">        head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;<span class="keyword">next</span> != <span class="constant">NULL </span>&amp;&amp; head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> != <span class="constant">NULL)</span>&#123;</span><br><span class="line">            if(head-&gt;<span class="keyword">next</span>-&gt;val == head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>-&gt;val)&#123;</span><br><span class="line">                int val = head-&gt;<span class="keyword">next</span>-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(head-&gt;<span class="keyword">next</span> != <span class="constant">NULL </span>&amp;&amp; head-&gt;<span class="keyword">next</span>-&gt;val == val)&#123;</span><br><span class="line">                    head-&gt;<span class="keyword">next</span> = head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                head = head-&gt;<span class="keyword">next</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Reverse Linked List<br><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="external">https://leetcode.com/problems/reverse-linked-list/description/</a><br>Reverse a singly linked list.</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = head-&gt;<span class="keyword">next</span>;</span><br><span class="line">            head-&gt;<span class="keyword">next</span> = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Reverse Linked List II<br><a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="external">https://leetcode.com/problems/reverse-linked-list-ii/description/</a><br>Reverse a linked list from position m to n. Do it in-place and in one-pass.<br>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,<br>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.<br>Note:<br>Given m, n satisfy the following condition:<br>1 ? m ? n ? length of list.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Partition List<br><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="external">https://leetcode.com/problems/partition-list/description/</a><br>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.<br>You should preserve the original relative order of the nodes in each of the two partitions.<br>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* partition(ListNode* head, <span class="keyword">int</span> x) &#123;</span><br><span class="line">        ListNode *leftDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *rightDummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *leftTail = leftDummy;</span><br><span class="line">        ListNode *rightTail = rightDummy;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                leftTail-&gt;next = head;</span><br><span class="line">                leftTail = head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rightTail-&gt;next = head;</span><br><span class="line">                rightTail = head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        leftTail-&gt;next = rightDummy-&gt;next;</span><br><span class="line">        rightTail-&gt;next = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftDummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Remove Linked List Elements<br><a href="https://leetcode.com/problems/remove-linked-list-elements/description/" target="_blank" rel="external">https://leetcode.com/problems/remove-linked-list-elements/description/</a><br>Remove all elements from a linked list of integers that have value val.<br>Example<br>Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6<br>Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5<br>Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="constant">Solution </span>&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    <span class="constant">ListNode*</span> removeElements(<span class="constant">ListNode*</span> head, int val) &#123;</span><br><span class="line">        <span class="regexp">//if</span>(head == <span class="constant">NULL)</span> <span class="keyword">return</span> <span class="constant">NULL;</span></span><br><span class="line">        <span class="constant">ListNode </span>*dummy = new <span class="constant">ListNode(</span><span class="number">0</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line">        head = dummy;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;<span class="keyword">next</span> != <span class="constant">NULL)</span>&#123;</span><br><span class="line">            if(head-&gt;<span class="keyword">next</span>-&gt;val == val)&#123;</span><br><span class="line">                head-&gt;<span class="keyword">next</span> = head-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            head = head-&gt;<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Merge Two Sorted Lists<br><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="external">https://leetcode.com/problems/merge-two-sorted-lists/description/</a><br>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *tmp = dummy;</span><br><span class="line">		<span class="keyword">while</span> (l1 != <span class="keyword">NULL</span> &amp;&amp; l2 != <span class="keyword">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                tmp-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">NULL</span>) tmp-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> tmp-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Merge k Sorted Lists<br><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="external">https://leetcode.com/problems/merge-k-sorted-lists/description/</a><br>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Sort List<br><a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="external">https://leetcode.com/problems/sort-list/description/</a><br>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>merge sort<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>quick sort</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Reorder List<br>Find the Middle of Linked List<br>Remove Nth Node<br>Linked List Cycle<br>Copy List with Random Pointer<br>Convert Sorted List to Balanced Binary Search Tree<br>Convert Array to Balanced Binary Search Tree</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Remove Duplicates from Sorted List<br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_bl]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二分搜索]]></title>
    <link href="http://geekzph.github.io/2017/08/05/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <id>http://geekzph.github.io/2017/08/05/二分搜索/</id>
    <published>2017-08-05T08:22:24.000Z</published>
    <updated>2017-08-24T01:50:03.000Z</updated>
    <content type="html"><![CDATA[<p>Classical Binary Search<br><a href="http://www.lintcode.com/en/problem/classical-binary-search/" target="_blank" rel="external">http://www.lintcode.com/en/problem/classical-binary-search/</a><br>Description:Find any position of a target number in a sorted array. Return -1 if target does not exist.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    /**</span><br><span class="line">     * @param A an <span class="type">integer</span> array sorted <span class="type">in</span> ascending order</span><br><span class="line">     * @param <span class="type">target</span> an <span class="type">integer</span></span><br><span class="line">     * @<span class="keyword">return</span> an <span class="type">integer</span></span><br><span class="line">     */</span><br><span class="line">    <span class="built_in">int</span> findPosition(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        // <span class="built_in">Write</span> your code here</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>First Position of Target<br><a href="http://www.lintcode.com/en/problem/first-position-of-target/#" target="_blank" rel="external">http://www.lintcode.com/en/problem/first-position-of-target/#</a><br>For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.<br>If the target number does not exist in the array, return -1.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    /**</span><br><span class="line">     * @param nums: The <span class="type">integer</span> array.</span><br><span class="line">     * @param <span class="type">target</span>: <span class="type">Target</span> <span class="keyword">number</span> to find.</span><br><span class="line">     * @<span class="keyword">return</span>: The first <span class="keyword">position</span> of <span class="type">target</span>. <span class="keyword">Position</span> starts from <span class="number">0.</span> </span><br><span class="line">     */</span><br><span class="line">    <span class="built_in">int</span> binarySearch(vector&lt;<span class="built_in">int</span>&gt; &amp;nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        // <span class="built_in">write</span> your code here</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search a 2D Matrix<br><a href="https://leetcode.com/problems/search-a-2d-matrix/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-a-2d-matrix/#/description</a><br>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty() || <span class="built_in">array</span>[<span class="number">0</span>].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid  = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[mid][<span class="number">0</span>] == target)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[mid][<span class="number">0</span>] &lt; target)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[end][<span class="number">0</span>] &lt;= target)</span><br><span class="line">            index = end;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[start][<span class="number">0</span>] &lt;= target)</span><br><span class="line">            index = start;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid  = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[index][mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[index][mid] &lt; target)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[index][start] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[index][end] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> Search Insert Position<br> <a href="https://leetcode.com/problems/search-insert-position/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-insert-position/#/description</a></p>
<p> Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.<br>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> searchInsert(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        // <span class="built_in">Write</span> your code here</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &gt;= <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] &gt;= <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Find Minimum in Rotated Sorted Array<br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="external">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/</a><br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>Find the minimum element.<br>You may assume no duplicate exists in the array.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findMin(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="type">target</span> = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid  = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt;= <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &lt;= <span class="type">target</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="keyword">end</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search in Rotated Sorted Array<br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-in-rotated-sorted-array/#/description</a><br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>You are given a target value to search. If found in the array return its index, otherwise return -1.<br>You may assume no duplicate exists in the array.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> search(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid =  start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[start] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">target</span> &lt;= nums[mid] &amp;&amp; <span class="type">target</span> &gt;= nums[start])</span><br><span class="line">                    <span class="keyword">end</span> = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">target</span> &lt;= nums[<span class="keyword">end</span>] &amp;&amp; <span class="type">target</span> &gt;= nums[mid])</span><br><span class="line">                    start = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">end</span> = mid;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>) <span class="keyword">return</span> <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search in Rotated Sorted Array II<br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>Write a function to determine if a given target is in the array.<br>The array may contain duplicates.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Sqrt(x)<br><a href="https://leetcode.com/problems/sqrtx/#/description" target="_blank" rel="external">https://leetcode.com/problems/sqrtx/#/description</a><br>Implement int sqrt(int x).<br>Compute and return the square root of x.<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> mySqrt(<span class="built_in">int</span> x) &#123;</span><br><span class="line">        long start = <span class="number">1</span>, <span class="keyword">end</span> = x;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            long <span class="built_in">mid</span> = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">mid</span> * <span class="built_in">mid</span> &lt; x)</span><br><span class="line">                start = <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = <span class="built_in">mid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">end</span> * <span class="keyword">end</span> &lt;= x)</span><br><span class="line">            return (<span class="built_in">int</span>)<span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            return (<span class="built_in">int</span>)start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>First Bad Version<br><a href="https://leetcode.com/problems/first-bad-version/#/description" target="_blank" rel="external">https://leetcode.com/problems/first-bad-version/#/description</a></p>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.<br>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.<br>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="keyword">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))</span><br><span class="line">                end = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(start))</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Wood Cut<br><a href="http://www.lintcode.com/en/problem/wood-cut/" target="_blank" rel="external">http://www.lintcode.com/en/problem/wood-cut/</a><br>Given n pieces of wood with length L[i] (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L &amp; k, return the maximum length of the small pieces.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** </span><br><span class="line">     *@param L: Given n pieces of wood with length L[i]</span><br><span class="line">     *@param k: An integer</span><br><span class="line">     *return: The maximum length of the small pieces.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>  <span class="title">ok</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L, <span class="keyword">int</span> mid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mid) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = L.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt += L[i] / mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">woodCut</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span> l =<span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = L.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            r = max(r, L[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (ok(L, mid, k)) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; </span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Find Peak Element<br><a href="https://leetcode.com/problems/find-peak-element/#/description" target="_blank" rel="external">https://leetcode.com/problems/find-peak-element/#/description</a><br>A peak element is an element that is greater than its neighbors.<br>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.<br>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br>You may imagine that num[-1] = num[n] = -∞.<br>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> findPeakElement(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="literal">empty</span>()) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">mid</span> = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &lt; nums[<span class="built_in">mid</span> - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">end</span> = <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">mid</span>] &gt; nums[<span class="built_in">mid</span> - <span class="number">1</span>])</span><br><span class="line">                start = <span class="built_in">mid</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = <span class="built_in">mid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &lt; nums[<span class="keyword">end</span>])</span><br><span class="line">            return <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            return start;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Search for a Range<br><a href="https://leetcode.com/problems/search-for-a-range/#/description" target="_blank" rel="external">https://leetcode.com/problems/search-for-a-range/#/description</a><br>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br>If the target is not found in the array, return [-1, -1].<br>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; searchRange(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="type">target</span>) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; nores;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; res;</span><br><span class="line">        nores.push_back(-<span class="number">1</span>);</span><br><span class="line">        nores.push_back(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> nores;</span><br><span class="line">        <span class="built_in">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(start);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span> = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; <span class="keyword">end</span>)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = start + (<span class="keyword">end</span> - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; <span class="type">target</span>)</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">end</span> = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="keyword">end</span>] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] == <span class="type">target</span>)</span><br><span class="line">            res.push_back(start);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            res.push_back(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Count of Smaller Numbers After Self<br><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/#/description" target="_blank" rel="external">https://leetcode.com/problems/count-of-smaller-numbers-after-self/#/description</a></p>
<p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].<br>Example:<br>Given nums = [5, 2, 6, 1]<br>To the right of 5 there are 2 smaller elements (2 and 1).<br>To the right of 2 there is only 1 smaller element (1).<br>To the right of 6 there is 1 smaller element (1).<br>To the right of 1 there is 0 smaller element.<br>Return the array [2, 1, 1, 0].</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Recover Rotated Sorted Array<br><a href="http://www.lintcode.com/en/problem/recover-rotated-sorted-array/" target="_blank" rel="external">http://www.lintcode.com/en/problem/recover-rotated-sorted-array/</a><br>Given a rotated sorted array, recover it to sorted array in-place.<br>Have you met this question in a real interview? Yes<br>Clarification<br>What is rotated array?<br>For example, the orginal array is [1,2,3,4], The rotated array of it can be [1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]<br>Example<br>[4, 5, 1, 2, 3] -&gt; [1, 2, 3, 4, 5]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Roate String<br><a href="http://www.lintcode.com/en/problem/rotate-string/" target="_blank" rel="external">http://www.lintcode.com/en/problem/rotate-string/</a><br>Given a string and an offset, rotate string by offset. (rotate from left to right)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Classical Binary Search<br><a href="http://www.lintcode.com/en/problem/classical-binary-search/" target="_blank" rel="external">http://ww]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[进程间通信概述]]></title>
    <link href="http://geekzph.github.io/2017/07/05/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0/"/>
    <id>http://geekzph.github.io/2017/07/05/进程间通信概述/</id>
    <published>2017-07-05T11:49:33.000Z</published>
    <updated>2017-08-24T01:52:05.000Z</updated>
    <content type="html"><![CDATA[<p>进程间通信概述</p>
<p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间<br>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。<br>通知时间：一个进程需要向另一个或一组进程发送消息，通知他们发生了某些事件（如进程终止时要通知父进程）<br>资源共享：多个进程之间共享同样的资源，为了做到这一点，需要内核提供锁和同步机制<br>进程控制：有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入的异常，并能够及时指导它的状态改变。<br>进程间通信方式</p>
<p>管道(pipe)，有名管道(FIFO)<br>信号(signal)<br>共享内存(shared memory)<br>消息队列(message queue)<br>信号量(semaphore)<br>套接字(socket)<br>管道</p>
<p>管道针对本地计算机的两个进程之间的通信而设计的通信方式，管道建立后，实际获得两个文件描述符：一个用于读取另一个用于写入。<br>常见的IPC机制，通过pipe系统调用。<br>管道单工，数据只能向一个方向流动。双向通信时，需要建立两个管道。<br>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道的缓冲区的尾部，每次都是从缓冲区的头部读出数据。<br>管道的分类</p>
<p>匿名管道<br>关系进程，父子或兄弟<br>由pipe系统调用，管道由父进程建立<br>管道位于内核空间，其实是一块缓存<br>有名管道（FIFO）<br>两个没有任何关系的进程之间通信可通过有名管道进行数据传输<br>通过系统调用mkfifo创建<br>管道创建</p>
<p>#include<unistd.h><br>int pipe(int fd[2]);<br>//返回：0成功，-1出错<br>两个文件描述符数组<br>fd[0]:pipe的读端<br>fd[1]:pipe的写端<br>共享内存</unistd.h></p>
<p>共享内存区域是被多个进程共享的一部分物理内存。<br>多个进程都可以把共享内存映射到自己的虚拟空间。所有用户空间的进程要操作共享内存，都要将其映射到自己的虚拟空间，通过映射的虚拟内存空间地址去操作共享内存，从而达到进程间的数据通信。<br>共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容<br>本身不提供同步机制，可通过信号量进行同步<br>提升数据处理效率，一种效率最高的IPC机制<br>共享内存属性信息</p>
<p>struct shmid_ds{<br>    struct ipc_perm shm_perm;<br>    size_t shm_semsz;//共享内存大小<br>    pid_t shm_lpid;//最后一次调用系统pid<br>    pid_t shm_cpid;//pid的创建者的id<br>    shmatt_t shm_nattch;//和共享内存成功映射的数量<br>    time_t shm_atime;//最后一个成功映射的时间<br>    time_t shm_dtime;//最后断开映射的时间<br>    time_t shm_ctime;//最后改变的时间<br>}<br>共享内存使用步骤</p>
<p>使用shmget()函数创建共享内存<br>使用shmat()函数映射共享内存，将这段创建的共享内存映射到具体的进程虚拟内存空间<br>创建共享内存</p>
<p>#include <sys shm.h=""><br>itn shmget(key_t key,size_t size,int shmflag);<br>//返回，成功返回内核中共享内存的表示iD，失败返回-1.<br>参数<br>key:用户指定的共享内存键值<br>size:共享内存大小<br>shmflg:IPC_CREAT,IPC_EXCL等权限组合<br>erron<br>EINVAL(无效的内存段大小)<br>EEXIST(内存段已经存在，无法创建)<br>EIDRM(内存段已经被删除)<br>ENOENT(内存段不存在)<br>EACCES(权限不够)<br>ENOMEM(没有足够内存创建内存段)<br>共享内存控制</sys></p>
<p>#include<sys shm.h=""><br>int shmctl(int shmid,int cmd,struct shmid_ds *buf);<br>参数<br>shmid:共享内存ID<br>buf:共享内存属性指针<br>cmd<br>IPC_STAT 获取共享内存段属性<br>IPC_SET 设置共享内存段属性<br>IPC_RMID 删除共享内存段<br>SHM_LOCK 锁定共享内存段页面<br>SHM_UNLOCK 解锁锁定<br>共享内存映射和解除</sys></p>
<p>#include<sys shm.h=""><br>void shmat(int shmid,char <em>shmaddr,int shmflg);<br>int shmdt(char  </em>shmaddr);<br>//失败返回-1<br>参数<br>shmid:共享内存ID<br>shmaddr:映射到进程虚拟内存空间的地址，系统自动分配<br>shmflg:弱shmaddr为0，shmflag也是0<br>SHM_RND<br>SHMLBA 地址为2的次方<br>SHM_RDONLY 只读方式连接<br>errno<br>EINVAL 无效的IPC ID值或无效的地址<br>ENOMEM 没有足够的内存<br>EACCES 权限不够<br>子进程不继承父进程创建的共享内存，大家是共享的，子进程继承父进程映射的地址。<br>消息队列</sys></p>
<p>消息队列是内核中的一个链表<br>用户进程将数据传输到内核后，内核重新添加一些如用户ID、组ID、读写进程的ID和优先级等相关信息后并打包成一个数据包称为消息<br>允许一个或多个进程往消息队列中读写消息，但一个消息只能被一个进程读取，读取完毕后自动删除<br>消息队列具有一定的FIFO的特性，消息可以按照顺序发送到队列中，也可以几种不同的方式从队列中读取。每一个消息队列在内核中用一个唯一的IPC标识ID表示<br>消息队列的实现包括创建和打开队列、发送消息、读取消息和控制消息队列四种操作。<br>消息队列属性</p>
<p>struct msqid_ds<br>{<br>    struct ipc_perm msg_perm;<br>    msgqnum_t msg_qnum; //消息数量<br>    msglen_t msg_qbytes; //消息最大字节数<br>    pid_t msg_lspid; //最后一次发送消息进程的pid<br>    pid_t msg_lrpid; //最后一次接收消息的pid<br>    pid_t msg_stime; //最后一次消息发送的时间<br>    pid_t msg_ctime; //最后一次消息改变的时间<br>}；<br>打开或创建消息队列</p>
<p>#include <sys msg.h=""><br>int msgget(key_t key,int flag);<br>//返回：如果成功，返回内核中消息队列的标识ID，出错返回-1<br>参数<br>key:用户指定的消息队列键值<br>flag:IPC CREAT,IPC EXCL等权限组合<br>若创建消息队列，key可以指定键值，也可以设置为IPC_PRIVATE(0)。若打开进行查询，则key不能为0，必须是一个非零的值，否则查询不到<br>消息队列控制</sys></p>
<p>#include <sys msg.h=""><br>int msgctl(int msgid,int cmd,struct msqid_ds *buf);<br>//返回：成功返回0,出错返回-1<br>参数<br>msgid：消息队列ID<br>buf：消息队列属性指针<br>cmd<br>IPC_STAT：获取消息队列的属性，取此队列的msqid_ds结构，并放在buf指向的结构中<br>IPC_SET：设置属性，按由buf只想的结构中的值，设置与此队列相关的结构中的字段<br>IPC_RMID：删除队列，从系统中删除该队列以及在队列上的所有数据。<br>发送消息</sys></p>
<p>#include <sys msg.h=""><br>int msgsnd(int msgqid,const void *ptr,size_t nbytes,int flag);<br>//成功返回0,出错返回-1</sys></p>
<p>ptr:<br>struct mymesg<br>{<br>    long mtype;//消息类型<br>    char mtext[512];//消息数据本身<br>};<br>nbytes 指定消息的大小，不包括mtype的大小<br>mtype指消息的类型，由一个整数来表示，且大于0<br>mtext消息数据本身<br>在Linux中，消息的最大长度是4056个字节，其中包括mtype，占4个字节<br>结构体mymesg用户可自定义，但第一个成员必须是mtype<br>参数flag<br>0：阻塞<br>IPC_NOWAIT:类似文件I/O的非阻塞<br>若消息队列满（或者是队列中的消息总数等于系统限制值，或队列中的字节数等于系统限制值），则指定IPC_NOWAIT使得msgsnd立即出错返回EAGAIN。如果指定0，则<br>阻塞直到有空间可以容纳要发送的消息<br>或从系统中删除了此队列<br>或捕捉到一个信号，并从信号处理程序返回<br>接收消息</p>
<p>#include <sys msg.h=""><br>ssize_t msgrcv(int msgqid,void *ptr,size_t nbytes,long type,int flag);<br>//成功返回消息数据部分的长度，出错返回-1<br>参数<br>magqid：消息队列的ID<br>ptr：指向存放消息的缓存<br>nbytes：消息缓存的大小，不包括mtype的大小。计算方式<br>nbytes=sizeof(struct mymesg)-sizeof(long)<br>type：消息类型<br>type==0：获得消息队列中的第一个消息<br>type&gt;0：获得消息队列中类型type的第一个消息<br>type&lt;0：获得消息队列中小于或等于type绝对值的消息<br>flag：0或者IPC_NOWAIT<br>信号量</sys></p>
<p>本质上是共享资源的数目，用来控制对共享资源的访问。<br>用于进程间的互斥和同步<br>每种恭喜那个资源对应一个信号量，为了便于大量共享资源的操作引入了信号量集，可对多有信号量一次性操作。对信号量集中所有的操作可以要求全部成功，也可以部分成功<br>二元信号量(信号灯)值为0和1<br>对信号量做PV操作<br>信号量集属性</p>
<p>#include<sysm.h></sysm.h></p>
<p>struct semid_ds<br>{<br>    struct ipc_perm sem_perm;<br>    unsigned short sem_nseme; //信号灯的数量<br>    time_t sem_otime; //最后一次操作的时间<br>    time_t sem_ctime; //最后一次改变的时间<br>};<br>创建信号量集</p>
<p>#include <sysm.h><br>int semget(key_t key,int nsems,int flag);<br>//返回：如果成功，返回信号量集ID，出错返回-1<br>参数<br>key:用户指定的信号量集键值<br>nsems:信号量集中信号量的个数<br>flag:IPC CREAT,IPC EXCL等权限组合<br>若创建消息队列，key可以指定键值，也可以设置为IPC_PRIVATE(0)。若打开进行查询，则key不能为0，必须是一个非零的值，否则查询不到<br>信号量集控制</sysm.h></p>
<p>#include <sys msg.h=""><br>int semctl(int semid,int semnum,int cmd,…//信号量集数组);<br>//返回：成功返回0,出错返回-1<br>union semun<br>{<br>    int val;<br>    struct semid_ds <em>buf;<br>    unsigned short </em>array;<br>}<br>参数<br>semid：信号量集ID<br>semnum：0表示对所有信号量操作，信号量标号从0开始。<br>val：防止获取或设置信号量集中某个信号量的值<br>buf：信号量属性指针<br>array：防止获取或设置信号量集中所有信号量的值<br>cmd<br>IPC_STAT：获取信号量的属性，取此队列的semid_ds结构，并放在buf指向的结构中<br>IPC_SET：设置属性，按由buf只想的结构中的值，设置与此信号量相关的结构中的字段<br>IPC_RMID：删除信号量，从系统中删除该信号量以及信号量上的所有数据。<br>信号量集操作</sys></p>
<p>#include<sysm.h><br>int semop(int semid,struct sembuf *sops,size_t nsops);<br>//成功返回0，失败返回-1</sysm.h></p>
<p>struct sembuf<br>{<br>    unsigned short sem_num; //信号量集标号<br>    short sem_op; //操作<br>    short sem_flg; //<br>}<br>参数<br>semid：信号量集ID<br>sops：sembuf结构体数组指针<br>nsops：第二个参数中结构体数组的长度<br>sem_num：信号量集中信号量的编号<br>sep_op：正数为v操作，负数为p操作，0表示对共享资源是否已用完的测试<br>sem_flg：SEM_UNDO标志，表示进程结束时，相应的操作将被取消，如果设置了该标志，那么在进程没有释放共享资源就退出时，内核将代为释放。<br>用于信号量集中信号量的PV操作<br>可用于进程见的互斥和同步</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>进程间通信概述</p>
<p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间<br>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。<br>通知时间：一个进程需要向另一个或一组进程发送消息，通知他们]]>
    </summary>
    
      <category term="IPC" scheme="http://geekzph.github.io/tags/IPC/"/>
    
      <category term="Linux" scheme="http://geekzph.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python并发编程之Gevent]]></title>
    <link href="http://geekzph.github.io/2017/07/03/Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BGevent/"/>
    <id>http://geekzph.github.io/2017/07/03/Python并发编程之Gevent/</id>
    <published>2017-07-03T11:57:20.000Z</published>
    <updated>2017-08-24T01:52:10.000Z</updated>
    <content type="html"><![CDATA[<p>##Gevent<br>gevent是一个基于libev的并发库。它为各种并发和网络相关的任务提供了整洁的API。,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效。</p>
<p>在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<blockquote>
<p>在任何时刻，只有一个协程在运行。</p>
</blockquote>
<p>这与multiprocessing或threading等提供真正并行构造的库是不同的。 这些库轮转使用操作系统调度的进程和线程，是真正的并行。</p>
<p>gevent 是基于 greenlet 的一个 python 库，它可以把 python 的内置线程用 greenlet 包装，这样在我们使用线程的时候，实际上使用的是协程，在上一个协程的例子里，协程 A 结束时，由协程 A 让位给协程 B ，而在 gevent 里，所有需要让位的协程都让位给主协程，由主协程决定运行哪一个协程，gevent 也会包装一些可能需要阻塞的方法，比如 sleep ，比如读 socket ，比如等待锁，等等，在这些方法里会自动让位给主协程，而不是由程序员显示让位，这样程序员就可以按照线程的模式进行线性编程，不需要考虑切换的逻辑。</p>
<p>##协程<br>要理解Gevent首先要理解协程，进程，线程，协程定义如下：</p>
<ul>
<li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</li>
<li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</li>
<li>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</li>
</ul>
<p>协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。</p>
<p>协程的本质上是：</p>
<blockquote>
<p>allowing multiple entry points for suspending and resuming execution at certain locations.<br>允许多个入口对程序进行挂起、继续执行等操作</p>
</blockquote>
<p>协程就是一种特殊的并发机制，其调度[就是指什么时候调用什么函数]完全由程序员指定，比如下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump_range</span><span class="params">(upper)</span>:</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; upper:</span><br><span class="line">        jump = <span class="keyword">yield</span> index</span><br><span class="line">        <span class="keyword">if</span> jump <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            jump = <span class="number">1</span></span><br><span class="line">        index += jump</span><br><span class="line">jump = jump_range(<span class="number">5</span>)</span><br><span class="line">print(jump)</span><br><span class="line">print(jump.send(<span class="keyword">None</span>))</span><br><span class="line">print(jump.send(<span class="number">3</span>))</span><br><span class="line">print(jump.send(<span class="keyword">None</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;generator object jump_range at <span class="number">0x10e283518</span>&gt;</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>jump_range函数在执行的过程中终端，又继续了好几次，这就是协程。这有类似线程的context-switch，那么协程的好处在哪呢？</p>
<ul>
<li>thread之間需要context-switch，而且成本很高，但是coroutine之間的切換很快</li>
<li>coroutine的成本很低，可以很輕易的產生大量的coroutine</li>
<li>這些事情全是在同一個thread裡發生的，因此不會有race condition等問題發生 (還是可能會有)</li>
<li>thread的context-switch雖然我們可以進行某種程度的控制，但是很多部份還是得靠OS來決定要先排程哪個thread，而coroutine的執行是由我們自己控制的。</li>
</ul>
<p>下面两幅图说明他们的区别：</p>
<p>协程的本质就是在单一线程里的协程互相切换，因此也被成为微线程。协程适合于I/O密集型的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Copyright (c) 2009 Denis Bilenko. See LICENSE for details.</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""Spawn multiple workers and wait for them to complete"""</span></span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'http://www.google.com'</span>, <span class="string">'http://www.yandex.ru'</span>, <span class="string">'http://www.python.org'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># patches stdlib (including socket and ssl modules) to cooperate with other greenlets</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_head</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Starting %s'</span> % url</span><br><span class="line">    data = urllib2.urlopen(url).read()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s: %s bytes: %r'</span> % (url, len(data), data[:<span class="number">50</span>])</span><br><span class="line"></span><br><span class="line">jobs = [gevent.spawn(print_head, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">gevent.joinall(jobs)</span><br></pre></td></tr></table></figure>
<p>monkey.patch_all()，會有這行，是因為Python內建的各種函式庫裡的IO函式庫、及會阻塞住的函數，例如Sleep都會讓整個程式卡住，而不是利用Selector/epoll之類的功能來處理，所以monkey這個函式庫就是負責將Python內建的函式庫取代成以gevent的非同步形式的函式，如此一來當執行到那些IO之類的動作，會切到MainThread的coroutine進行排程，而非直接卡在那裡等結果，而當IO動作真的完成了，gevent內部會將該coroutine標示為可執行的，因此下次有機會就會排到那個coroutine，看到下面的spawn，就是在產生coroutine，在這裡的coroutine因為事實上是greenlet這個Python函式庫題供的，所以事實上叫做greenlet，</p>
<p>总结一下：<br>1）多进程能够利用多核优势，但是进程间通信比较麻烦，另外，进程数目的增加会使性能下降，进程切换的成本较高。程序流程复杂度相对I/O多路复用要低。<br>2）I/O多路复用是在一个进程内部处理多个逻辑流程，不用进行进程切换，性能较高，另外流程间共享信息简单。但是无法利用多核优势，另外，程序流程被事件处理切割成一个个小块，程序比较复杂，难于理解。<br>3）线程运行在一个进程内部，由操作系统调度，切换成本较低，另外，他们共享进程的虚拟地址空间，线程间共享信息简单。但是线程安全问题导致线程学习曲线陡峭，而且易出错。<br>4）协程有编程语言提供，由程序员控制进行切换，所以没有线程安全问题，可以用来处理状态机，并发请求等。但是无法利用多核优势。<br>上面的四种方案可以配合使用，我比较看好的是进程+协程的模式。</p>
<p>Reference：</p>
<ul>
<li><a href="http://blog.jobbole.com/77240/" target="_blank" rel="external">python greenlet背景介绍与实现机制</a></li>
<li><a href="http://xlambda.com/gevent-tutorial/" target="_blank" rel="external">gevent程序员指南</a></li>
<li><a href="http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/" target="_blank" rel="external">淺談coroutine與gevent</a></li>
<li><a href="https://segmentfault.com/a/1190000004890674" target="_blank" rel="external">PyTips 0x13 - Python 线程与协程（2）</a></li>
<li><a href="http://litaotao.github.io/python-gevent" target="_blank" rel="external">Python 并发编程之一：Gevent</a></li>
<li><a href="http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html" target="_blank" rel="external">进程、线程和协程的理解</a></li>
<li><a href="http://www.firefoxbug.com/index.php/archives/2750/" target="_blank" rel="external">Python Gevent应用</a></li>
<li><a href="http://blog.rainy.im/2016/03/10/how-the-heck-does-async-await-work-in-python-3-5/" target="_blank" rel="external">Python 3.5 协程究竟是个啥</a></li>
<li><a href="http://pyzh.readthedocs.io/en/latest/the-python-yield-keyword-explained.html" target="_blank" rel="external">Python关键字yield的解释(stackoverflow)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>##Gevent<br>gevent是一个基于libev的并发库。它为各种并发和网络相关的任务提供了整洁的API。,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效。</p>
<p>在gevent中用到的主要模式是Greenlet, 它]]>
    </summary>
    
      <category term="并发" scheme="http://geekzph.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Python" scheme="http://geekzph.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL源码分析之空间配置器]]></title>
    <link href="http://geekzph.github.io/2017/06/30/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://geekzph.github.io/2017/06/30/STL源码分析之空间配置器/</id>
    <published>2017-06-30T15:20:43.000Z</published>
    <updated>2017-08-24T01:52:37.000Z</updated>
    <content type="html"><![CDATA[<p>在内存配置方面，为了避免小型区块所造成的内存破碎问题，STL设计为两级配置器。第一级配置器直接使用malloc()和free(). 第二层配置器有有一个内存池，用一个union obj数组free_list来存储内存的地址，数组的每一个元素都指向一个obj链表，也就是内存链表。数组从小到大表示负责8b,16b,24b,…,120b,128b内存请求。当请求的内存大于128b的时候调用第一级配置器，当请求的内存小于等于128b的时候调用第二级配置器。<br><img src="/images/1.jpg" alt=""></p>
<p>第一级配置器</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line">class __malloc_alloc_template  </span><br><span class="line">&#123;  </span><br><span class="line">private:</span><br><span class="line">	//sfasdf</span><br><span class="line">	//调用malloc函数不成功后调用</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> *oom_malloc(size_t);</span><br><span class="line">	//调用realloc函数不成功后调用 </span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> *oom_realloc(<span class="type">void</span> *, size_t);</span><br><span class="line">	//类似于C++的set_new_handle错误处理函数一样，如果不设置，在内存不足时，返回<span class="type">THROW_BAD_ALLOC</span></span><br><span class="line">	<span class="comment">#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line">		<span class="keyword">static</span> <span class="type">void</span> (* __malloc_alloc_oom_handler)();  </span><br><span class="line">	<span class="comment">#endif  </span></span><br><span class="line">	public:  </span><br><span class="line">	//直接调用malloc来分配内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> * allocate(size_t n)  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> *<span class="literal">result</span> = malloc(n);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == <span class="literal">result</span>) <span class="literal">result</span> = oom_malloc(n);  //如果分配失败，则调用oom_malloc()</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">result</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line"> 	//第一级配置器直接调用free来释放内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> deallocate(<span class="type">void</span> *p, size_t /* n */)  </span><br><span class="line">	&#123; </span><br><span class="line">		free(p); </span><br><span class="line">	&#125;  </span><br><span class="line">	//直接调用reallloc来分配内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> * reallocate(<span class="type">void</span> *p, size_t /* old_sz */, size_t new_sz)  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> * <span class="literal">result</span> = realloc(p, new_sz);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == <span class="literal">result</span>) <span class="literal">result</span> = oom_realloc(p, new_sz);  //如果realloc分配不成功，调用oom_realloc()</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">result</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	//异常处理函数，即内存分配失败后的处理</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> (* set_malloc_handler(<span class="type">void</span> (*f)()))()  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> (* old)() = __malloc_alloc_oom_handler;  </span><br><span class="line">	 __malloc_alloc_oom_handler = f;  </span><br><span class="line">	 <span class="keyword">return</span>(old);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上述源码中可以看到，STL的第一级配置器仅仅是调用了malloc，free等函数，然后增加了内存分配错误下的异常处理函数。下面是内存分配失败时的代码</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 以下是针对内存分配失败后的处理</span><br><span class="line">//首先，将__malloc_alloc_oom_handler的默认值设为<span class="number">0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">#endif  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="type">void</span> *<span class="literal">result</span>;  </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  // 不断地尝试释放、再配置、再释放、再配置</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;  //这里是当没有设置处理函数的时候，直接抛出异常</span><br><span class="line">		(*my_malloc_handler)();   // 调用处理例程，尝试释放内存</span><br><span class="line">		<span class="literal">result</span> = malloc(n);  	  // 再重新分配内存</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span>(<span class="literal">result</span>);  // 如果分配成功则返回指针</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="type">void</span> *p, size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="type">void</span> *<span class="literal">result</span>;  </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  //不断地尝试释放、再配置、再释放、再配置</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; //这里是当没有设置处理函数的时候，直接抛出异常 </span><br><span class="line">		(*my_malloc_handler)();  // 调用处理例程，尝试释放内存</span><br><span class="line">		<span class="literal">result</span> = realloc(p, n);  // 再重新分配内存</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span>(<span class="literal">result</span>);  // 如果分配成功则返回指针</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数，在当内存分配失败时，会不断尝试区内存释放内存，再分配内存，所以再一定程度上提高内存分配成功。</p>
<p>第二级配置器<br>当申请内存小于128b的时候，会调用第二级配置器。第二级配置器有一个内存池和一个对应的自由链表，其定义如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span>  </span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span>  </span><br><span class="line">	char client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述obj所用的是union， 由于是union，从第一个字段看，obj可以视为一个指针，指向相同形式的另一个obj；从第二个字段看，obj可以被视为一个指针，指向实际区块。这样一来，既实现了链表结点只用一个指针的大小空间，却能同时做索引和指向内存区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;   <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;  <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;   <span class="comment">//free-lists个数</span></span><br><span class="line"><span class="comment">//第一参数用于多线程，这里不做讨论。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">class</span> __default_alloc_template  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 此函数将bytes的边界上调至8的倍数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(size_t bytes)</span>  </span><br><span class="line">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN-<span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));  </span><br><span class="line">	&#125;  </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">	<span class="comment">// 此union结构体上面已经解释过了</span></span><br><span class="line">	<span class="keyword">union</span> obj  </span><br><span class="line">	&#123;  </span><br><span class="line">	<span class="keyword">union</span> obj * free_list_link;  </span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="comment">//16个free-lists</span></span><br><span class="line">	<span class="keyword">static</span> obj * __VOLATILE free_list[__NFREELISTS];</span><br><span class="line">	<span class="comment">// 根据待待分配的空间大小, 在free_list中选择合适的大小  </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(size_t bytes)</span>  </span><br><span class="line">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN-<span class="number">1</span>)/__ALIGN - <span class="number">1</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个大小为n的对象，并可能加入大小为n的其它区块到free-lists</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(size_t n)</span></span>;  </span><br><span class="line">	<span class="comment">// 配置一大块空间，可容纳nobjs个大小为“size”的区块</span></span><br><span class="line">	<span class="comment">// 如果配置nobjs个区块有所不便，nobjs可能会降低，所以需要用引用传递</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(size_t size, <span class="keyword">int</span> &amp;nobjs)</span></span>;  </span><br><span class="line">	<span class="comment">// 内存池  </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;      <span class="comment">// 内存池起始点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;        <span class="comment">// 内存池结束点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;      <span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(size_t n)</span></span>;<span class="comment">// 空间配置函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, size_t n)</span></span>; <span class="comment">// 空间释放函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* p, size_t old_sz , size_t new_sz)</span></span>; <span class="comment">//空间重新配置函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一些静态成员变量的初始化</span></span><br><span class="line"><span class="comment">// 内存池起始位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池结束位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池容量索引数组  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * __VOLATILE  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS ] = </span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>
<p>空间配置函数allocate()</p>
<p>下图说明了说明空间配置函数的调用过程：<br><img src="/images/2.jpg" alt=""></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> * allocate(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	obj * volatile * my_free_list;  </span><br><span class="line">	obj * <span class="literal">result</span>;  </span><br><span class="line">	// 大于<span class="number">128</span>就调用第一级配置器</span><br><span class="line">	<span class="keyword">if</span> (n &gt; (size_t) __MAX_BYTES) &#123;  </span><br><span class="line">	 <span class="keyword">return</span>(malloc_alloc::allocate(n));  </span><br><span class="line">	&#125;  </span><br><span class="line">	// 寻找<span class="number">16</span>个free_lists中适当的一个</span><br><span class="line">	my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(n);  </span><br><span class="line">	<span class="literal">result</span> = *my_free_list;  </span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">result</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">		// 如果没有可用的free list，准备重新填充free_list</span><br><span class="line">		<span class="type">void</span> *r = refill(<span class="type">ROUND_UP</span>(n));  </span><br><span class="line">		<span class="keyword">return</span> r;  </span><br><span class="line">	&#125;</span><br><span class="line">	// 调整free list</span><br><span class="line">	*my_free_list = <span class="literal">result</span> -&gt; free_list_link;  </span><br><span class="line">	<span class="keyword">return</span> (<span class="literal">result</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存释放函数deallocate()<br>内存释放函数会将释放的空间交还给free_list以留备用。其过程如下图所示：<br><img src="/images/3.jpg" alt=""></p>
<p>重新填充函数refill()</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> nobjs = <span class="number">20</span>;  //	默认获取<span class="number">20</span>个</span><br><span class="line">	<span class="type">char</span> * chunk = chunk_alloc(n, nobjs);  //找内存池要空间</span><br><span class="line">	obj * volatile * my_free_list;  </span><br><span class="line">	obj * <span class="literal">result</span>;  </span><br><span class="line">	obj * current_obj, * next_obj;  </span><br><span class="line">	<span class="type">int</span> i;  </span><br><span class="line">	// 如果内存池仅仅只够分配一个对象的空间, 直接返回即可  </span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);  </span><br><span class="line">	// 内存池能分配更多的空间，调整free_list纳入新节点</span><br><span class="line">	my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(n);</span><br><span class="line">	// 在chunk的空间中建立free_list  </span><br><span class="line">	<span class="literal">result</span> = (obj *)chunk;</span><br><span class="line">	*my_free_list = next_obj = (obj *)(chunk + n); //导引free_list指向新配置的空间(取自内存池)</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; ; i++) &#123;	//从<span class="number">1</span>开始，因为第<span class="number">0</span>个返回给客端</span><br><span class="line">		current_obj = next_obj;  </span><br><span class="line">		next_obj = (obj *)((<span class="type">char</span> *)next_obj + n);  </span><br><span class="line">		<span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = next_obj;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span>(<span class="literal">result</span>);//返回头指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存池函数chunk_alloc()</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">char</span>*  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, <span class="type">int</span>&amp; nobjs)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> * <span class="literal">result</span>;  </span><br><span class="line">    size_t total_bytes = size * nobjs;  </span><br><span class="line">    size_t bytes_left = end_free - start_free;  // 计算内存池剩余容量  </span><br><span class="line">   </span><br><span class="line">    //内存池中的剩余空间满足需求 </span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">        <span class="literal">result</span> = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">result</span>);//返回起始地址</span><br><span class="line">    &#125;  </span><br><span class="line">    // 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span><br><span class="line">    // 返回所能分配的最多的节点, 返回start_free指向的内存块  </span><br><span class="line">    // 并且重新设置内存池起始点  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left/size;  </span><br><span class="line">        total_bytes = size * nobjs;  </span><br><span class="line">        <span class="literal">result</span> = start_free;  </span><br><span class="line">        start_free += total_bytes;  </span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">result</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 内存池剩余内存连一个节点也不够分配  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        size_t bytes_to_get = <span class="number">2</span> * total_bytes + <span class="type">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line">        // 将剩余的内存分配给指定的free_list[<span class="type">FREELIST_INDEX</span>(bytes_left)]  </span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        	//内存池内还有一些零头，先分给适当的free_list</span><br><span class="line">        	//寻找适当的free_list</span><br><span class="line">            obj * __VOLATILE * my_free_list =  </span><br><span class="line">                   	free_list + <span class="type">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">            // 调整free_list，将内存池中的残余空间编入 </span><br><span class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </span><br><span class="line">            *my_free_list = (obj *)start_free;  </span><br><span class="line">        &#125;  </span><br><span class="line">        start_free = (<span class="type">char</span> *)malloc(bytes_to_get);  </span><br><span class="line">        // 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;// heap里面空间不足，malloc失败</span><br><span class="line">            <span class="type">int</span> i;  </span><br><span class="line">            obj * __VOLATILE * my_free_list, *p;  </span><br><span class="line">            // 试着检查检查free_list中的可用空间，即尚有未用的空间，且区块够大  </span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </span><br><span class="line">                my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(i);  </span><br><span class="line">                p = *my_free_list;  </span><br><span class="line">                // 找到了一个, 将其加入内存池中  </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;  </span><br><span class="line">                    start_free = (<span class="type">char</span> *)p;  </span><br><span class="line">                    end_free = start_free + i;  </span><br><span class="line">                    // 内存池更新完毕, 重新分配需要的内存  </span><br><span class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">                    //任何剩余零头将被编入适当的free_list以留备用 </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line"> </span><br><span class="line">        // 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助  </span><br><span class="line">        // 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span><br><span class="line">        // 最好直接log, 然后让程序崩溃  </span><br><span class="line">        end_free = <span class="number">0</span>;</span><br><span class="line">        	//调用第一级配置器，看看<span class="keyword">out</span>-<span class="keyword">of</span>-memory机制能不能起点作用</span><br><span class="line">            start_free = (<span class="type">char</span> *)malloc_alloc::allocate(bytes_to_get);  </span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;  </span><br><span class="line">        end_free = start_free + bytes_to_get;  </span><br><span class="line">        // 内存池更新完毕, 重新分配需要的内存  </span><br><span class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用配置器<br>STL两层配置器就分析结束了，接下来看下配置器使如何使用的。<br>vector中使用配置器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc&gt;  <span class="comment">//alloc被默认为第二级配置器</span></span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 专属的空间配置器，每次只分配一个元素的大小</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	<span class="comment">// 在释放内存的时候直接调用借口函数即可</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(...)&#123;</span><br><span class="line">			data_allocator::deallocate(start , end_of_storage - start);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在内存配置方面，为了避免小型区块所造成的内存破碎问题，STL设计为两级配置器。第一级配置器直接使用malloc()和free(). 第二层配置器有有一个内存池，用一个union obj数组free_list来存储内存的地址，数组的每一个元素都指向一个obj链表，也就是内存链]]>
    </summary>
    
      <category term="STL" scheme="http://geekzph.github.io/tags/STL/"/>
    
      <category term="C++" scheme="http://geekzph.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树与分治法]]></title>
    <link href="http://geekzph.github.io/2017/06/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>http://geekzph.github.io/2017/06/30/二叉树与分治法/</id>
    <published>2017-06-30T02:33:46.000Z</published>
    <updated>2017-08-24T01:52:27.000Z</updated>
    <content type="html"><![CDATA[<p>Binary Tree Preorder Traversal<br>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>recursion<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * @param root: <span class="type">The</span> root <span class="keyword">of</span> binary tree.</span><br><span class="line">     * @<span class="keyword">return</span>: <span class="type">Preorder</span> <span class="keyword">in</span> vector which contains node values.</span><br><span class="line">     */</span><br><span class="line">    <span class="type">void</span> traverse(<span class="type">TreeNode</span> *root, vector&lt;<span class="type">int</span>&gt; &amp;res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        traverse(root-&gt;left, res);</span><br><span class="line">        traverse(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preorderTraversal(<span class="type">TreeNode</span> *root) &#123;</span><br><span class="line">        // write your code here</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        traverse(root, <span class="literal">result</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode *root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">stack</span>.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            </span><br><span class="line">            TreeNode *node = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push(node-&gt;left);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Maximum Depth of Binary Tree<br><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/maximum-depth-of-binary-tree/description/</a><br>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maxDepth(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = maxDepth(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">right</span> = maxDepth(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        return ((<span class="built_in">left</span> &gt; <span class="built_in">right</span>)?<span class="built_in">left</span>:<span class="built_in">right</span>) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Minimum Depth of Binary Tree<br><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/minimum-depth-of-binary-tree/description/</a><br>Given a binary tree, find its minimum depth.<br>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve_dp</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> lf = <span class="number">0x7fffffff</span>, rt = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            lf = solve_dp(root-&gt;left);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) </span><br><span class="line">            rt = solve_dp(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(lf, rt) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> solve_dp(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Balanced Binary Tree<br><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/balanced-binary-tree/description/</a><br>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">public:</span><br><span class="line">    int treeDepth(<span class="type">TreeNode</span> *root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int <span class="keyword">left</span> = treeDepth(root-&gt;<span class="keyword">left</span>);</span><br><span class="line">        int <span class="keyword">right</span> = treeDepth(root-&gt;<span class="keyword">right</span>);</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">left</span> &gt; <span class="keyword">right</span>)?<span class="keyword">left</span>:<span class="keyword">right</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br><span class="line">    bool isBalanced(<span class="type">TreeNode</span>* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="type">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        int <span class="keyword">left</span> = treeDepth(root-&gt;<span class="keyword">left</span>);</span><br><span class="line">        int <span class="keyword">right</span> = treeDepth(root-&gt;<span class="keyword">right</span>);</span><br><span class="line">        int diff = <span class="keyword">left</span> - <span class="keyword">right</span>;</span><br><span class="line">        <span class="keyword">if</span>(diff &gt; <span class="number">1</span> || diff &lt; -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root-&gt;<span class="keyword">left</span>) &amp;&amp; isBalanced(root-&gt;<span class="keyword">right</span>);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Binary Tree Maximum Path Sum<br><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" target="_blank" rel="external">https://leetcode.com/problems/binary-tree-maximum-path-sum/description/</a><br>Given a binary tree, find the maximum path sum.<br>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.<br>For example:<br>Given the below binary tree,</p>
<pre><code>  <span class="number">1</span>
 / \
<span class="number">2</span>   <span class="number">3</span>
</code></pre><p>Return 6.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Lowest Common Ancestor of a Binary Tree<br><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/</a><br>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre><code><span class="code">    _______3______</span>
   /              \
<span class="strong">___5__</span>          <span class="strong">___1__</span>
</code></pre><p>   /      \        /      \<br>   6      _2       0       8<br>         /  \<br>         7   4<br>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root == p || root == q)</span><br><span class="line">            return root;</span><br><span class="line">            </span><br><span class="line">        TreeNode* <span class="built_in">left</span> = lowestCommonAncestor(root-&gt;<span class="built_in">left</span>, p, q);</span><br><span class="line">        TreeNode* <span class="built_in">right</span> = lowestCommonAncestor(root-&gt;<span class="built_in">right</span>, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">right</span> != <span class="literal">NULL</span>)</span><br><span class="line">            return root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">left</span> != <span class="literal">NULL</span>)</span><br><span class="line">            return <span class="built_in">left</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">right</span> != <span class="literal">NULL</span>)</span><br><span class="line">            return <span class="built_in">right</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            return <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Binary Tree Level Order Traversal<br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="external">https://leetcode.com/problems/binary-tree-level-order-traversal/description/</a><br>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; levelOrder(<span class="type">TreeNode</span>* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="literal">result</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">        queue&lt;<span class="type">TreeNode</span>*&gt; q1;</span><br><span class="line">        q1.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty())</span><br><span class="line">        &#123; </span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="type">int</span> my_size = q1.size();</span><br><span class="line">            <span class="keyword">while</span>(my_size != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span>* head = q1.front();</span><br><span class="line">                q1.pop();</span><br><span class="line">                level.push_back(head-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left != <span class="type">NULL</span>)</span><br><span class="line">                    q1.push(head-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;right != <span class="type">NULL</span>)</span><br><span class="line">                    q1.push(head-&gt;right);</span><br><span class="line">                </span><br><span class="line">                my_size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">result</span>.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Validate Binary Search Tree<br><a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="external">https://leetcode.com/problems/validate-binary-search-tree/description/</a><br>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>Example 1:<br>    2<br>   / \<br>  1   3<br>Binary tree [2,1,3], return true.<br>Example 2:<br>    1<br>   / \<br>  2   3<br>Binary tree [1,2,3], return false.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *lastNode = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isValidBST(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(lastNode != <span class="keyword">NULL</span> &amp;&amp; lastNode-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        lastNode = root;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Delete Node in a BST<br><a href="https://leetcode.com/problems/delete-node-in-a-bst/discuss/" target="_blank" rel="external">https://leetcode.com/problems/delete-node-in-a-bst/discuss/</a><br>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<p>Search for a node to remove.<br>If the node is found, delete the node.<br>Note: Time complexity should be O(height of tree).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Binary Search Tree Iterator<br><a href="https://leetcode.com/problems/binary-search-tree-iterator/description/" target="_blank" rel="external">https://leetcode.com/problems/binary-search-tree-iterator/description/</a><br>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<p>Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; myStack;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    void pushAll(TreeNode *root)&#123;</span><br><span class="line">        <span class="keyword">for</span> (; root != <span class="keyword">NULL</span>; myStack.push(root), root = root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    BSTIterator(TreeNode *root) &#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="keyword">bool</span> hasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> !myStack.<span class="keyword">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="keyword">int</span> next() &#123;</span><br><span class="line">        TreeNode * node = myStack.top();</span><br><span class="line">        myStack.pop();</span><br><span class="line">        pushAll(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Binary Tree Preorder Traversal<br>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>recursion<br><figure c]]>
    </summary>
    
      <category term="Leetcode" scheme="http://geekzph.github.io/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://geekzph.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[I/O复用之select、poll、epoll]]></title>
    <link href="http://geekzph.github.io/2017/06/19/I-O%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll/"/>
    <id>http://geekzph.github.io/2017/06/19/I-O复用之select、poll、epoll/</id>
    <published>2017-06-19T13:39:04.000Z</published>
    <updated>2017-08-24T01:52:31.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="IO复用" scheme="http://geekzph.github.io/tags/IO%E5%A4%8D%E7%94%A8/"/>
    
      <category term="Linux" scheme="http://geekzph.github.io/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL源码分析之vector]]></title>
    <link href="http://geekzph.github.io/2017/05/30/STL%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bvector/"/>
    <id>http://geekzph.github.io/2017/05/30/STL源码分析之vector/</id>
    <published>2017-05-30T06:44:04.000Z</published>
    <updated>2017-08-24T01:53:03.000Z</updated>
    <content type="html"><![CDATA[<p>概述<br>vector的数据安排及操作方式与数组非常类似。C++内置了数组的类型，在使用数组的时候，必须指定数组的长度，一旦配置了就不能改变了。vector是一个动态空间，随着元素的加入，它的内部机制会自行扩充以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，再也不必因为害怕空间不足而一开始就配置一个大容量数组了，vector是用多少就分配多少。</p>
<p>vector的数据结构<br>vector采用的数据结构非常简单：线性连续空间。两个迭代器start和finish分贝指向配置得来的的连续空间目前已被使用范围，end_of_storage指向连续整段空间的末尾</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T, class <span class="type">Alloc</span> = alloc&gt;//alloc是<span class="type">STL</span>的空间配置器</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">	// 这里提供<span class="type">STL</span>标准的allocator接口</span><br><span class="line">  typedef simple_alloc&lt;value_type, <span class="type">Alloc</span>&gt; data_allocator;</span><br><span class="line">  <span class="keyword">iterator</span> start;               // 内存空间起始点</span><br><span class="line">  <span class="keyword">iterator</span> finish;              // 当前使用的内存空间结束点</span><br><span class="line">  <span class="keyword">iterator</span> end_of_storage;      // 实际分配内存空间的结束点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当初始化一个vector的时候，先分配一段内存，称为容量capacity，大小为end_of_storage - start + 1，当往vector里面加入数据的时候，finish就往后移，代表目前已使用的空间，这样做的好处是，不用频繁的扩充空间和转移数据，使得时间成本下降。<br>运用start，finish，end_of_storage 三个迭代器，可以容易地提供收尾标示、大小、容量、空容器，注标（[]）运算子、最前端、最后端元素等功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//初始迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//const迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;<span class="comment">//末端迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(end()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(begin()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;<span class="comment">//vector元素个数</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(-<span class="number">1</span>) / <span class="keyword">sizeof</span>(T); &#125;<span class="comment">//vector最多可以容纳元素个数</span></span><br><span class="line"><span class="comment">//vector容量</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - begin()); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() == end(); &#125;</span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br></pre></td></tr></table></figure>
<p>vector构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数，迭代器都初始化为０，此时没有内存空间</span></span><br><span class="line"><span class="built_in">vector</span>() : start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">//用n个数类初始化vector</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; fill_initialize(n, T()); &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码调用了默认构造函数，不分配空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure></p>
<p>vector的初始化可以指定元素个数和初始化类型。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>,<span class="number">1</span>); <span class="comment">// 将vec初始化为10个1</span></span><br></pre></td></tr></table></figure>
<p>vector提供下面的构造函数以支持上述初始化操作：<br><img src="/images/vector.jpg" alt=""></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数，允许指定vector的元素个数和初值</span><br><span class="line">vector(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">vector(<span class="type">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">vector(long n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">// 需要对象提供默认构造函数</span><br><span class="line">explicit vector(size_type n) &#123; fill_initialize(n, T()); &#125;</span><br><span class="line">/**</span><br><span class="line"> * 填充并予以初始化</span><br><span class="line"> */</span><br><span class="line"><span class="type">void</span> fill_initialize(size_type n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">  start = allocate_and_fill(n, value);</span><br><span class="line">  finish = start + n;                         // 设置当前使用内存空间的结束点</span><br><span class="line">  //这里不过多的分配内存</span><br><span class="line">  end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 配置一块大小为n的内存空间，并予以填充</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">iterator</span> allocate_and_fill(size_type n, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	// 调用<span class="type">STL</span>的空间配置器配置一块大小为n的内存空间</span><br><span class="line">  <span class="keyword">iterator</span> <span class="literal">result</span> = data_allocator::allocate(n); </span><br><span class="line">  // 调用底层函数uninitialized_fill_n予以填充</span><br><span class="line">  uninitialized_fill_n(<span class="literal">result</span>, n, x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面调用了uninitialized_fill_n函数，这个函数是STL的内存基本处理函数，存放在stl_uninitialized.h中，下面来看看它的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction和operator =等效, 并且destructor is trivial</span></span><br><span class="line"><span class="comment">// 那么就可以使用本函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                           <span class="keyword">const</span> T&amp; x, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> fill_n(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是POD类型使用以下函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line">ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                           <span class="keyword">const</span> T&amp; x, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">  ForwardIterator cur = first;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</span><br><span class="line">    construct(&amp;*cur, x);</span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用type_traits来判断是否是POD类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T, <span class="keyword">class</span> T1&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,</span><br><span class="line">    <span class="keyword">const</span> T&amp; x, T1*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用Iterator_traits来萃取出其值类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n,</span><br><span class="line">    <span class="keyword">const</span> T&amp; x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数根据这个vector的数据类型，调用不同的函数:先判断这个数据类型是否是POD，POD是plain old data的简称，表示c语言的基础数据类型，int ,long,double等等，还有c语言的struct接口。如果是POD类型，直接用fill_n函数填充内存即可；如果不是POD类型，就需要调用构造函数来初始化内存。</p>
<p>一些常用函数<br>push_back函数<br>push_back()函数将新元素插入于vector的尾部，该函数再完成这一操作的时候，先检查是否还有备用空间，如果有直接在备用空间上构造元素，并调整finish；如果没有就扩充空间，通过重新配置一块大空间，移动数据，释放原空间的操作来完成push_back操作。其源代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span>(<span class="params"><span class="keyword">const</span> T&amp; x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    construct(finish, x);    <span class="comment">//当还有空间时，直接在finish赋值，然后finish向后移动一个单位</span></span><br><span class="line">    ++finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">else</span></span><br><span class="line">    <span class="title">insert_aux</span>(<span class="params">end(</span>), x)</span>;<span class="comment">//内存不够时，调用分配函数，并赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">vector</span>&lt;T, Alloc&gt;::insert_aux(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    copy_backward(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);<span class="comment">//把position到finish-2都向后移动一个单位，将position空间留出来</span></span><br><span class="line">    *position = x_copy;<span class="comment">//给这个空间赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">    <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;<span class="comment">//设置新长度</span></span><br><span class="line">    iterator new_start = data_allocator::allocate(len);<span class="comment">//分配新空间</span></span><br><span class="line">    iterator new_finish = new_start;<span class="comment">//finish和start一样</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="comment">//将[start,position)赋值到new_start</span></span><br><span class="line">      new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">      <span class="comment">//将x放置在new_finish处</span></span><br><span class="line">      construct(new_finish, x);</span><br><span class="line">      ++new_finish;<span class="comment">//new_finish向后移动一个单位</span></span><br><span class="line">      <span class="comment">//将[position,finish)赋值到new_finish</span></span><br><span class="line">      new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#       <span class="keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">      destroy(new_start, new_finish); </span><br><span class="line">      data_allocator::deallocate(new_start, len);</span><br><span class="line">      <span class="keyword">throw</span>;<span class="comment">//错误删除分配空间</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#       <span class="keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">    destroy(begin(), end());<span class="comment">//析构原空间数据</span></span><br><span class="line">    deallocate();<span class="comment">//释放原内存</span></span><br><span class="line">    start = new_start;<span class="comment">//更新start值</span></span><br><span class="line">    finish = new_finish;<span class="comment">//更新finish值</span></span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓动态增加大小，不是在原空间之后接续新空间（无法保证原空间之后又足够空间），而是以原来大小的两倍配置另一块儿空间，然后将原来的内容拷贝过来，并释放原空间。</p>
<p>vector操作：pop_back(), erase,clear,insert<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//初始迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//const迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;<span class="comment">//末端迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(end()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(begin()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;<span class="comment">//vector元素个数</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(-<span class="number">1</span>) / <span class="keyword">sizeof</span>(T); &#125;<span class="comment">//vector最多可以容纳元素个数</span></span><br><span class="line"><span class="comment">//vector容量</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - begin()); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() == end(); &#125;</span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br></pre></td></tr></table></figure></p>
<p>pop_back()函数<br>pop_back函数弹出当前尾端元素。其源代码比较简单，如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//调整finish</span></span><br><span class="line">  --finish;</span><br><span class="line">  <span class="comment">//释放调弹出的元素</span></span><br><span class="line">  destroy(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>erase()函数<br>erase函数支持两个版本：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//清除某个位置上的元素</span><br><span class="line"><span class="keyword">iterator</span> erase(<span class="keyword">iterator</span> position)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="keyword">end</span>())</span><br><span class="line">    copy(position + <span class="number">1</span>, finish, position); //将[position+<span class="number">1</span>,finish]移到[position,finish]</span><br><span class="line">  --finish;</span><br><span class="line">  destroy(finish);</span><br><span class="line">  <span class="keyword">return</span> position;//返回删除点的迭代器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清除某个区间上的所有函数</span><br><span class="line"><span class="keyword">iterator</span> erase(<span class="keyword">iterator</span> first, <span class="keyword">iterator</span> last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">iterator</span> i = copy(last, finish, first);//关于copy函数的源码分析在以后的博文中会提到</span><br><span class="line">  // 析构掉需要析构的元素</span><br><span class="line">  destroy(i, finish);</span><br><span class="line">  finish = finish - (last - first);</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程如下图所示：<br><img src="/images/vector2.jpg" alt=""></p>
<p>insert()函数<br>insert函数实现的功能是：从position开始，插入n个元素，元素的初值均为x。其源码如下：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::insert(iterator position, size<span class="number">_</span>type n, const T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果n为0则不进行任何操作</span></span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size<span class="number">_</span>type(end<span class="number">_</span><span class="keyword">of</span><span class="number">_</span>storage - finish) &gt;= n) &#123;      <span class="comment">// 剩下的内存够分配</span></span><br><span class="line">      T x<span class="number">_</span>copy = x;</span><br><span class="line">      const size<span class="number">_</span>type elems<span class="number">_</span>after = finish - position; <span class="comment">// 计算插入点之后的现有元素个数</span></span><br><span class="line">      iterator old<span class="number">_f</span>inish = finish;</span><br><span class="line">      <span class="keyword">if</span> (elems<span class="number">_</span>after &gt; n) &#123;  <span class="comment">// 插入点之后的现有元素个数大于新增元素个数，见下图1</span></span><br><span class="line">      	<span class="comment">// 先复制尾部n个元素到尾部</span></span><br><span class="line">        uninitialized<span class="number">_</span>copy(finish - n, finish, finish);</span><br><span class="line">        finish += n; <span class="comment">// 调整新的finish</span></span><br><span class="line">        <span class="comment">// 从后往前复制剩余的旧元素</span></span><br><span class="line">        copy<span class="number">_</span>backward(position, old<span class="number">_f</span>inish - n, old<span class="number">_f</span>inish);</span><br><span class="line">        <span class="comment">// 从position开始填充新元素</span></span><br><span class="line">        fill(position, position + n, x<span class="number">_</span>copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 插入点之后的现有元素个数小于新增元素个数，见下图2</span></span><br><span class="line">      	<span class="comment">// 先在尾部填充n - elems_after个新增元素</span></span><br><span class="line">        uninitialized<span class="number">_f</span>ill<span class="number">_n</span>(finish, n - elems<span class="number">_</span>after, x<span class="number">_</span>copy);</span><br><span class="line">        <span class="comment">// 调整新的finish</span></span><br><span class="line">        finish += n - elems<span class="number">_</span>after;</span><br><span class="line">        <span class="comment">// 复制[position,old_finish]区间的数到新的finish之后</span></span><br><span class="line">        uninitialized<span class="number">_</span>copy(position, old<span class="number">_f</span>inish, finish);</span><br><span class="line">        <span class="comment">// 调整finish</span></span><br><span class="line">        finish += elems<span class="number">_</span>after;</span><br><span class="line">        <span class="comment">// 从position开始填充新增元素</span></span><br><span class="line">        fill(position, old<span class="number">_f</span>inish, x<span class="number">_</span>copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 剩下的内存不够分配, 需要重新分配</span></span><br><span class="line">      const size<span class="number">_</span>type old<span class="number">_</span>size = size();</span><br><span class="line">      const size<span class="number">_</span>type len = old<span class="number">_</span>size + max(old<span class="number">_</span>size, n);</span><br><span class="line">      iterator <span class="keyword">new</span><span class="number">_</span>start = data<span class="number">_</span>allocator::allocate(len);</span><br><span class="line">      iterator <span class="keyword">new</span><span class="number">_f</span>inish = <span class="keyword">new</span><span class="number">_</span>start;</span><br><span class="line">      <span class="number">__</span>STL<span class="number">_T</span>RY &#123;</span><br><span class="line">      	<span class="comment">// 将旧的vector中插入点之前的元素复制到新空间，见下图3</span></span><br><span class="line">        <span class="keyword">new</span><span class="number">_f</span>inish = uninitialized<span class="number">_</span>copy(start, position, <span class="keyword">new</span><span class="number">_</span>start);</span><br><span class="line">        <span class="comment">// 将新增元素复制到新空间</span></span><br><span class="line">        <span class="keyword">new</span><span class="number">_f</span>inish = uninitialized<span class="number">_f</span>ill<span class="number">_n</span>(<span class="keyword">new</span><span class="number">_f</span>inish, n, x);</span><br><span class="line">        <span class="comment">// 将插入点之后的元素复制到新空间</span></span><br><span class="line">        <span class="keyword">new</span><span class="number">_f</span>inish = uninitialized<span class="number">_</span>copy(position, finish, <span class="keyword">new</span><span class="number">_f</span>inish);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        destroy(<span class="keyword">new</span><span class="number">_</span>start, <span class="keyword">new</span><span class="number">_f</span>inish);</span><br><span class="line">        data<span class="number">_</span>allocator::deallocate(<span class="keyword">new</span><span class="number">_</span>start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 清除并释放原有vector</span></span><br><span class="line">      destroy(start, finish);</span><br><span class="line">      deallocate();</span><br><span class="line">      <span class="comment">// 调整新的start和finish</span></span><br><span class="line">      start = <span class="keyword">new</span><span class="number">_</span>start;</span><br><span class="line">      finish = <span class="keyword">new</span><span class="number">_f</span>inish;</span><br><span class="line">      end<span class="number">_</span><span class="keyword">of</span><span class="number">_</span>storage = <span class="keyword">new</span><span class="number">_</span>start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>概述<br>vector的数据安排及操作方式与数组非常类似。C++内置了数组的类型，在使用数组的时候，必须指定数组的长度，一旦配置了就不能改变了。vector是一个动态空间，随着元素的加入，它的内部机制会自行扩充以容纳新元素。因此，vector的运用对于内存的合理利用与运用]]>
    </summary>
    
      <category term="STL" scheme="http://geekzph.github.io/tags/STL/"/>
    
      <category term="C++" scheme="http://geekzph.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++柔性数组]]></title>
    <link href="http://geekzph.github.io/2017/05/30/C-%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
    <id>http://geekzph.github.io/2017/05/30/C-柔性数组/</id>
    <published>2017-05-30T06:43:32.000Z</published>
    <updated>2017-08-24T01:52:49.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="柔性数组" scheme="http://geekzph.github.io/tags/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
    
      <category term="C++" scheme="http://geekzph.github.io/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gephi导入csv文件的问题]]></title>
    <link href="http://geekzph.github.io/2017/05/28/Gephi%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://geekzph.github.io/2017/05/28/Gephi导入csv文件的问题/</id>
    <published>2017-05-28T07:30:10.000Z</published>
    <updated>2017-05-28T07:45:57.000Z</updated>
    <content type="html"><![CDATA[<p>做实验室输出类似如下的数据，需要导入到Gephi画图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1991</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1991</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2003</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">2003</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span> <span class="number">1972</span></span><br><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">1972</span></span><br><span class="line">.  .  .</span><br><span class="line">.  .  .</span><br><span class="line">.  .  .</span><br></pre></td></tr></table></figure>
<p>于是将其改为csv格式，并将内容改为如下形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">source target wight</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1991</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1991</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2003</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">2003</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span> <span class="number">1972</span></span><br><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">1972</span></span><br><span class="line">.  .  .</span><br><span class="line">.  .  .</span><br><span class="line">.  .  .</span><br></pre></td></tr></table></figure>
<p>打开Gehpi ，依次选择 文件-&gt;importspreadsheet<br>，选择刚才保存的csv文件。分隔符为空格，表格为边表格。</p>
<p>但是下面却出现红色警告</p>
<blockquote>
<p>边表格需要一个包含节点标号的“源”和“目标”列</p>
</blockquote>
<p>在网上查了好久，说是应为编码的原因，但是换个编码还是不行。而且我认为并不是编码的问题，因为在预览里，csv的数据都是可以正常显示和分列的。如果是编码问题的话，应该是会出现乱码。</p>
<p>后来经过摸索发现，在出现类似情况的时候，可以把数据存入Excel后，再导出为csv，这样就可以正常导入Gephi了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>做实验室输出类似如下的数据，需要导入到Gephi画图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span clas]]>
    </summary>
    
  </entry>
  
</feed>

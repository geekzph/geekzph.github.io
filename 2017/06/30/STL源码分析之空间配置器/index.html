<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>STL源码分析之空间配置器 | geekzph's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">STL源码分析之空间配置器</h1><a id="logo" href="/.">geekzph's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">STL源码分析之空间配置器</h1><div class="post-meta">Jun 30, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>在内存配置方面，为了避免小型区块所造成的内存破碎问题，STL设计为两级配置器。第一级配置器直接使用malloc()和free(). 第二层配置器有有一个内存池，用一个union obj数组free_list来存储内存的地址，数组的每一个元素都指向一个obj链表，也就是内存链表。数组从小到大表示负责8b,16b,24b,…,120b,128b内存请求。当请求的内存大于128b的时候调用第一级配置器，当请求的内存小于等于128b的时候调用第二级配置器。<br><img src="/images/1.jpg" alt=""></p>
<p>第一级配置器</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line">class __malloc_alloc_template  </span><br><span class="line">&#123;  </span><br><span class="line">private:</span><br><span class="line">	//sfasdf</span><br><span class="line">	//调用malloc函数不成功后调用</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> *oom_malloc(size_t);</span><br><span class="line">	//调用realloc函数不成功后调用 </span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> *oom_realloc(<span class="type">void</span> *, size_t);</span><br><span class="line">	//类似于C++的set_new_handle错误处理函数一样，如果不设置，在内存不足时，返回<span class="type">THROW_BAD_ALLOC</span></span><br><span class="line">	<span class="comment">#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG  </span></span><br><span class="line">		<span class="keyword">static</span> <span class="type">void</span> (* __malloc_alloc_oom_handler)();  </span><br><span class="line">	<span class="comment">#endif  </span></span><br><span class="line">	public:  </span><br><span class="line">	//直接调用malloc来分配内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> * allocate(size_t n)  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> *<span class="literal">result</span> = malloc(n);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == <span class="literal">result</span>) <span class="literal">result</span> = oom_malloc(n);  //如果分配失败，则调用oom_malloc()</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">result</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line"> 	//第一级配置器直接调用free来释放内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> deallocate(<span class="type">void</span> *p, size_t /* n */)  </span><br><span class="line">	&#123; </span><br><span class="line">		free(p); </span><br><span class="line">	&#125;  </span><br><span class="line">	//直接调用reallloc来分配内存</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> * reallocate(<span class="type">void</span> *p, size_t /* old_sz */, size_t new_sz)  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> * <span class="literal">result</span> = realloc(p, new_sz);  </span><br><span class="line">	 <span class="keyword">if</span> (<span class="number">0</span> == <span class="literal">result</span>) <span class="literal">result</span> = oom_realloc(p, new_sz);  //如果realloc分配不成功，调用oom_realloc()</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">result</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	//异常处理函数，即内存分配失败后的处理</span><br><span class="line">	<span class="keyword">static</span> <span class="type">void</span> (* set_malloc_handler(<span class="type">void</span> (*f)()))()  </span><br><span class="line">	&#123;  </span><br><span class="line">	 <span class="type">void</span> (* old)() = __malloc_alloc_oom_handler;  </span><br><span class="line">	 __malloc_alloc_oom_handler = f;  </span><br><span class="line">	 <span class="keyword">return</span>(old);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上述源码中可以看到，STL的第一级配置器仅仅是调用了malloc，free等函数，然后增加了内存分配错误下的异常处理函数。下面是内存分配失败时的代码</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 以下是针对内存分配失败后的处理</span><br><span class="line">//首先，将__malloc_alloc_oom_handler的默认值设为<span class="number">0</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">#endif  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="type">void</span> *<span class="literal">result</span>;  </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  // 不断地尝试释放、再配置、再释放、再配置</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;  //这里是当没有设置处理函数的时候，直接抛出异常</span><br><span class="line">		(*my_malloc_handler)();   // 调用处理例程，尝试释放内存</span><br><span class="line">		<span class="literal">result</span> = malloc(n);  	  // 再重新分配内存</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span>(<span class="literal">result</span>);  // 如果分配成功则返回指针</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="type">void</span> *p, size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">void</span> (* my_malloc_handler)();  </span><br><span class="line">	<span class="type">void</span> *<span class="literal">result</span>;  </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;  //不断地尝试释放、再配置、再释放、再配置</span><br><span class="line">		my_malloc_handler = __malloc_alloc_oom_handler;  </span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; //这里是当没有设置处理函数的时候，直接抛出异常 </span><br><span class="line">		(*my_malloc_handler)();  // 调用处理例程，尝试释放内存</span><br><span class="line">		<span class="literal">result</span> = realloc(p, n);  // 再重新分配内存</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span>(<span class="literal">result</span>);  // 如果分配成功则返回指针</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数，在当内存分配失败时，会不断尝试区内存释放内存，再分配内存，所以再一定程度上提高内存分配成功。</p>
<p>第二级配置器<br>当申请内存小于128b的时候，会调用第二级配置器。第二级配置器有一个内存池和一个对应的自由链表，其定义如下：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span>  </span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span>  </span><br><span class="line">	char client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述obj所用的是union， 由于是union，从第一个字段看，obj可以视为一个指针，指向相同形式的另一个obj；从第二个字段看，obj可以被视为一个指针，指向实际区块。这样一来，既实现了链表结点只用一个指针的大小空间，却能同时做索引和指向内存区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;;   <span class="comment">//小型区块的上调边界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;  <span class="comment">//小型区块的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;   <span class="comment">//free-lists个数</span></span><br><span class="line"><span class="comment">//第一参数用于多线程，这里不做讨论。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">class</span> __default_alloc_template  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 此函数将bytes的边界上调至8的倍数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(size_t bytes)</span>  </span><br><span class="line">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN-<span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));  </span><br><span class="line">	&#125;  </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">	<span class="comment">// 此union结构体上面已经解释过了</span></span><br><span class="line">	<span class="keyword">union</span> obj  </span><br><span class="line">	&#123;  </span><br><span class="line">	<span class="keyword">union</span> obj * free_list_link;  </span><br><span class="line">	<span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">	&#125;;  </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">	<span class="comment">//16个free-lists</span></span><br><span class="line">	<span class="keyword">static</span> obj * __VOLATILE free_list[__NFREELISTS];</span><br><span class="line">	<span class="comment">// 根据待待分配的空间大小, 在free_list中选择合适的大小  </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(size_t bytes)</span>  </span><br><span class="line">	</span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> (((bytes) + __ALIGN-<span class="number">1</span>)/__ALIGN - <span class="number">1</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回一个大小为n的对象，并可能加入大小为n的其它区块到free-lists</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">refill</span><span class="params">(size_t n)</span></span>;  </span><br><span class="line">	<span class="comment">// 配置一大块空间，可容纳nobjs个大小为“size”的区块</span></span><br><span class="line">	<span class="comment">// 如果配置nobjs个区块有所不便，nobjs可能会降低，所以需要用引用传递</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">chunk_alloc</span><span class="params">(size_t size, <span class="keyword">int</span> &amp;nobjs)</span></span>;  </span><br><span class="line">	<span class="comment">// 内存池  </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *start_free;      <span class="comment">// 内存池起始点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *end_free;        <span class="comment">// 内存池结束点，只在chunk_alloc()中变化 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;      <span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(size_t n)</span></span>;<span class="comment">// 空间配置函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, size_t n)</span></span>; <span class="comment">// 空间释放函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* p, size_t old_sz , size_t new_sz)</span></span>; <span class="comment">//空间重新配置函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一些静态成员变量的初始化</span></span><br><span class="line"><span class="comment">// 内存池起始位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池结束位置  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 已经在堆上分配的空间大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 内存池容量索引数组  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::obj * __VOLATILE  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt; ::free_list[__NFREELISTS ] = </span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure>
<p>空间配置函数allocate()</p>
<p>下图说明了说明空间配置函数的调用过程：<br><img src="/images/2.jpg" alt=""></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> * allocate(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	obj * volatile * my_free_list;  </span><br><span class="line">	obj * <span class="literal">result</span>;  </span><br><span class="line">	// 大于<span class="number">128</span>就调用第一级配置器</span><br><span class="line">	<span class="keyword">if</span> (n &gt; (size_t) __MAX_BYTES) &#123;  </span><br><span class="line">	 <span class="keyword">return</span>(malloc_alloc::allocate(n));  </span><br><span class="line">	&#125;  </span><br><span class="line">	// 寻找<span class="number">16</span>个free_lists中适当的一个</span><br><span class="line">	my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(n);  </span><br><span class="line">	<span class="literal">result</span> = *my_free_list;  </span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">result</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">		// 如果没有可用的free list，准备重新填充free_list</span><br><span class="line">		<span class="type">void</span> *r = refill(<span class="type">ROUND_UP</span>(n));  </span><br><span class="line">		<span class="keyword">return</span> r;  </span><br><span class="line">	&#125;</span><br><span class="line">	// 调整free list</span><br><span class="line">	*my_free_list = <span class="literal">result</span> -&gt; free_list_link;  </span><br><span class="line">	<span class="keyword">return</span> (<span class="literal">result</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存释放函数deallocate()<br>内存释放函数会将释放的空间交还给free_list以留备用。其过程如下图所示：<br><img src="/images/3.jpg" alt=""></p>
<p>重新填充函数refill()</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> nobjs = <span class="number">20</span>;  //	默认获取<span class="number">20</span>个</span><br><span class="line">	<span class="type">char</span> * chunk = chunk_alloc(n, nobjs);  //找内存池要空间</span><br><span class="line">	obj * volatile * my_free_list;  </span><br><span class="line">	obj * <span class="literal">result</span>;  </span><br><span class="line">	obj * current_obj, * next_obj;  </span><br><span class="line">	<span class="type">int</span> i;  </span><br><span class="line">	// 如果内存池仅仅只够分配一个对象的空间, 直接返回即可  </span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);  </span><br><span class="line">	// 内存池能分配更多的空间，调整free_list纳入新节点</span><br><span class="line">	my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(n);</span><br><span class="line">	// 在chunk的空间中建立free_list  </span><br><span class="line">	<span class="literal">result</span> = (obj *)chunk;</span><br><span class="line">	*my_free_list = next_obj = (obj *)(chunk + n); //导引free_list指向新配置的空间(取自内存池)</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; ; i++) &#123;	//从<span class="number">1</span>开始，因为第<span class="number">0</span>个返回给客端</span><br><span class="line">		current_obj = next_obj;  </span><br><span class="line">		next_obj = (obj *)((<span class="type">char</span> *)next_obj + n);  </span><br><span class="line">		<span class="keyword">if</span>(nobjs - <span class="number">1</span> == i) &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			current_obj -&gt; free_list_link = next_obj;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span>(<span class="literal">result</span>);//返回头指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存池函数chunk_alloc()</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;  </span><br><span class="line"><span class="type">char</span>*  </span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, <span class="type">int</span>&amp; nobjs)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">char</span> * <span class="literal">result</span>;  </span><br><span class="line">    size_t total_bytes = size * nobjs;  </span><br><span class="line">    size_t bytes_left = end_free - start_free;  // 计算内存池剩余容量  </span><br><span class="line">   </span><br><span class="line">    //内存池中的剩余空间满足需求 </span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;  </span><br><span class="line">        <span class="literal">result</span> = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">result</span>);//返回起始地址</span><br><span class="line">    &#125;  </span><br><span class="line">    // 如果内存池中剩余的容量不够分配, 但是能至少分配一个节点时,  </span><br><span class="line">    // 返回所能分配的最多的节点, 返回start_free指向的内存块  </span><br><span class="line">    // 并且重新设置内存池起始点  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left/size;  </span><br><span class="line">        total_bytes = size * nobjs;  </span><br><span class="line">        <span class="literal">result</span> = start_free;  </span><br><span class="line">        start_free += total_bytes;  </span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">result</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 内存池剩余内存连一个节点也不够分配  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        size_t bytes_to_get = <span class="number">2</span> * total_bytes + <span class="type">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line">        // 将剩余的内存分配给指定的free_list[<span class="type">FREELIST_INDEX</span>(bytes_left)]  </span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        	//内存池内还有一些零头，先分给适当的free_list</span><br><span class="line">        	//寻找适当的free_list</span><br><span class="line">            obj * __VOLATILE * my_free_list =  </span><br><span class="line">                   	free_list + <span class="type">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">            // 调整free_list，将内存池中的残余空间编入 </span><br><span class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </span><br><span class="line">            *my_free_list = (obj *)start_free;  </span><br><span class="line">        &#125;  </span><br><span class="line">        start_free = (<span class="type">char</span> *)malloc(bytes_to_get);  </span><br><span class="line">        // 分配失败, 搜索原来已经分配的内存块, 看是否有大于等于当前请求的内存块  </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;// heap里面空间不足，malloc失败</span><br><span class="line">            <span class="type">int</span> i;  </span><br><span class="line">            obj * __VOLATILE * my_free_list, *p;  </span><br><span class="line">            // 试着检查检查free_list中的可用空间，即尚有未用的空间，且区块够大  </span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;  </span><br><span class="line">                my_free_list = free_list + <span class="type">FREELIST_INDEX</span>(i);  </span><br><span class="line">                p = *my_free_list;  </span><br><span class="line">                // 找到了一个, 将其加入内存池中  </span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;  </span><br><span class="line">                    *my_free_list = p -&gt; free_list_link;  </span><br><span class="line">                    start_free = (<span class="type">char</span> *)p;  </span><br><span class="line">                    end_free = start_free + i;  </span><br><span class="line">                    // 内存池更新完毕, 重新分配需要的内存  </span><br><span class="line">                    <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">                    //任何剩余零头将被编入适当的free_list以留备用 </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line"> </span><br><span class="line">        // 再次失败, 直接调用一级配置器分配, 期待异常处理函数能提供帮助  </span><br><span class="line">        // 不过在我看来, 内存分配失败进行其它尝试已经没什么意义了,  </span><br><span class="line">        // 最好直接log, 然后让程序崩溃  </span><br><span class="line">        end_free = <span class="number">0</span>;</span><br><span class="line">        	//调用第一级配置器，看看<span class="keyword">out</span>-<span class="keyword">of</span>-memory机制能不能起点作用</span><br><span class="line">            start_free = (<span class="type">char</span> *)malloc_alloc::allocate(bytes_to_get);  </span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;  </span><br><span class="line">        end_free = start_free + bytes_to_get;  </span><br><span class="line">        // 内存池更新完毕, 重新分配需要的内存  </span><br><span class="line">        <span class="keyword">return</span>(chunk_alloc(size, nobjs));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用配置器<br>STL两层配置器就分析结束了，接下来看下配置器使如何使用的。<br>vector中使用配置器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc&gt;  <span class="comment">//alloc被默认为第二级配置器</span></span><br><span class="line"><span class="keyword">class</span> <span class="built_in">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 专属的空间配置器，每次只分配一个元素的大小</span></span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">	<span class="comment">// 在释放内存的时候直接调用借口函数即可</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(...)&#123;</span><br><span class="line">			data_allocator::deallocate(start , end_of_storage - start);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://geekzph.github.io/2017/06/30/STL源码分析之空间配置器/" data-id="cj6lpauqr000zhskm5ln7bpdr" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2017/07/01/Python多线程/" class="pre">Python多线程</a><a href="/2017/06/30/刷题：二叉树与分治法/" class="next">刷题：二叉树与分治法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://geekzph.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/google/" style="font-size: 15px;">google</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-3/">LeetCode Top 100 Liked Question 3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-2/">LeetCode Top 100 Liked Question 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-1/">LeetCode Top 100 Liked Question 1 - 20</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question/">LeetCode Top 100 Liked Question</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/C-虚函数的的实现/">C++虚函数的的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/不得不知的Linux命令/">不得不知的Linux命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/TCP协议那些事儿/">TCP协议那些事儿</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/高频题目/">高频题目</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/链表/">链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/05/二分搜索/">二分搜索</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">geekzph's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
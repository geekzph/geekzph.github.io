<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>STL源码分析之vector | geekzph's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">STL源码分析之vector</h1><a id="logo" href="/.">geekzph's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">STL源码分析之vector</h1><div class="post-meta">May 30, 2017<span> | </span><span class="category"><a href="/categories/C/">C++</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>概述<br>vector的数据安排及操作方式与数组非常类似。C++内置了数组的类型，在使用数组的时候，必须指定数组的长度，一旦配置了就不能改变了。vector是一个动态空间，随着元素的加入，它的内部机制会自行扩充以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，再也不必因为害怕空间不足而一开始就配置一个大容量数组了，vector是用多少就分配多少。</p>
<p>vector的数据结构<br>vector采用的数据结构非常简单：线性连续空间。两个迭代器start和finish分贝指向配置得来的的连续空间目前已被使用范围，end_of_storage指向连续整段空间的末尾</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class T, class <span class="type">Alloc</span> = alloc&gt;//alloc是<span class="type">STL</span>的空间配置器</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">	// 这里提供<span class="type">STL</span>标准的allocator接口</span><br><span class="line">  typedef simple_alloc&lt;value_type, <span class="type">Alloc</span>&gt; data_allocator;</span><br><span class="line">  <span class="keyword">iterator</span> start;               // 内存空间起始点</span><br><span class="line">  <span class="keyword">iterator</span> finish;              // 当前使用的内存空间结束点</span><br><span class="line">  <span class="keyword">iterator</span> end_of_storage;      // 实际分配内存空间的结束点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当初始化一个vector的时候，先分配一段内存，称为容量capacity，大小为end_of_storage - start + 1，当往vector里面加入数据的时候，finish就往后移，代表目前已使用的空间，这样做的好处是，不用频繁的扩充空间和转移数据，使得时间成本下降。<br>运用start，finish，end_of_storage 三个迭代器，可以容易地提供收尾标示、大小、容量、空容器，注标（[]）运算子、最前端、最后端元素等功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//初始迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//const迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;<span class="comment">//末端迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(end()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(begin()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;<span class="comment">//vector元素个数</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(-<span class="number">1</span>) / <span class="keyword">sizeof</span>(T); &#125;<span class="comment">//vector最多可以容纳元素个数</span></span><br><span class="line"><span class="comment">//vector容量</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - begin()); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() == end(); &#125;</span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br></pre></td></tr></table></figure>
<p>vector构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数，迭代器都初始化为０，此时没有内存空间</span></span><br><span class="line"><span class="built_in">vector</span>() : start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="comment">//用n个数类初始化vector</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; fill_initialize(n, T()); &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码调用了默认构造函数，不分配空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br></pre></td></tr></table></figure></p>
<p>vector的初始化可以指定元素个数和初始化类型。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(<span class="number">10</span>,<span class="number">1</span>); <span class="comment">// 将vec初始化为10个1</span></span><br></pre></td></tr></table></figure>
<p>vector提供下面的构造函数以支持上述初始化操作：<br><img src="/images/vector.jpg" alt=""></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数，允许指定vector的元素个数和初值</span><br><span class="line">vector(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">vector(<span class="type">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">vector(long n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">// 需要对象提供默认构造函数</span><br><span class="line">explicit vector(size_type n) &#123; fill_initialize(n, T()); &#125;</span><br><span class="line">/**</span><br><span class="line"> * 填充并予以初始化</span><br><span class="line"> */</span><br><span class="line"><span class="type">void</span> fill_initialize(size_type n, <span class="keyword">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">  start = allocate_and_fill(n, value);</span><br><span class="line">  finish = start + n;                         // 设置当前使用内存空间的结束点</span><br><span class="line">  //这里不过多的分配内存</span><br><span class="line">  end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 配置一块大小为n的内存空间，并予以填充</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">iterator</span> allocate_and_fill(size_type n, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">	// 调用<span class="type">STL</span>的空间配置器配置一块大小为n的内存空间</span><br><span class="line">  <span class="keyword">iterator</span> <span class="literal">result</span> = data_allocator::allocate(n); </span><br><span class="line">  // 调用底层函数uninitialized_fill_n予以填充</span><br><span class="line">  uninitialized_fill_n(<span class="literal">result</span>, n, x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面调用了uninitialized_fill_n函数，这个函数是STL的内存基本处理函数，存放在stl_uninitialized.h中，下面来看看它的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果copy construction和operator =等效, 并且destructor is trivial</span></span><br><span class="line"><span class="comment">// 那么就可以使用本函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                           <span class="keyword">const</span> T&amp; x, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> fill_n(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不是POD类型使用以下函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line">ForwardIterator</span><br><span class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</span><br><span class="line">                           <span class="keyword">const</span> T&amp; x, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">  ForwardIterator cur = first;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</span><br><span class="line">    construct(&amp;*cur, x);</span><br><span class="line">  <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用type_traits来判断是否是POD类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T, <span class="keyword">class</span> T1&gt;</span><br><span class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,</span><br><span class="line">    <span class="keyword">const</span> T&amp; x, T1*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用Iterator_traits来萃取出其值类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n,</span><br><span class="line">    <span class="keyword">const</span> T&amp; x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, value_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数根据这个vector的数据类型，调用不同的函数:先判断这个数据类型是否是POD，POD是plain old data的简称，表示c语言的基础数据类型，int ,long,double等等，还有c语言的struct接口。如果是POD类型，直接用fill_n函数填充内存即可；如果不是POD类型，就需要调用构造函数来初始化内存。</p>
<p>一些常用函数<br>push_back函数<br>push_back()函数将新元素插入于vector的尾部，该函数再完成这一操作的时候，先检查是否还有备用空间，如果有直接在备用空间上构造元素，并调整finish；如果没有就扩充空间，通过重新配置一块大空间，移动数据，释放原空间的操作来完成push_back操作。其源代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span>(<span class="params"><span class="keyword">const</span> T&amp; x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    construct(finish, x);    <span class="comment">//当还有空间时，直接在finish赋值，然后finish向后移动一个单位</span></span><br><span class="line">    ++finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">else</span></span><br><span class="line">    <span class="title">insert_aux</span>(<span class="params">end(</span>), x)</span>;<span class="comment">//内存不够时，调用分配函数，并赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">vector</span>&lt;T, Alloc&gt;::insert_aux(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    copy_backward(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);<span class="comment">//把position到finish-2都向后移动一个单位，将position空间留出来</span></span><br><span class="line">    *position = x_copy;<span class="comment">//给这个空间赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type old_size = size();</span><br><span class="line">    <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;<span class="comment">//设置新长度</span></span><br><span class="line">    iterator new_start = data_allocator::allocate(len);<span class="comment">//分配新空间</span></span><br><span class="line">    iterator new_finish = new_start;<span class="comment">//finish和start一样</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="comment">//将[start,position)赋值到new_start</span></span><br><span class="line">      new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">      <span class="comment">//将x放置在new_finish处</span></span><br><span class="line">      construct(new_finish, x);</span><br><span class="line">      ++new_finish;<span class="comment">//new_finish向后移动一个单位</span></span><br><span class="line">      <span class="comment">//将[position,finish)赋值到new_finish</span></span><br><span class="line">      new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#       <span class="keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">      destroy(new_start, new_finish); </span><br><span class="line">      data_allocator::deallocate(new_start, len);</span><br><span class="line">      <span class="keyword">throw</span>;<span class="comment">//错误删除分配空间</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#       <span class="keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">    destroy(begin(), end());<span class="comment">//析构原空间数据</span></span><br><span class="line">    deallocate();<span class="comment">//释放原内存</span></span><br><span class="line">    start = new_start;<span class="comment">//更新start值</span></span><br><span class="line">    finish = new_finish;<span class="comment">//更新finish值</span></span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓动态增加大小，不是在原空间之后接续新空间（无法保证原空间之后又足够空间），而是以原来大小的两倍配置另一块儿空间，然后将原来的内容拷贝过来，并释放原空间。</p>
<p>vector操作：pop_back(), erase,clear,insert<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//初始迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">//const迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;<span class="comment">//末端迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(end()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;<span class="comment">//逆向迭代器</span></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> const_reverse_iterator(begin()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;<span class="comment">//vector元素个数</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(-<span class="number">1</span>) / <span class="keyword">sizeof</span>(T); &#125;<span class="comment">//vector最多可以容纳元素个数</span></span><br><span class="line"><span class="comment">//vector容量</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - begin()); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() == end(); &#125;</span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br></pre></td></tr></table></figure></p>
<p>pop_back()函数<br>pop_back函数弹出当前尾端元素。其源代码比较简单，如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">//调整finish</span></span><br><span class="line">  --finish;</span><br><span class="line">  <span class="comment">//释放调弹出的元素</span></span><br><span class="line">  destroy(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>erase()函数<br>erase函数支持两个版本：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//清除某个位置上的元素</span><br><span class="line"><span class="keyword">iterator</span> erase(<span class="keyword">iterator</span> position)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="keyword">end</span>())</span><br><span class="line">    copy(position + <span class="number">1</span>, finish, position); //将[position+<span class="number">1</span>,finish]移到[position,finish]</span><br><span class="line">  --finish;</span><br><span class="line">  destroy(finish);</span><br><span class="line">  <span class="keyword">return</span> position;//返回删除点的迭代器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清除某个区间上的所有函数</span><br><span class="line"><span class="keyword">iterator</span> erase(<span class="keyword">iterator</span> first, <span class="keyword">iterator</span> last)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">iterator</span> i = copy(last, finish, first);//关于copy函数的源码分析在以后的博文中会提到</span><br><span class="line">  // 析构掉需要析构的元素</span><br><span class="line">  destroy(i, finish);</span><br><span class="line">  finish = finish - (last - first);</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程如下图所示：<br><img src="/images/vector2.jpg" alt=""></p>
<p>insert()函数<br>insert函数实现的功能是：从position开始，插入n个元素，元素的初值均为x。其源码如下：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::insert(iterator position, size<span class="number">_</span>type n, const T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果n为0则不进行任何操作</span></span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size<span class="number">_</span>type(end<span class="number">_</span><span class="keyword">of</span><span class="number">_</span>storage - finish) &gt;= n) &#123;      <span class="comment">// 剩下的内存够分配</span></span><br><span class="line">      T x<span class="number">_</span>copy = x;</span><br><span class="line">      const size<span class="number">_</span>type elems<span class="number">_</span>after = finish - position; <span class="comment">// 计算插入点之后的现有元素个数</span></span><br><span class="line">      iterator old<span class="number">_f</span>inish = finish;</span><br><span class="line">      <span class="keyword">if</span> (elems<span class="number">_</span>after &gt; n) &#123;  <span class="comment">// 插入点之后的现有元素个数大于新增元素个数，见下图1</span></span><br><span class="line">      	<span class="comment">// 先复制尾部n个元素到尾部</span></span><br><span class="line">        uninitialized<span class="number">_</span>copy(finish - n, finish, finish);</span><br><span class="line">        finish += n; <span class="comment">// 调整新的finish</span></span><br><span class="line">        <span class="comment">// 从后往前复制剩余的旧元素</span></span><br><span class="line">        copy<span class="number">_</span>backward(position, old<span class="number">_f</span>inish - n, old<span class="number">_f</span>inish);</span><br><span class="line">        <span class="comment">// 从position开始填充新元素</span></span><br><span class="line">        fill(position, position + n, x<span class="number">_</span>copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 插入点之后的现有元素个数小于新增元素个数，见下图2</span></span><br><span class="line">      	<span class="comment">// 先在尾部填充n - elems_after个新增元素</span></span><br><span class="line">        uninitialized<span class="number">_f</span>ill<span class="number">_n</span>(finish, n - elems<span class="number">_</span>after, x<span class="number">_</span>copy);</span><br><span class="line">        <span class="comment">// 调整新的finish</span></span><br><span class="line">        finish += n - elems<span class="number">_</span>after;</span><br><span class="line">        <span class="comment">// 复制[position,old_finish]区间的数到新的finish之后</span></span><br><span class="line">        uninitialized<span class="number">_</span>copy(position, old<span class="number">_f</span>inish, finish);</span><br><span class="line">        <span class="comment">// 调整finish</span></span><br><span class="line">        finish += elems<span class="number">_</span>after;</span><br><span class="line">        <span class="comment">// 从position开始填充新增元素</span></span><br><span class="line">        fill(position, old<span class="number">_f</span>inish, x<span class="number">_</span>copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">// 剩下的内存不够分配, 需要重新分配</span></span><br><span class="line">      const size<span class="number">_</span>type old<span class="number">_</span>size = size();</span><br><span class="line">      const size<span class="number">_</span>type len = old<span class="number">_</span>size + max(old<span class="number">_</span>size, n);</span><br><span class="line">      iterator <span class="keyword">new</span><span class="number">_</span>start = data<span class="number">_</span>allocator::allocate(len);</span><br><span class="line">      iterator <span class="keyword">new</span><span class="number">_f</span>inish = <span class="keyword">new</span><span class="number">_</span>start;</span><br><span class="line">      <span class="number">__</span>STL<span class="number">_T</span>RY &#123;</span><br><span class="line">      	<span class="comment">// 将旧的vector中插入点之前的元素复制到新空间，见下图3</span></span><br><span class="line">        <span class="keyword">new</span><span class="number">_f</span>inish = uninitialized<span class="number">_</span>copy(start, position, <span class="keyword">new</span><span class="number">_</span>start);</span><br><span class="line">        <span class="comment">// 将新增元素复制到新空间</span></span><br><span class="line">        <span class="keyword">new</span><span class="number">_f</span>inish = uninitialized<span class="number">_f</span>ill<span class="number">_n</span>(<span class="keyword">new</span><span class="number">_f</span>inish, n, x);</span><br><span class="line">        <span class="comment">// 将插入点之后的元素复制到新空间</span></span><br><span class="line">        <span class="keyword">new</span><span class="number">_f</span>inish = uninitialized<span class="number">_</span>copy(position, finish, <span class="keyword">new</span><span class="number">_f</span>inish);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        destroy(<span class="keyword">new</span><span class="number">_</span>start, <span class="keyword">new</span><span class="number">_f</span>inish);</span><br><span class="line">        data<span class="number">_</span>allocator::deallocate(<span class="keyword">new</span><span class="number">_</span>start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 清除并释放原有vector</span></span><br><span class="line">      destroy(start, finish);</span><br><span class="line">      deallocate();</span><br><span class="line">      <span class="comment">// 调整新的start和finish</span></span><br><span class="line">      start = <span class="keyword">new</span><span class="number">_</span>start;</span><br><span class="line">      finish = <span class="keyword">new</span><span class="number">_f</span>inish;</span><br><span class="line">      end<span class="number">_</span><span class="keyword">of</span><span class="number">_</span>storage = <span class="keyword">new</span><span class="number">_</span>start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://geekzph.github.io/2017/05/30/STL源码分析之vector/" data-id="cj7qdzz2l002oxkkm5i0n09ik" class="article-share-link">分享到</a><div class="tags"><a href="/tags/STL/">STL</a></div><div class="post-nav"><a href="/2017/06/19/I-O复用之select、poll、epoll/" class="pre">I/O复用之select、poll、epoll</a><a href="/2017/05/30/C-柔性数组/" class="next">C++柔性数组</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://geekzph.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/书摘/">书摘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/快排/" style="font-size: 15px;">快排</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/剑指offer/" style="font-size: 15px;">剑指offer</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/命令/" style="font-size: 15px;">命令</a> <a href="/tags/IPC/" style="font-size: 15px;">IPC</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/环境变量/" style="font-size: 15px;">环境变量</a> <a href="/tags/IO复用/" style="font-size: 15px;">IO复用</a> <a href="/tags/虚函数/" style="font-size: 15px;">虚函数</a> <a href="/tags/柔性数组/" style="font-size: 15px;">柔性数组</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/17/常见排序算法总结/">常见排序算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/剑指offer-三/">剑指offer(三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/剑指offer-二/">剑指offer(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/剑指offer-一/">剑指offer(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/LeetCode-Top-100-Liked-Question-5/">LeetCode Top 100 Liked Question 5</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/LeetCode-Top-100-Liked-Question-4/">LeetCode Top 100 Liked Question 4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-3/">LeetCode Top 100 Liked Question 3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-2/">LeetCode Top 100 Liked Question 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-1/">LeetCode Top 100 Liked Question 1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/C-虚函数的的实现/">C++虚函数的的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">geekzph's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>面试那些事儿之数据结构 | geekzph's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">面试那些事儿之数据结构</h1><a id="logo" href="/.">geekzph's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">面试那些事儿之数据结构</h1><div class="post-meta">Aug 24, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h3 id="1-哈希构造函数有哪几种？处理冲突的方法。解决哈希冲突的方法有哪几种？哈希表的时间复杂度。">1.哈希构造函数有哪几种？处理冲突的方法。解决哈希冲突的方法有哪几种？哈希表的时间复杂度。</h3><p>哈希函数的构造方法有很多，但应注意两个原则：第一，函数值应在1至记录总数之间；第二，尽可能避免冲突。<br>设要存放的数据元素有n个，存放数据元素的内存单元有m个，设计哈希函数的目标就是要使通过哈希函数得到的n个数据元素的哈希地址尽可能均匀地分布在m个连续内存单元上，同时使计算过程尽可能简单以达到尽可能高的时间效率。<br>哈希构造函数：1．直接定址法2．数字分析法3．折叠法4．平方取中法<br>5.减去法7.除留余数法8．随机乘数法10.旋转法11.伪随机数法<br>处理冲突方法：1.链地址法 2.开放定址法 3.再散列法 4.建立一个公共溢出区 5.线性探测法 6.二次探测法 7.伪随机探测法<br>装填因子 = 关键字个数 / 表长度<br>时间复杂度O(1)</p>
<h3 id="哈希表在桶固定的情况下，时间复杂度，怎么优化。多线程中哈希表保证线程安全。哈希表特别大，桶特别多的时候怎么加锁？">哈希表在桶固定的情况下，时间复杂度，怎么优化。多线程中哈希表保证线程安全。哈希表特别大，桶特别多的时候怎么加锁？</h3><p>由于Hash桶容量的限制，所以，有可能发生Hash表填不满的情况，也就是，虽然Hash表里面还有空位，但是新建的表项由于冲突过多，而不能装入Hash表中。不过，这样的实现也有其好处，就是查表的最大开销是可以确定的，因为最多处理的冲突数是确定的，所以算法的时间复杂度为O(1)+O(m)，其中m为Hash桶容量。</p>
<h3 id="2-什么是索引？优点是什么？有哪几种索引？索引的底层实现，为什么要用B+树而不用红黑树?">2.什么是索引？优点是什么？有哪几种索引？索引的底层实现，为什么要用B+树而不用红黑树?</h3><p>关系数据库中，索引是一种单独的、物理的数对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。<br>Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。<br>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM的索引方式也叫做“非聚集”的<br>InnoDB也使用B+Tree作为索引结构，第一个重大区别是InnoDB的数据文件本身就是索引文件。第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<h3 id="6-set,map的底层实现？为什么要用红黑树？而不用AVL树？_插入删除的复杂度。">6.set,map的底层实现？为什么要用红黑树？而不用AVL树？ 插入删除的复杂度。</h3><p>红黑树</p>
<ol>
<li>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</li>
<li>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</li>
<li>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。<br>插入、删除、查找时的复杂度都为 O(log n)</li>
</ol>
<h3 id="7-hashmap的实现方式_，，实现unordered_map过程中的冲突解决办法">7.hashmap的实现方式 ，，实现unordered_map过程中的冲突解决办法</h3><p>hash_map内部是一个hash_table一般是由一个大vector，vector元素节点可挂接链表来解决冲突，来实现。hash_map其插入过程是：<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>存放key和value在桶内。</p>
<p>其取值过程是:<br>得到key<br>通过hash函数得到hash值<br>得到桶号(一般都为hash值对桶数求模)<br>比较桶的内部元素是否与key相等，若都不相等，则没有找到。<br>取出相等的记录的value。</p>
<h3 id="hash函数如何保证冲突最小">hash函数如何保证冲突最小</h3><p>1、增大 映射空间/原空间 的大小<br>2、尽可能把原数据集均匀映射到较小空间<br>3、结合原空间数据的数据特征<br>设m和n分别表示表长和表中填人的结点数，则将α=n/m定义为散列表的装填因子(load factor)。α越大，表越满，冲突的机会也越大。</p>
<h3 id="hashmap的iterator读取时是否会读到另一个线程put的数据">hashmap的iterator读取时是否会读到另一个线程put的数据</h3><h3 id="vector使用的注意点及其原因_频繁对vector调用push_back()对性能的影响和原因">vector使用的注意点及其原因 频繁对vector调用push_back()对性能的影响和原因</h3><p>1.vector支持随机存取，因此你只要知道元素的位置，可以在常数时间内存取任何一个元素；<br>2.在末端附加或删除元素，vector的性能相当好，但是在前端或中部安插或删除元素，性能就不行了，因为操作点之后的每一个元素都必须向后移动，而每一次移动都得调assignment操作符；<br>3.合适的vector大小很重要，因为capacity()返回的实际容纳的元素数量过小，vector就必须重新配置内存存储器，vector是一个动态数组，里面有一个指针指向一片连续的内存空间，当空间不够装下数据时会自动申请另一片更大的空间，然后把原有数据拷贝过去，接着释放原来的那片空间。可以使用 vector::reserve 先预留一个较大的容量。 这样在push_back 的时候就无需频繁的内存重新分配，直到预留的容量已经使用完了。<br>(1)一旦内存重新配置，和vector元素相关的所有references,pointers,iterators都会失效；<br>(2)内存重新配置很耗时间；<br>4.发生以下情况vector迭代器失效：<br>(1)使用者在一个较小索引位置上安插或移除元素<br>(2)由于容量变化而引起重新分配<br>5.vector只支持最低限度的逻辑错误检查。下标操作符的安全版本at()，是唯一被标准规格书要求可能抛出异常的一个函数，其他函数都不做检查，如果发生越界存取，会引发未定义的行为；</p>
<h3 id="红黑树的了解_,红黑树的特性与其在C++_STL中的应用,红黑树的调整_,讲讲B+树，红黑树_,红黑树的了解与其查找复杂度（红黑树的特性和复杂度是热门问题）">红黑树的了解 ,红黑树的特性与其在C++ STL中的应用,红黑树的调整 ,讲讲B+树，红黑树 ,红黑树的了解与其查找复杂度（红黑树的特性和复杂度是热门问题）</h3><p>1.每个节点不是红色就是黑色<br>2.根节点为黑色<br>3.如果子节点为红，其子节点必须为黑<br>4.任一节点至NULL的任何路径，所包含之黑节点数必须相同 </p>
<p>12.平衡二叉树转化为双向链表？</p>
<p>20.介绍更高效的建树判重数据结构 </p>
<h3 id="37-问STL内存分配，vector的实现内存管理，deque的内存管理，list的排序">37.问STL内存分配，vector的实现内存管理，deque的内存管理，list的排序</h3><p>STL分为两级配置器，当请求的内存大于128b的时候调用第一级配置器，当请求的内存小于等于128b的时候调用第二级配置器。</p>
<h3 id="51-InnoDB和MyISAM区别，对数据库包括其引擎的区别与了解">51.InnoDB和MyISAM区别，对数据库包括其引擎的区别与了解</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。MyISAM的索引方式也叫做“非聚集索引“</p>
<p>InnoDB也使用B+Tree作为索引结构。第一个重大区别是InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。<br>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<h3 id="217-B树、存储模型（B树、B+树与数据库引擎这块是热门问题）">217.B树、存储模型（B树、B+树与数据库引擎这块是热门问题）</h3><h3 id="数据库索引的作用">数据库索引的作用</h3><p>第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>第二，可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。<br>第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。<br>第四，在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。<br>第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<h3 id="mysql数据库实现层级树形结构，引擎，索引，查询优化">mysql数据库实现层级树形结构，引擎，索引，查询优化</h3><h3 id="B+树详细介绍，手画B+树">B+树详细介绍，手画B+树</h3><p>与B-Tree相比，B+Tree有以下不同点：<br>每个节点的指针上限为2d而不是2d+1。<br>内节点不存储data，只存储key；叶子节点不存储指针。</p>
<h3 id="数据库索引，联合索引，结合B+树分析">数据库索引，联合索引，结合B+树分析</h3><h3 id="数据库的索引分为哪几种，特点是什么。">数据库的索引分为哪几种，特点是什么。</h3><p>类型分类<br>1) 聚簇索引<br>按照数据存放物理位置为顺序。是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是记录指针。<br>2) 非聚簇索引<br>表数据的存储顺序和索引顺序无关。是一种密集索引，在数据页上一级索引页为每一个数据行存储一条索引记录。<br>3.2  功能分类<br>1) 唯一索引<br>不允许其中任何两行具有相同索引值的索引。<br>[数据中存在重复的键值时，大多数数据库系统不允许新创建的唯一索引和表保存，数据库中为此防止了重复数据添加。例如:在职工表姓氏上创建唯一索引，则任何两个员工都不能同姓。]<br>2) 主键索引<br>主键索引是唯一索引的特定类型。[数据库表创建主键后将自动生成主键索引，该索引要求主键中的每一个值都具有唯一性]<br>3) 聚集索引<br>表中行的物理顺序与键值的逻辑顺序相同，且一个数据表只能包含一个聚集索引。[与非聚集索引相比，聚集索引具有更快的访问速度]</p>
<p>mysql索引<br>从数据结构角度<br>1、B+树索引(O(log(n)))：关于B+树索引，可以参考 MySQL索引背后的数据结构及算法原理<br>2、hash索引：<br>a 仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询<br>b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引<br>c 只有Memory存储引擎显示支持hash索引<br>3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）<br>4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）<br>从物理存储角度<br>1、聚集索引（clustered index）<br>2、非聚集索引（non-clustered index）<br>从逻辑角度<br>1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值<br>2、普通索引或者单列索引<br>3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合<br>4、唯一索引或者非唯一索引<br>5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。</p>
<h3 id="数据库的ACID">数据库的ACID</h3><p>1）原子性（Atomicity）<br>所谓原子性就是将一组操作作为一个操作单元，是原子操作，即要么全部执行，要么全部不执行。<br>2）一致性（Consistency）<br>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。<br>3）隔离性（Isolation）<br>隔离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。<br>4）持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。即一旦一个事务提交，DBMS（Database Management System）保证它对数据库中数据的改变应该是永久性的，持久性通过数据库备份和恢复来保证。</p>
<h3 id="59-图的邻接矩阵和邻接表的表示，邻接表的数据结构。">59.图的邻接矩阵和邻接表的表示，邻接表的数据结构。</h3><p>195.LRU模仿一下内部实现，实现insert函数（插入），get(获得头部元素，但是也相当于对头部进行查询)，?<br>最开始用O(N)静态数组复杂度模拟两个函数.<br>能优化不？用堆+map标记时间复杂度降低到log(n)<br>还能优化不？<br>get函数使用双向循环链表，只是更改指针，时间复杂度降为O<1>,insert没想法优化到1了。最低logn</1></p>
<h3 id="字典树的概念，插入和删除需要注意些什么">字典树的概念，插入和删除需要注意些什么</h3><p>Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。</p>
<h3 id="字典树你有什么优化的地方">字典树你有什么优化的地方</h3><p>在标准Trie树的基础上，可以压缩：若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上的所有结点压缩成一个叶子结点。</p>
<h3 id="同样很多的字符串，你怎么尽可能少的压缩空间去存储，设计一种数据结构实现，不能使用字典树">同样很多的字符串，你怎么尽可能少的压缩空间去存储，设计一种数据结构实现，不能使用字典树</h3><h3 id="字典树构造及其优化与应用">字典树构造及其优化与应用</h3><p>对字母进行逐层划分。建立一个Trie树的过程就是不断添加新的单词的过程。由根节点向下扫描，如果不存在相应的节点则创建之。否则进入下一个层次，直到单词添加完毕。</p>
<h3 id="字典树与其在统计词频上的应用">字典树与其在统计词频上的应用</h3><p>Trie树的根为空节点，不存放数据。每个节点包含了一个指针数组，数组大小通常为26，即保存26个英文字母（如果要区分大小则数组大小为52，如果要包括数字，则要加上0-9，数组大小为62）。<br>可以想象它是一棵分支很庞大的树，会占用不少内存空间；不过它的树高不会唱过最长的字符串长度，所以查找十分快捷。典型的用空间换取时间。<br>rie树中检索的过程是走一条从跟节点开始到叶子节点的路径（不一定走到叶子节点，取决于你的Trie树的实现，如果规定每个单词以$结束，那么检索成功的话一定走到叶子节点）：如下图示意,检索单词bat的路径用红色标出。在Trie的node节点中添加count域后，可以统计单词出现的次数。统计的方法就是在插入单词的时候，令相应的count域加1（初始化为0）。代码见Trie插入部分。</p>
<h3 id="持久化数据结构，序列化与反序列化时机">持久化数据结构，序列化与反序列化时机</h3><p>可持久化数据结构 就是使数据结构可以返回历史版本<br>一般的实现方法是新建有修改的点 其他点与上一版本共用 这样做到空间复杂度带上一个或两个log<br>序列化：将程序中的对象或者数据结构转换成二进制串的过程。<br>反序列化：将在序列化过程中所生成的二进制串转换成对象或者数据结构的过程</p>
<h3 id="实现bitmap数据结构，包括数据的存储与插入方式">实现bitmap数据结构，包括数据的存储与插入方式</h3><p>位数组</p>
<h3 id="如果用bitmap解决大数量整数去重问题，计算当全为int型整数时需要消耗的内存">如果用bitmap解决大数量整数去重问题，计算当全为int型整数时需要消耗的内存</h3><p>int的最大为2^32, 内存为2^32*1byte/8/1024/1024 MB</p>
<h3 id="Bloom过滤器的实现">Bloom过滤器的实现</h3><p>位数组与hash函数联合使用，插入元素时，根据k个hash函数得到位数组的k位，将这些为置为1.查找时，利用k个hash函数得到k个位，若所有点为1，则在集合内。不是适合零错误的场合，用极少的错误换取了存储空间的极大节省。</p>
<h3 id="二叉树的遍历与实现">二叉树的遍历与实现</h3><h3 id="单链表的倒置">单链表的倒置</h3><p>网页解析的过程与实现方法<br>访问一个web页面的流程<br>有哪些地方可以做分流（DNS，服务器，数据库。。。），分别有哪些方式<br>快速排序的稳定化算法（此方法可百度到）</p>
<p>7微信红包的设计 开发 注意 用户数据的统计<br>DFA的过程与正则的区别<br>单源最短路你会哪些。说一下，时间复杂度都是多少？<br>dijska,spfa dij能优化不？(堆优化和优先队列优化两种)<br>191.给你个图，已经源点和终点，问先从源点到终点，在从源点回到终点，最短路径怎么求?时间复杂度怎么样？<br>建立两个对称图搜索+标记+剪枝<br>还有什么方法?<br>跑一点最短路。另一遍进行搜索判断 </p>
<p>2项目中的数据库备份，主从数据库、集群<br>3数据库的索引原理，b+树原理，trie树引申，二叉查找树的原理<br>4海量数据中查找一个单词，分布式计算map reduce ，或者用hsah映射筛选部分结果 </p>
<p>3、redis五种数据类型，当散列类型的value值非常大的时候怎么进行压缩，用redis怎么实现摇一摇与附近的人功能，redis主从复制过程， </p>
<p>6、其他的nosql存储<br>7、记不清了，应该还有一<br>数据库连接池用的是什么，配置文件呢，数据库驱动怎么下载的，持久层框架呢。<br>4为什么要用数据库连接池，有什么好处。 </p>
<p>7、sql，group by的理解<br>8、oracle与mysql的区别<br>9、redis了解多少<br>13 了解 数据库的存储数据的数据结构吗  不是很懂 说不会<br>14 讲讲你熟悉的nosql数据库  讲了一下redis 感觉他不是很满意<br>数据库中join的类型与区别（如果平时不怎么写业务代码，可一串int型整数存放磁盘上的压缩存储方式，包括写入与读取及内存无法一次性读取时的解决办法 </p>
<pre><code>•    Bloom过滤器的优点与原理 
•    字符串<span class="built_in">hash</span>成状态位的具体实现方式 
•    <span class="built_in">hash</span>函数如何保证冲突最小 
</code></pre><p>Bloom过滤器处理大规模问题时的持久化，包括内存大小受限、<br>数据库join的具体含义<br>mysql数据库连接池的驱动参数<br>数据库连接池如何防止失效<br>部署项目时tomcat 的参数 </p>
<p>红黑树的了解与其查找复杂度（红黑树的特性和复杂度是热门问题）<br>mysql数据库 实现层级树形结构 引擎 索引 查询优化 多方面<br>MySQL存储引擎, B+树<br>memcache了解<br>    对数据库的了解<br>    •    mysql执行的慢，如何分析<br>    •    数据库如何建立索引，以及索引的实现<br>    数据库索引，联合索引，结合B+树分析<br>    STL 相关: STL 中的内存管理(allocator)的原理, 以及如何让它线程安全。<br>    •    因为我对 STL 源码比较了解, 所以就很轻松地回答了 allocator 的实现原理, 相关实现可以参考《STL 源码剖析(侯捷)》。<br>    •    由于对线程安全了解的比较少, 所以直接我给面试官说我不知道。面试官也没多说。等到后面回答了线程安全的单例模式时, 面试官让我把那里线程安全的知识用在这里来。然后我就大概写了一下分配器工作的关键代码的伪代码, 然后试着去加锁。最后面试官还是觉得很满意的。<br>    9.超长字段有没有其他优化方式(搜索引擎？)<br>10.Redis数据结构<br>11.Redis持久化机制<br>12.基于快照的方式在持久化的过程中有其他更新怎么办<br>13.多版本并发控制<br>14.MySQL默认隔离级别？为什么(可以用next-key Lock防止幻影读)<br>15.Redis与Memcached区别<br>16.项目中Redis的使用<br>2.Redis的使用，Redis查找跟插入都很快，可以再考虑下Redis与MySQL的适用场景<br>5.MySQL索引底层实现<br>6.MySQL聚集索引与非聚集索引区别<br>7.有人建议给每张表都建一个自增主键，这样做有什么优点跟缺点<br>8.第三范式<br>3.hashmap和hashtable的区别<br>结构体和共用体区别<br>1.strcpy memcpy什么玩意的</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://geekzph.github.io/2017/08/24/面试那些事儿之数据结构/" data-id="cj6ptxv790008l3km7ifsd7nm" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2017/08/24/LeetCode-Top-100-Liked-Question-5/" class="next">LeetCode Top 100 Liked Question 5</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://geekzph.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/书摘/">书摘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/快排/" style="font-size: 15px;">快排</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/命令/" style="font-size: 15px;">命令</a> <a href="/tags/IPC/" style="font-size: 15px;">IPC</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/环境变量/" style="font-size: 15px;">环境变量</a> <a href="/tags/IO复用/" style="font-size: 15px;">IO复用</a> <a href="/tags/虚函数/" style="font-size: 15px;">虚函数</a> <a href="/tags/柔性数组/" style="font-size: 15px;">柔性数组</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/面试那些事儿之数据结构/">面试那些事儿之数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/LeetCode-Top-100-Liked-Question-5/">LeetCode Top 100 Liked Question 5</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/LeetCode-Top-100-Liked-Question-4/">LeetCode Top 100 Liked Question 4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-3/">LeetCode Top 100 Liked Question 3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-2/">LeetCode Top 100 Liked Question 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-1/">LeetCode Top 100 Liked Question 1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/C-虚函数的的实现/">C++虚函数的的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/不得不知的Linux命令/">不得不知的Linux命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/TCP协议那些事儿/">TCP协议那些事儿</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/高频题目/">高频题目</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">geekzph's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>进程间通信概述 | geekzph's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">进程间通信概述</h1><a id="logo" href="/.">geekzph's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">进程间通信概述</h1><div class="post-meta">Jul 5, 2017<span> | </span><span class="category"><a href="/categories/Linux/">Linux</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>进程间通信概述</p>
<p>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间<br>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。<br>通知时间：一个进程需要向另一个或一组进程发送消息，通知他们发生了某些事件（如进程终止时要通知父进程）<br>资源共享：多个进程之间共享同样的资源，为了做到这一点，需要内核提供锁和同步机制<br>进程控制：有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入的异常，并能够及时指导它的状态改变。<br>进程间通信方式</p>
<p>管道(pipe)，有名管道(FIFO)<br>信号(signal)<br>共享内存(shared memory)<br>消息队列(message queue)<br>信号量(semaphore)<br>套接字(socket)<br>管道</p>
<p>管道针对本地计算机的两个进程之间的通信而设计的通信方式，管道建立后，实际获得两个文件描述符：一个用于读取另一个用于写入。<br>常见的IPC机制，通过pipe系统调用。<br>管道单工，数据只能向一个方向流动。双向通信时，需要建立两个管道。<br>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道的缓冲区的尾部，每次都是从缓冲区的头部读出数据。<br>管道的分类</p>
<p>匿名管道<br>关系进程，父子或兄弟<br>由pipe系统调用，管道由父进程建立<br>管道位于内核空间，其实是一块缓存<br>有名管道（FIFO）<br>两个没有任何关系的进程之间通信可通过有名管道进行数据传输<br>通过系统调用mkfifo创建<br>管道创建</p>
<p>#include<unistd.h><br>int pipe(int fd[2]);<br>//返回：0成功，-1出错<br>两个文件描述符数组<br>fd[0]:pipe的读端<br>fd[1]:pipe的写端<br>共享内存</unistd.h></p>
<p>共享内存区域是被多个进程共享的一部分物理内存。<br>多个进程都可以把共享内存映射到自己的虚拟空间。所有用户空间的进程要操作共享内存，都要将其映射到自己的虚拟空间，通过映射的虚拟内存空间地址去操作共享内存，从而达到进程间的数据通信。<br>共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容<br>本身不提供同步机制，可通过信号量进行同步<br>提升数据处理效率，一种效率最高的IPC机制<br>共享内存属性信息</p>
<p>struct shmid_ds{<br>    struct ipc_perm shm_perm;<br>    size_t shm_semsz;//共享内存大小<br>    pid_t shm_lpid;//最后一次调用系统pid<br>    pid_t shm_cpid;//pid的创建者的id<br>    shmatt_t shm_nattch;//和共享内存成功映射的数量<br>    time_t shm_atime;//最后一个成功映射的时间<br>    time_t shm_dtime;//最后断开映射的时间<br>    time_t shm_ctime;//最后改变的时间<br>}<br>共享内存使用步骤</p>
<p>使用shmget()函数创建共享内存<br>使用shmat()函数映射共享内存，将这段创建的共享内存映射到具体的进程虚拟内存空间<br>创建共享内存</p>
<p>#include <sys shm.h=""><br>itn shmget(key_t key,size_t size,int shmflag);<br>//返回，成功返回内核中共享内存的表示iD，失败返回-1.<br>参数<br>key:用户指定的共享内存键值<br>size:共享内存大小<br>shmflg:IPC_CREAT,IPC_EXCL等权限组合<br>erron<br>EINVAL(无效的内存段大小)<br>EEXIST(内存段已经存在，无法创建)<br>EIDRM(内存段已经被删除)<br>ENOENT(内存段不存在)<br>EACCES(权限不够)<br>ENOMEM(没有足够内存创建内存段)<br>共享内存控制</sys></p>
<p>#include<sys shm.h=""><br>int shmctl(int shmid,int cmd,struct shmid_ds *buf);<br>参数<br>shmid:共享内存ID<br>buf:共享内存属性指针<br>cmd<br>IPC_STAT 获取共享内存段属性<br>IPC_SET 设置共享内存段属性<br>IPC_RMID 删除共享内存段<br>SHM_LOCK 锁定共享内存段页面<br>SHM_UNLOCK 解锁锁定<br>共享内存映射和解除</sys></p>
<p>#include<sys shm.h=""><br>void shmat(int shmid,char <em>shmaddr,int shmflg);<br>int shmdt(char  </em>shmaddr);<br>//失败返回-1<br>参数<br>shmid:共享内存ID<br>shmaddr:映射到进程虚拟内存空间的地址，系统自动分配<br>shmflg:弱shmaddr为0，shmflag也是0<br>SHM_RND<br>SHMLBA 地址为2的次方<br>SHM_RDONLY 只读方式连接<br>errno<br>EINVAL 无效的IPC ID值或无效的地址<br>ENOMEM 没有足够的内存<br>EACCES 权限不够<br>子进程不继承父进程创建的共享内存，大家是共享的，子进程继承父进程映射的地址。<br>消息队列</sys></p>
<p>消息队列是内核中的一个链表<br>用户进程将数据传输到内核后，内核重新添加一些如用户ID、组ID、读写进程的ID和优先级等相关信息后并打包成一个数据包称为消息<br>允许一个或多个进程往消息队列中读写消息，但一个消息只能被一个进程读取，读取完毕后自动删除<br>消息队列具有一定的FIFO的特性，消息可以按照顺序发送到队列中，也可以几种不同的方式从队列中读取。每一个消息队列在内核中用一个唯一的IPC标识ID表示<br>消息队列的实现包括创建和打开队列、发送消息、读取消息和控制消息队列四种操作。<br>消息队列属性</p>
<p>struct msqid_ds<br>{<br>    struct ipc_perm msg_perm;<br>    msgqnum_t msg_qnum; //消息数量<br>    msglen_t msg_qbytes; //消息最大字节数<br>    pid_t msg_lspid; //最后一次发送消息进程的pid<br>    pid_t msg_lrpid; //最后一次接收消息的pid<br>    pid_t msg_stime; //最后一次消息发送的时间<br>    pid_t msg_ctime; //最后一次消息改变的时间<br>}；<br>打开或创建消息队列</p>
<p>#include <sys msg.h=""><br>int msgget(key_t key,int flag);<br>//返回：如果成功，返回内核中消息队列的标识ID，出错返回-1<br>参数<br>key:用户指定的消息队列键值<br>flag:IPC CREAT,IPC EXCL等权限组合<br>若创建消息队列，key可以指定键值，也可以设置为IPC_PRIVATE(0)。若打开进行查询，则key不能为0，必须是一个非零的值，否则查询不到<br>消息队列控制</sys></p>
<p>#include <sys msg.h=""><br>int msgctl(int msgid,int cmd,struct msqid_ds *buf);<br>//返回：成功返回0,出错返回-1<br>参数<br>msgid：消息队列ID<br>buf：消息队列属性指针<br>cmd<br>IPC_STAT：获取消息队列的属性，取此队列的msqid_ds结构，并放在buf指向的结构中<br>IPC_SET：设置属性，按由buf只想的结构中的值，设置与此队列相关的结构中的字段<br>IPC_RMID：删除队列，从系统中删除该队列以及在队列上的所有数据。<br>发送消息</sys></p>
<p>#include <sys msg.h=""><br>int msgsnd(int msgqid,const void *ptr,size_t nbytes,int flag);<br>//成功返回0,出错返回-1</sys></p>
<p>ptr:<br>struct mymesg<br>{<br>    long mtype;//消息类型<br>    char mtext[512];//消息数据本身<br>};<br>nbytes 指定消息的大小，不包括mtype的大小<br>mtype指消息的类型，由一个整数来表示，且大于0<br>mtext消息数据本身<br>在Linux中，消息的最大长度是4056个字节，其中包括mtype，占4个字节<br>结构体mymesg用户可自定义，但第一个成员必须是mtype<br>参数flag<br>0：阻塞<br>IPC_NOWAIT:类似文件I/O的非阻塞<br>若消息队列满（或者是队列中的消息总数等于系统限制值，或队列中的字节数等于系统限制值），则指定IPC_NOWAIT使得msgsnd立即出错返回EAGAIN。如果指定0，则<br>阻塞直到有空间可以容纳要发送的消息<br>或从系统中删除了此队列<br>或捕捉到一个信号，并从信号处理程序返回<br>接收消息</p>
<p>#include <sys msg.h=""><br>ssize_t msgrcv(int msgqid,void *ptr,size_t nbytes,long type,int flag);<br>//成功返回消息数据部分的长度，出错返回-1<br>参数<br>magqid：消息队列的ID<br>ptr：指向存放消息的缓存<br>nbytes：消息缓存的大小，不包括mtype的大小。计算方式<br>nbytes=sizeof(struct mymesg)-sizeof(long)<br>type：消息类型<br>type==0：获得消息队列中的第一个消息<br>type&gt;0：获得消息队列中类型type的第一个消息<br>type&lt;0：获得消息队列中小于或等于type绝对值的消息<br>flag：0或者IPC_NOWAIT<br>信号量</sys></p>
<p>本质上是共享资源的数目，用来控制对共享资源的访问。<br>用于进程间的互斥和同步<br>每种恭喜那个资源对应一个信号量，为了便于大量共享资源的操作引入了信号量集，可对多有信号量一次性操作。对信号量集中所有的操作可以要求全部成功，也可以部分成功<br>二元信号量(信号灯)值为0和1<br>对信号量做PV操作<br>信号量集属性</p>
<p>#include<sysm.h></sysm.h></p>
<p>struct semid_ds<br>{<br>    struct ipc_perm sem_perm;<br>    unsigned short sem_nseme; //信号灯的数量<br>    time_t sem_otime; //最后一次操作的时间<br>    time_t sem_ctime; //最后一次改变的时间<br>};<br>创建信号量集</p>
<p>#include <sysm.h><br>int semget(key_t key,int nsems,int flag);<br>//返回：如果成功，返回信号量集ID，出错返回-1<br>参数<br>key:用户指定的信号量集键值<br>nsems:信号量集中信号量的个数<br>flag:IPC CREAT,IPC EXCL等权限组合<br>若创建消息队列，key可以指定键值，也可以设置为IPC_PRIVATE(0)。若打开进行查询，则key不能为0，必须是一个非零的值，否则查询不到<br>信号量集控制</sysm.h></p>
<p>#include <sys msg.h=""><br>int semctl(int semid,int semnum,int cmd,…//信号量集数组);<br>//返回：成功返回0,出错返回-1<br>union semun<br>{<br>    int val;<br>    struct semid_ds <em>buf;<br>    unsigned short </em>array;<br>}<br>参数<br>semid：信号量集ID<br>semnum：0表示对所有信号量操作，信号量标号从0开始。<br>val：防止获取或设置信号量集中某个信号量的值<br>buf：信号量属性指针<br>array：防止获取或设置信号量集中所有信号量的值<br>cmd<br>IPC_STAT：获取信号量的属性，取此队列的semid_ds结构，并放在buf指向的结构中<br>IPC_SET：设置属性，按由buf只想的结构中的值，设置与此信号量相关的结构中的字段<br>IPC_RMID：删除信号量，从系统中删除该信号量以及信号量上的所有数据。<br>信号量集操作</sys></p>
<p>#include<sysm.h><br>int semop(int semid,struct sembuf *sops,size_t nsops);<br>//成功返回0，失败返回-1</sysm.h></p>
<p>struct sembuf<br>{<br>    unsigned short sem_num; //信号量集标号<br>    short sem_op; //操作<br>    short sem_flg; //<br>}<br>参数<br>semid：信号量集ID<br>sops：sembuf结构体数组指针<br>nsops：第二个参数中结构体数组的长度<br>sem_num：信号量集中信号量的编号<br>sep_op：正数为v操作，负数为p操作，0表示对共享资源是否已用完的测试<br>sem_flg：SEM_UNDO标志，表示进程结束时，相应的操作将被取消，如果设置了该标志，那么在进程没有释放共享资源就退出时，内核将代为释放。<br>用于信号量集中信号量的PV操作<br>可用于进程见的互斥和同步</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://geekzph.github.io/2017/07/05/进程间通信概述/" data-id="cj7va9oc6000bs7kme221g6un" class="article-share-link">分享到</a><div class="tags"><a href="/tags/IPC/">IPC</a></div><div class="post-nav"><a href="/2017/08/05/二分搜索/" class="pre">二分搜索</a><a href="/2017/07/03/Python并发编程之Gevent/" class="next">Python并发编程之Gevent</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://geekzph.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/书摘/">书摘</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/快排/" style="font-size: 15px;">快排</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/剑指offer/" style="font-size: 15px;">剑指offer</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/命令/" style="font-size: 15px;">命令</a> <a href="/tags/IPC/" style="font-size: 15px;">IPC</a> <a href="/tags/TCP/" style="font-size: 15px;">TCP</a> <a href="/tags/STL/" style="font-size: 15px;">STL</a> <a href="/tags/图像/" style="font-size: 15px;">图像</a> <a href="/tags/环境变量/" style="font-size: 15px;">环境变量</a> <a href="/tags/IO复用/" style="font-size: 15px;">IO复用</a> <a href="/tags/虚函数/" style="font-size: 15px;">虚函数</a> <a href="/tags/柔性数组/" style="font-size: 15px;">柔性数组</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/17/常见排序算法总结/">常见排序算法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/剑指offer-三/">剑指offer(三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/剑指offer-二/">剑指offer(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/剑指offer-一/">剑指offer(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/LeetCode-Top-100-Liked-Question-5/">LeetCode Top 100 Liked Question 5</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/LeetCode-Top-100-Liked-Question-4/">LeetCode Top 100 Liked Question 4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-3/">LeetCode Top 100 Liked Question 3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-2/">LeetCode Top 100 Liked Question 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/LeetCode-Top-100-Liked-Question-1/">LeetCode Top 100 Liked Question 1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/C-虚函数的的实现/">C++虚函数的的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">geekzph's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>